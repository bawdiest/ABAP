class Y0BW_CL_XF_VLD_GENERIC definition
  public
  final
  create private .

public section.

  types:
*"* public components of class Y0BW_CL_XF_VLD_GENERIC
*"* do not include other source files here!!!
    BEGIN OF TS_VALUE_BUFFER,
  INFOOBJECT  Type  RSD_IOBJNM,
  ATTRIBUTE   Type  RSD_IOBJNM,
  INFOOBJECT_VALUE  Type  RSCHAVL,
  ATTRIBUTE_VALUE   Type  RSCHAVL,
      END OF TS_VALUE_BUFFER .
  types:
    Tt_VALUE_BUFFER type HASHED TABLE OF TS_VALUE_BUFFER WITH UNIQUE key INFOOBJECT ATTRIBUTE INFOOBJECT_VALUE .
  types:
    BEGIN OF Ts_RECORD_TABLE,
      infoobject type RSIOBJNM,
      value type NATXT,
      end of ts_record_table .
  types:
    tt_record_table TYPE HASHED TABLE OF ts_record_table WITH UNIQUE key infoobject .

  class-methods CALCULATE_CONCATINATED_VALUE
    importing
      !I_VALUE type RSCHAVL optional
      !I_IOBJNM type RSD_IOBJNM
      !I_RECORD_TABLE type TT_RECORD_TABLE
    returning
      value(R_VALUE) type /BIC/OF_CHAR_000030_00 .
  methods GET_ATTRIBUTE_VALUE
    importing
      !INFOOBJECT type RSD_IOBJNM
      !ATTRIBUTE type RSD_IOBJNM
      !INFOOBJECT_VALUE type RSCHAVL
    exporting
      !ATTRIBUTE_VALUE type RSCHAVL .
  methods UPDATE_RECORD_BY_RULEID
    importing
      !I_V_RULEID type Y0BW_RULE
    exporting
      !E_V_SUCCESS type BOOLEAN
      !E_V_FIELD_VALUE type RSCHAVL_MAXLEN
    changing
      !CH_S_RECORD type ANY
      !CH_CL_MESSAGES type ref to IF_RSPLFA_MSG .
  methods VALIDATE_DATAPAK
    importing
      !RBMODULE type /BIC/OIZAPPMOD
      !I_PROC_ONLY_LOCKINGS type BOOLEAN optional
    exporting
      value(SUCCESS) type BOOLEAN
    changing
      !C_TH_DATA type HASHED TABLE
      !I_R_MSG type ref to IF_RSPLFA_MSG .
  methods UPDATE_RECORD
    importing
      !RBMODULE type /BIC/OIZAPPMOD optional
      !I_R_MESSAGE type ref to IF_RSPLFA_MSG optional
      !RECNO type SYTABIX optional
      !I_PROC_ONLY_LOCKINGS type BOOLEAN default ABAP_FALSE
      !I_TRANS_FIELDS type BOOLEAN default ABAP_FALSE
    exporting
      !SUCCESS type BOOLEAN
    changing
      !RECORD type ANY .
  methods VALIDATE_RECORD
    importing
      !RBMODULE type /BIC/OIZAPPMOD optional
      !I_R_MESSAGE type ref to IF_RSPLFA_MSG
      !RECNO type SYTABIX optional
      !I_PROC_ONLY_LOCKINGS type BOOLEAN default ABAP_FALSE
    exporting
      !SUCCESS type BOOLEAN
    changing
      !RECORD type ANY .
  class-methods GET_INSTANCE
    returning
      value(RETURN) type ref to Y0BW_CL_XF_VLD_GENERIC .
  class-methods RECORD2TABLE
    importing
      !RECORD type ANY
      !I_TRANS_FIELDNM type BOOLEAN default ABAP_FALSE
    exporting
      !RECORD_TABLE type TT_RECORD_TABLE .
protected section.
*"* protected components of class Y0BW_CL_XF_VLD_GENERIC
*"* do not include other source files here!!!
private section.

*"* private components of class Y0BW_CL_XF_VLD_GENERIC
*"* do not include other source files here!!!
  constants E_MSG_CLASS type STRING value 'Y0BW_VLD' ##NO_TEXT.
  data RECORD_TABLE type TT_RECORD_TABLE .
  data VALIDATION_RULES type ref to Y0BW_CL_XF_VLD_RULE_TABLE .
  data VALUE_BUFFER type TT_VALUE_BUFFER .
  data VLD_TABLE type ref to Y0BW_CL_XF_VLD_RULE_TABLE .
  class-data INSTANCE type ref to Y0BW_CL_XF_VLD_GENERIC .

  methods _DO_EXIT_VALIDATIONS
    importing
      !I_R_VALIDATIONS type ref to Y0BW_CL_XF_VLD_RULE_TABLE
      !I_V_RBMODULE type /BIC/OIZAPPMOD optional
      !I_R_MESSAGE type ref to IF_RSPLFA_MSG optional
      !I_V_RECNO type SYTABIX optional
      !I_R_FILTER type ref to Y0BW_CL_XF_VLD_FILTER
    exporting
      !E_SUCCESS type BOOLEAN
    changing
      !C_TH_RECORD type TT_RECORD_TABLE .
  methods _DO_GENERIC_VALIDATIONS
    importing
      !I_R_VALIDATIONS type ref to Y0BW_CL_XF_VLD_RULE_TABLE
      !I_V_RBMODULE type /BIC/OIZAPPMOD optional
      !I_TH_RECORD type TT_RECORD_TABLE
      !I_R_MESSAGE type ref to IF_RSPLFA_MSG optional
      !I_V_RECNO type SYTABIX optional
      !I_R_FILTER type ref to Y0BW_CL_XF_VLD_FILTER
    exporting
      !E_SUCCESS type BOOLEAN .
  methods _DO_REAL_DERIVATIONS
    importing
      !I_R_VALIDATIONS type ref to Y0BW_CL_XF_VLD_RULE_TABLE
      !I_V_RBMODULE type /BIC/OIZAPPMOD optional
      !I_R_MESSAGE type ref to IF_RSPLFA_MSG optional
      !I_V_RECNO type SYTABIX optional
      !I_R_FILTER type ref to Y0BW_CL_XF_VLD_FILTER
    exporting
      !E_SUCCESS type BOOLEAN
    changing
      !C_TH_RECORD type TT_RECORD_TABLE .
  methods _DO_VRT_DERIVATIONS
    importing
      !I_R_VALIDATIONS type ref to Y0BW_CL_XF_VLD_RULE_TABLE
      !I_V_RBMODULE type /BIC/OIZAPPMOD optional
      !I_R_MESSAGE type ref to IF_RSPLFA_MSG
      !I_V_RECNO type SYTABIX optional
      !I_R_FILTER type ref to Y0BW_CL_XF_VLD_FILTER
    exporting
      !E_SUCCESS type BOOLEAN
    changing
      !C_TH_RECORD type TT_RECORD_TABLE .
  class-methods GET_INFOOBJECT_INFO
    importing
      !IOBJNM type RSD_IOBJNM
    exporting
      !E_T_ATR type RSD_T_ATR
      !E_T_IOBJ_CMP type RSD_T_IOBJ_CMP
      !E_S_IOBJ type RSD_S_IOBJ .
  methods PROCESS_EXIT_RULE
    importing
      !RULE_ID type Y0BW_RULE
    returning
      value(SUCCESS) type BOOLEAN
    raising
      YCX_CL_XF_VLD_EXCEPTIONS .
  methods PROCESS_GENERIC_RULE
    importing
      !RULE_ID type Y0BW_RULE
      !I_DERIVATION type BOOLEAN optional
    changing
      !RECORD_TABLE type TT_RECORD_TABLE
      value(SUCCESS) type BOOLEAN
    raising
      YCX_CL_XF_VLD_EXCEPTIONS .
  methods CONSTRUCTOR .
  methods CONVERT_TABLE2RECORD
    importing
      !RECORD_TABLE type TT_RECORD_TABLE
      !I_TRANS_FIELDNM type BOOLEAN default ABAP_FALSE
    exporting
      !RECORD type ANY .
ENDCLASS.



CLASS Y0BW_CL_XF_VLD_GENERIC IMPLEMENTATION.


method calculate_concatinated_value.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Calculate a concatinated value for a given InfoObject
*               according the record_table provided.
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        11.12.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*
  type-pools rsd.
  data:
  l_chavl               type rsd_chavl           ,
  t_dep_m               type rrsv_t_dep          ,
  s_dep_m               type rrsv_s_dep          ,
  l_v_infoobject_value  type rschavl,
  e_t_iobj_cmp          type rsd_t_iobj_cmp,
  l_s_iobj_cmp          like line of e_t_iobj_cmp,
  l_s_record_table      type ts_record_table,
  l_v_attribute_value   type rschavl,
  e_t_atr               type rsd_t_atr,
  e_msg                 type string.

  field-symbols:
  <wa_zmy_infoobject>   type any.

  call method y0bw_cl_xf_vld_generic=>get_infoobject_info
    exporting
      iobjnm       = i_iobjnm
    importing
      e_t_atr      = e_t_atr
      e_t_iobj_cmp = e_t_iobj_cmp.

  clear l_chavl.
  l_chavl = i_iobjnm .

* Set the value of Object, which should be concatinated
  if i_value is not initial. "The correct Value is provided, not needed to look in the record table
    l_v_infoobject_value = i_value.
  else.
    read table i_record_table into l_s_record_table with table key infoobject = i_iobjnm.
    if sy-subrc <> 0.
      message id y0bw_cl_xf_vld_generic=>e_msg_class
        type 'E'
        number 906
        into e_msg
        with i_iobjnm.
      raise exception type ycx_cl_xf_vld_exceptions
        exporting
          exc_type = 'E'
          msg      = e_msg.
    else.
      l_v_infoobject_value = l_s_record_table-value.
    endif.
  endif.
  sort e_t_iobj_cmp by posit ascending.

  clear t_dep_m[].
* Look for value of compounded infoobjects.
  loop at e_t_iobj_cmp into l_s_iobj_cmp.
    s_dep_m-chanm     = l_s_iobj_cmp-iobjcmp.
    read table i_record_table into l_s_record_table with table key infoobject = l_s_iobj_cmp-iobjcmp.
    if sy-subrc <> 0.
      message id y0bw_cl_xf_vld_generic=>e_msg_class
        type 'E'
        number 906
        into e_msg
        with i_iobjnm.
      raise exception type ycx_cl_xf_vld_exceptions
        exporting
          exc_type = 'E'
          msg      = e_msg.
    endif.
    s_dep_m-chavl_int = l_s_record_table-value .
    append s_dep_m to t_dep_m.
    clear s_dep_m.
  endloop.

  call function 'RRSV_CHA_VALUE_CONCATENATE'
    exporting
      i_chanm        = i_iobjnm
      i_chavl_int    = l_v_infoobject_value
    importing
      e_chavl_int    = l_v_infoobject_value
    changing
      c_t_dep        = t_dep_m
    exceptions
      unknown_chanm  = 1
      invalid_format = 2
      no_input_given = 3
      others         = 4.

  if sy-subrc <> 0.
    message id y0bw_cl_xf_vld_generic=>e_msg_class
   type 'E'
   number 900
   into e_msg.
    raise exception type ycx_cl_xf_vld_exceptions
      exporting
        exc_type = 'E'
        msg      = e_msg.
  endif.
  replace all occurrences of '#' in l_v_infoobject_value with ` `.

  r_value = l_v_infoobject_value.

endmethod.


method CONSTRUCTOR.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Standard Constructor Method
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        13.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

CALL FUNCTION 'Y0BC_WHEN_USED'.

vld_table = Y0BW_CL_XF_VLD_rule_table=>get_instance( ).

endmethod.


method convert_table2record.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Convert record to table with field description
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        17.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

  types: begin of ty_rules,
    source type string,
    target type string,
    end of ty_rules.
  data: ls_table type ts_record_table.
  data:
    lr_structdescr1 type ref to cl_abap_structdescr,
    lt_comps1       type cl_abap_structdescr=>component_table,
    lw_comp1        type line of cl_abap_structdescr=>component_table,
    lr_structdescr2 type ref to cl_abap_structdescr,
    lw_comp2        type line of cl_abap_structdescr=>component_table,
    lt_comps2       type cl_abap_structdescr=>component_table,
    lr_tabledescr   type ref to cl_abap_tabledescr,
    lr_dref         type ref to data,
    lt_sortorder    type abap_sortorder_tab,
    lt_rules        type hashed table of ty_rules with unique key source,
    ls_rules        like line of lt_rules,
    lw_record    type ref to data,
    record_table_new like record_table,
    lw_tab    type ref to data.
  data: lv_iobjnm like ls_table-infoobject.

  field-symbols:
    <lw_comp1>      type line of cl_abap_structdescr=>component_table,
    <lv_data>       type any.
  field-symbols: <table> type standard table,
                 <table_collect> type standard table,
                 <comp> type abap_compdescr,
                 <lw_record> type any,
                 <sourcecont> type any,
                 <lw_tab> type any,
                 <targetcont> type any,
                 <irgendwas> type any.

  create data lw_record like record.
  assign lw_record->* to <lw_record>.
  <lw_record> = record.
  loop at record_table into ls_table.
    if i_trans_fieldnm eq abap_false.
      assign component ls_table-infoobject of structure <lw_record> to <sourcecont>.
    else.
      clear lv_iobjnm.
      if ls_table-infoobject(1) = '0'.
        lv_iobjnm = ls_table-infoobject+1.
      else.
        concatenate '/BIC/' ls_table-infoobject into lv_iobjnm.
      endif.
      assign component lv_iobjnm of structure <lw_record> to <sourcecont>.
    endif.
    if  <sourcecont> is assigned.
      <sourcecont> = ls_table-value.
    endif.
    unassign: <sourcecont>, <targetcont>.
  endloop.
  record = <lw_record>.
endmethod.


method GET_ATTRIBUTE_VALUE.

  TYPE-POOLS rsd.
  DATA:
  l_chavl        TYPE rsd_chavl           ,
  t_dep_m        TYPE rrsv_t_dep          ,
  s_dep_m        TYPE rrsv_s_dep          ,
  l_s_viobj      TYPE rsd_s_viobj,
  E_S_IOBJ       TYPE RSD_S_IOBJ,
  l_s_readmd     TYPE rsau_s_readmd,
  l_chavl_m      TYPE rschavl             .

  DATA: l_s_value_buffer type ts_value_buffer.

  FIELD-SYMBOLS:
  <l_struct>   TYPE ANY,
  <attribute_value>     TYPE ANY.

  "First of all try to find the value in the buffered table.
  READ TABLE me->value_buffer INTO l_s_value_buffer  WITH KEY INFOOBJECT = INFOOBJECT ATTRIBUTE = ATTRIBUTE INFOOBJECT_VALUE = INFOOBJECT_VALUE.
  if sy-subrc = 0.
    attribute_value = l_s_value_buffer-attribute_value.
  else.

    CALL FUNCTION 'RSD_CHKTAB_GET_FOR_CHA_BAS'
      EXPORTING
        i_chabasnm = infoobject
      IMPORTING
        e_chktab   = l_s_readmd-chktab
      EXCEPTIONS
        name_error = 1
        OTHERS     = 2.
    IF sy-subrc <> 0.
    endif.

    CREATE DATA l_s_readmd-r_chktab TYPE (l_s_readmd-chktab).
    ASSIGN l_s_readmd-r_chktab->* TO <l_struct>.

    CALL FUNCTION 'RSAU_READ_MASTER_DATA'
      EXPORTING
        i_iobjnm                = infoobject
        i_chavl                 = infoobject_value
        I_ATTRNM                = ATTRIBUTE
        I_DATE                  = sy-datum "Decision: no dynamic date
      IMPORTING
        e_structure             = <l_struct>
      EXCEPTIONS
        read_error              = 1
        no_such_attribute       = 2
        wrong_import_parameters = 3
        chavl_not_found         = 4.

    if sy-subrc <> 0.
      "RAISE EXCEPTION TYPE ycx_cl_xf_vld_error.
    endif.

    "The structure  <l_struct> is described with fields and not infoobjects.
    "To access to value of infoobject, its neccessary to know its field name.
    CALL METHOD me->get_infoobject_info
      EXPORTING
        iobjnm   = attribute
      IMPORTING
        E_S_IOBJ = E_S_IOBJ.

    ASSIGN COMPONENT E_S_IOBJ-FIELDNM OF STRUCTURE <l_struct> TO <attribute_value>.
    IF <attribute_value> IS ASSIGNED.
      attribute_value = <attribute_value>.
      "Additionaly make an entry into buffer table.
      l_s_value_buffer-infoobject = infoobject.
      l_s_value_buffer-attribute  = attribute.
      l_s_value_buffer-infoobject_value = infoobject_value.
      l_s_value_buffer-attribute_value  = <attribute_value>.
      INSERT l_s_value_buffer INTO TABLE me->value_buffer.
      CLEAR l_s_value_buffer.
    ENDIF.

  endif.
endmethod.


method GET_INFOOBJECT_INFO.

      CALL FUNCTION 'RSD_IOBJ_GET'
      EXPORTING
               i_iobjnm       = iobjnm
      IMPORTING
        E_T_ATR      = E_T_ATR
        E_T_IOBJ_CMP = E_T_IOBJ_CMP
        E_S_IOBJ     = E_S_IOBJ
      EXCEPTIONS
        iobj_not_found = 1
        illegal_input  = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
*      MESSAGE ID sy-msgid TYPE 'E' NUMBER sy-msgno
*          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
*          RAISING read_error.
    ENDIF.

endmethod.


method GET_INSTANCE.

*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Unter Anwendung des Singleton Patterns gibt diese Methode
*               eine Instanz dieser Klasse zurück.
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        13.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

  IF instance IS NOT BOUND.
    CREATE OBJECT instance.
  ENDIF.

  return = instance.


endmethod.


method process_exit_rule.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Process direct rule.
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        17.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

  data: l_s_rule_table_head type y0bw_cl_xf_vld_rule_table=>ts_head_data,
        l_s_ruledetail      type y0bw_cl_xf_vld_rule_table=>ts_buffered_data,
        l_t_ruledetails     type y0bw_cl_xf_vld_rule_table=>tt_buffered_data,

        l_exc_text type string,
        l_ref_exc type ref to ycx_cl_xf_vld_exceptions,

        l_v_iobj_cmp type boolean,

        e_msg type string.

  type-pools rsd.
  data:
  l_chavl        type rsd_chavl           ,
  t_dep_m        type rrsv_t_dep          ,
  s_dep_m        type rrsv_s_dep          ,
  l_v_infoobject_value      type rschavl             .
  data:
  e_t_iobj_cmp  type  rsd_t_iobj_cmp,
  l_s_iobj_cmp  like line of e_t_iobj_cmp,
  l_s_record_table type ts_record_table,
  l_v_attribute_value type rschavl,

  exception_class type ref to ycx_cl_xf_vld_exceptions,
  e_t_atr type  rsd_t_atr.

  "Get rule
  clear: l_t_ruledetails, e_t_atr, e_t_iobj_cmp, l_v_infoobject_value, l_s_rule_table_head.
  call method me->validation_rules->get_rules_by_id
    exporting
      ruleid              = rule_id
    importing
      e_s_rule_table_head = l_s_rule_table_head.

* Read 1st step of validation rule

  call method validation_rules->get_ruledetails_by_id
    exporting
      ruleid           = rule_id
    importing
      e_t_rule_details = l_t_ruledetails.

  loop at l_t_ruledetails into l_s_ruledetail.
    " Get Information about Infoobject.
    try.
        call function l_s_ruledetail-fuba
          importing
            success                  = success
          changing
            c_th_record_table        = me->record_table
          exceptions
            ycx_cl_xf_vld_exceptions = 4.
        if sy-subrc <> 0.
          message id me->e_msg_class
            type 'E'
            number 905
            into e_msg
            with l_s_ruledetail-fuba rule_id.

          raise exception type ycx_cl_xf_vld_exceptions
            exporting
              exc_type = 'E'
              msg      = e_msg.

        endif.
      catch cx_sy_dyn_call_illegal_func.
        message id me->e_msg_class
          type 'E'
          number 904
          into e_msg
          with l_s_ruledetail-fuba rule_id.
        raise exception type ycx_cl_xf_vld_exceptions
          exporting
            exc_type = 'E'
            msg      = e_msg.
    endtry.

  endloop.

endmethod.


method process_generic_rule.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Process direct rule.
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        17.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

  data: l_s_rule_table_head type y0bw_cl_xf_vld_rule_table=>ts_head_data,
        l_s_ruledetail      type y0bw_cl_xf_vld_rule_table=>ts_buffered_data,
        l_t_ruledetails     type y0bw_cl_xf_vld_rule_table=>tt_buffered_data,

        l_v_iobj_cmp type boolean,

        e_msg type string.

  type-pools rsd.
  data:
  l_chavl        type rsd_chavl           ,
  t_dep_m        type rrsv_t_dep          ,
  s_dep_m        type rrsv_s_dep          ,
  lv_checker_value      type rschavl             .
  data:
  e_t_iobj_cmp  type  rsd_t_iobj_cmp,
  l_s_iobj_cmp  like line of e_t_iobj_cmp,
  l_s_record_table type ts_record_table,
  lv_checkee_value type rschavl,

  exception_class type ref to ycx_cl_xf_vld_exceptions,
  e_t_atr type  rsd_t_atr.

* Get details of the rule
  call method validation_rules->get_ruledetails_by_id
    exporting
      ruleid           = rule_id
    importing
      e_t_rule_details = l_t_ruledetails.

* Process details of the rule. For indirect rules, there are more details
  loop at l_t_ruledetails into l_s_ruledetail.

* If the checkee InfoObject is initial, and the rule is not "Derivation" -> abort checking
    read table record_table into l_s_record_table with table key infoobject = l_s_ruledetail-vld_io.
    if l_s_record_table-value is initial and i_derivation = abap_false.
      success = abap_true.
      exit.
    endif.
    clear: l_s_record_table.


* Determine if the "CHECKER" is compounded or not and if it has attributes.
    call method me->get_infoobject_info
      exporting
        iobjnm       = l_s_ruledetail-infoobject
      importing
        e_t_atr      = e_t_atr
        e_t_iobj_cmp = e_t_iobj_cmp.

    if e_t_atr is initial. "InfoObject has no attributes => Error message, and exception
      exit.
    endif.

* Get the "CHECKER" value
    " If this is not the first step (indirect rule).
    if l_s_ruledetail-stepid > 1.
      lv_checker_value = lv_checkee_value.
    else. "It's the 1st step.
      read table record_table into l_s_record_table
        with table key infoobject = l_s_ruledetail-infoobject.
      lv_checker_value = l_s_record_table-value .
    endif.

* If the first InfoObject has no value or is absent eg. it is clear in data record, exit the rule without error.
    if l_s_ruledetail-stepid = 1 and lv_checker_value is initial.
      success = abap_true.
      return.
    endif.

    if e_t_iobj_cmp is not initial. "If CHECKER" is compounded
      me->calculate_concatinated_value(
      exporting
        i_iobjnm = l_s_ruledetail-infoobject
        i_record_table = record_table
        i_value = lv_checker_value
        receiving
        r_value = lv_checker_value
        ).
    endif.

* Get the CHECKEE value.
    try.
        call method me->get_attribute_value
          exporting
            infoobject       = l_s_ruledetail-infoobject
            attribute        = l_s_ruledetail-attribute
            infoobject_value = lv_checker_value
          importing
            attribute_value  = lv_checkee_value.
      catch ycx_cl_xf_vld_exceptions.
        "Bring Error
    endtry.
  endloop.

* Process the value of the rule and set "SUCCESS" variable
  if i_derivation = abap_true. "Derivation rule => no checking; write new value into record_table
    clear l_s_record_table.
    l_s_record_table-infoobject = l_s_ruledetail-attribute.
    l_s_record_table-value = lv_checkee_value.
    delete record_table where infoobject = l_s_ruledetail-attribute.
    insert l_s_record_table into table record_table.
    success = abap_true.
  else. "Check the checkee with the attribute value.
    read table record_table into l_s_record_table with table key infoobject = l_s_ruledetail-attribute.
    if l_s_record_table-value <> lv_checkee_value and success is initial.
      success = abap_false.
    else.
      success = abap_true.
    endif.
  endif.
endmethod.


method record2table.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Convert record to table with field description
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        17.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

  types: begin of ty_rules,
    source type string,
    target type string,
    end of ty_rules.

  data: ls_table type ts_record_table.

  data:
    lr_structdescr1 type ref to cl_abap_structdescr,
    lt_comps1       type cl_abap_structdescr=>component_table,
    lw_comp1        type line of cl_abap_structdescr=>component_table,
    lr_structdescr2 type ref to cl_abap_structdescr,
    lw_comp2        type line of cl_abap_structdescr=>component_table,
    lt_comps2       type cl_abap_structdescr=>component_table,
    lr_tabledescr   type ref to cl_abap_tabledescr,
    lr_dref         type ref to data,
    lt_sortorder    type abap_sortorder_tab,

    lt_rules        type hashed table of ty_rules with unique key source,
    ls_rules        like line of lt_rules,

    lw_record    type ref to data,

    record_table_new like record_table,
    lw_tab    type ref to data.

  field-symbols:
    <lw_comp1>      type line of cl_abap_structdescr=>component_table,
    <lv_data>       type any.

  field-symbols: <table> type standard table,
                 <table_collect> type standard table,
                 <comp> type abap_compdescr,
                 <lw_record> type any,
                 <sourcecont> type any,
                 <lw_tab> type any,
                 <targetcont> type any,
                 <irgendwas> type any.

  lr_structdescr1 ?= cl_abap_structdescr=>describe_by_data(
                                                 record ).

  lt_comps1 = lr_structdescr1->get_components( ).


  loop at lt_comps1 into lw_comp1.
    clear ls_rules.
    ls_rules-source = lw_comp1-name.

    ls_table-infoobject = lw_comp1-name.

    insert ls_table into table record_table.
  endloop.

  create data lw_record like record.

  assign lw_record->* to <lw_record>.

  <lw_record> = record.

  loop at record_table into ls_table.
    assign component ls_table-infoobject of structure <lw_record> to <sourcecont>.

    if  <sourcecont> is assigned.
      ls_table-value = <sourcecont>.
      replace all occurrences of '#' in ls_table-value with ``.
    endif.

    if i_trans_fieldnm eq abap_true.
      if ls_table-infoobject(5) = '/BIC/'.
        ls_table-infoobject = ls_table-infoobject+5.
      elseif ls_table-infoobject(1) ne '0'.
        concatenate '0' ls_table-infoobject into ls_table-infoobject.
      endif.
    endif.
    unassign: <sourcecont>, <targetcont>.
    insert ls_table into table record_table_new.
  endloop.

  clear record_table.
  record_table = record_table_new.

endmethod.


method update_record.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Single record validation. Main methode.
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        17.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*
*----------------------------------------------------------------------*
* Description of Validation Process
*----------------------------------------------------------------------*
* Step 1. Get Customizing Info. Transpose record into table
* Step 2. Derivation rules
* Step 3. Process Exit Rules
* Step 4. Convert record table back into record
*
*--------------------------------------------------------------------*
  data: "record_table type tt_record_table,
        l_s_record_table type ts_record_table,
        l_t_rule_table_head type y0bw_cl_xf_vld_rule_table=>tt_head_data,
        mtext type string,
        l_exc_text type c length 200,
        l_s_rule_table_head like line of l_t_rule_table_head,
        filter_validation_class type ref to y0bw_cl_xf_vld_filter,
        success_tmp type boolean,
        l_ref_exc type ref to ycx_cl_xf_vld_exceptions.


* Step 1. Get Customizing Info. Transpose record into table
*--------------------------------------------------------------------*
  me->validation_rules = y0bw_cl_xf_vld_rule_table=>get_instance( ).
  filter_validation_class = y0bw_cl_xf_vld_filter=>get_instance( ).

  " Transform record into table for easier access.
  clear record_table.
  call method record2table
    exporting
      record          = record
      i_trans_fieldnm = abap_true
    importing
      record_table    = record_table.

  me->record_table = record_table.


* Step 2. Derivation rules
*--------------------------------------------------------------------*
  call method me->_do_real_derivations
    exporting
      i_v_recno       = recno
      i_r_validations = me->validation_rules
      i_v_rbmodule    = rbmodule
      "i_r_message     = i_r_message
      i_r_filter      = filter_validation_class
    importing
      e_success       = success
    changing
      c_th_record     = me->record_table.

  if success = abap_false.
* If not successefull
    "exit. "Cancel further processing.
  endif.


* Step 3. Process Generic Rules (incl. Exit Rules)
*--------------------------------------------------------------------*
  call method me->_do_exit_validations
    exporting
      i_v_recno       = recno
      i_r_validations = me->validation_rules
      i_v_rbmodule    = rbmodule
      "i_r_message     = i_r_message
      i_r_filter      = filter_validation_class
    importing
      e_success       = success
    changing
      c_th_record     = me->record_table.

  if success = abap_false.
* If not successefull
    "exit. "Cancel further processing.
  endif.


* Step 4. Convert record table back into record
*--------------------------------------------------------------------*
*- Transform the table back into record.
  me->convert_table2record(
  exporting
    record_table = record_table
    i_trans_fieldnm = abap_true
    importing
      record = record ).

  clear record_table.
endmethod.


method update_record_by_ruleid.

  " - Only generic (Direct, Indirect, Derivation, Virtual Derivation
  " - can be used for updating the record

  data: l_s_rule_table_head type y0bw_cl_xf_vld_rule_table=>ts_head_data,
        l_v_field_value_old type rschavl,
        l_ref_exc type ref to ycx_cl_xf_vld_exceptions,
        mtext type string,
        l_exc_text type c length 200.
  field-symbols: <fs_s_record_table> type ts_record_table.

*- Get Instance of Validation Table class
  me->validation_rules = y0bw_cl_xf_vld_rule_table=>get_instance( ).
  me->validation_rules->get_rules_by_id(
  exporting
    ruleid = i_v_ruleid
    importing
      e_s_rule_table_head = l_s_rule_table_head ).

*- Transform the record into table
  clear me->record_table.
  call method record2table
    exporting
      record       = ch_s_record
    importing
      record_table = me->record_table.

  " Read the old value (before updating)
  read table me->record_table assigning <fs_s_record_table>
   with table key infoobject = l_s_rule_table_head-vld_io.
  if sy-subrc = 0.
    l_v_field_value_old = <fs_s_record_table>-value.
  endif.

*- Call the processing of generic rules with derivation
  try.
      clear e_v_success.
      call method me->process_generic_rule
        exporting
          rule_id      = i_v_ruleid
          i_derivation = abap_true "with derivation
        changing
          record_table = me->record_table
          success      = e_v_success.
    catch ycx_cl_xf_vld_exceptions into l_ref_exc.
      l_exc_text = l_ref_exc->get_text( ).
      message id y0bw_if_vld_constants=>e_msg_class
       type y0bw_if_vld_constants=>error_type
       number y0bw_if_vld_constants=>default_message_nr
       into mtext
       with l_exc_text(50) l_exc_text+49(50) l_exc_text+99(50) l_exc_text+149(50).
      ch_cl_messages->add_msg( ).
      e_v_success = abap_false.
  endtry.

*- If the validation wasn't successeful, create a message
  if e_v_success <> abap_true.
    message id l_s_rule_table_head-messageclass
     type l_s_rule_table_head-msg_type
     number l_s_rule_table_head-messageid
     into mtext
     with l_s_rule_table_head-ruleid.
    ch_cl_messages->add_msg( ).
  endif.

*- Transform the table back into record.
  me->convert_table2record(
  exporting
    record_table = me->record_table
    importing
      record = ch_s_record ).

*- Fill the correct value of exporting field
  read table me->record_table assigning <fs_s_record_table>
   with table key infoobject = l_s_rule_table_head-vld_io.
  if sy-subrc = 0.
    e_v_field_value = <fs_s_record_table>-value.
  endif.

*- If the old value is not equal to the new value,
*- success is true, else it is false.
  if l_v_field_value_old <> e_v_field_value.
    e_v_success = abap_true.
  else.
    e_v_success = abap_false.
  endif.


endmethod.


method validate_datapak.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Validate whole data package
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        08.10.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

  data: data_record    type ref to data,
        success_tmp    type boolean.
  field-symbols: <data> type any.

  success = abap_true.

  create data data_record like line of c_th_data.
  assign data_record->* to <data>.
  loop at c_th_data into <data>.
    call method me->validate_record
      exporting
        rbmodule             = rbmodule
        i_r_message          = i_r_msg
        recno                = sy-tabix
        i_proc_only_lockings = i_proc_only_lockings
      importing
        success              = success_tmp
      changing
        record               = <data>.
    if success_tmp eq abap_false.
      success = abap_false.
    endif.
  endloop.

endmethod.


method validate_record.
*----------------------------------------------------------------------*
* Red Bull, Fuschl am See
*----------------------------------------------------------------------*
* Beschreibung: Single record validation. Main methode.
*
* SAP-Prozess : ...
*
* Grund:        ( ) QM-Meldung  : ...
*               (X) Projekt     : Validations
*               ( ) Notkorrektur: ...
*               ( ) andere      : ...
*
* Auftraggeber: Red Bull GmbH
*
* Verantwortlich / Test:
*
*-------------Aenderungsdokumentation----------------------------------*
* Edition SAP-Rel    Datum        Bearbeiter
*         Beschreibung
*----------------------------------------------------------------------*
* >001<   7.3        17.09.2012   Makarov Mikhail, CubeServ AG
*         Methode initial angelegt und implementiert
*----------------------------------------------------------------------*

*----------------------------------------------------------------------*
* Description of Validation Process
*----------------------------------------------------------------------*
* Step 1. Get Customizing Info. Transpose record into table
* Step 2. Derivation rules
* Step 3. Process Lockings
* Step 4. Process Filters
* Step 5. Process Generic Rules (incl. Exit Rules)
* Step 6. Convert record table back into record
*
*--------------------------------------------------------------------*
  data: "record_table type tt_record_table,
        l_s_record_table type ts_record_table,
        l_t_rule_table_head type y0bw_cl_xf_vld_rule_table=>tt_head_data,
        mtext type string,
        l_exc_text type c length 200,
        l_s_rule_table_head like line of l_t_rule_table_head,
        filter_validation_class type ref to y0bw_cl_xf_vld_filter,
        success_tmp type boolean,
        l_ref_exc type ref to ycx_cl_xf_vld_exceptions.


* Step 1. Get Customizing Info. Transpose record into table
*--------------------------------------------------------------------*
  me->validation_rules = y0bw_cl_xf_vld_rule_table=>get_instance( ).
  filter_validation_class = y0bw_cl_xf_vld_filter=>get_instance( ).

  " Transform record into table for easier access.
  clear record_table.
  call method record2table
    exporting
      record       = record
    importing
      record_table = record_table.

  me->record_table = record_table.


* Step 2. Derivation rules
*--------------------------------------------------------------------*
  call method me->_do_vrt_derivations
    exporting
      i_v_recno       = recno
      i_r_validations = me->validation_rules
      i_v_rbmodule    = rbmodule
      i_r_message     = i_r_message
      i_r_filter      = filter_validation_class
    importing
      e_success       = success
    changing
      c_th_record     = me->record_table.

  if success = abap_false.
* If not successefull
    exit. "Cancel further processing.
  endif.

  call method me->_do_real_derivations
    exporting
      i_v_recno       = recno
      i_r_validations = me->validation_rules
      i_v_rbmodule    = rbmodule
      i_r_message     = i_r_message
      i_r_filter      = filter_validation_class
    importing
      e_success       = success
    changing
      c_th_record     = me->record_table.

  if success = abap_false.
* If not successefull
    exit. "Cancel further processing.
  endif.

* Step 3. Process Lockings
*--------------------------------------------------------------------*
  filter_validation_class->check(
    exporting
      rbmodule = rbmodule
      record_table = record_table
      i_r_message = i_r_message
      i_recno = recno
      i_check_lockings = abap_true
      importing
        success = success ).
* Check if checking of filter was successeful.
  if success = abap_false.
* If not successefull
    exit. "Cancel further processing.
  endif.

  if i_proc_only_lockings eq abap_true.
    exit.
  endif.


* Step 4. Process Filters
*--------------------------------------------------------------------*
  filter_validation_class->check(
  exporting
    rbmodule = rbmodule
    record_table = record_table
    i_r_message = i_r_message
    i_recno = recno
    importing
      success = success
   ).
* Check if checking of filter was successeful.
  if success = abap_false.
* If not successefull
    exit. "Cancel further processing.
  endif.

* Step 5. Process Generic Rules (incl. Exit Rules)
*--------------------------------------------------------------------*
  call method me->_do_generic_validations
    exporting
      i_v_recno       = recno
      i_r_validations = me->validation_rules
      i_v_rbmodule    = rbmodule
      i_r_message     = i_r_message
      i_r_filter      = filter_validation_class
      i_th_record     = me->record_table
    importing
      e_success       = success.

  if success = abap_false.
* If not successefull
    exit. "Cancel further processing.
  endif.

  call method me->_do_exit_validations
    exporting
      i_v_recno       = recno
      i_r_validations = me->validation_rules
      i_v_rbmodule    = rbmodule
      i_r_message     = i_r_message
      i_r_filter      = filter_validation_class
    importing
      e_success       = success
    changing
      c_th_record     = me->record_table.

  if success = abap_false.
* If not successefull
    exit. "Cancel further processing.
  endif.


  " Process record InfoObject by InfoObject and get its validation rules


  " Delete record from table, so that next method call the table is initial.

*- Transform the table back into record.
  me->convert_table2record(
  exporting
    record_table = record_table
    importing
      record = record ).

  clear record_table.

endmethod.


method _do_exit_validations.
  data: l_s_record type ts_record_table.
  data: l_t_rule_table_head type y0bw_cl_xf_vld_rule_table=>tt_head_data.
  data: l_s_rule_table_head like line of l_t_rule_table_head.
  data: success_tmp type boolean.

*--------------------------------------------------------------------*
* Messages
*--------------------------------------------------------------------*
  data: l_ref_exc type ref to ycx_cl_xf_vld_exceptions.
  data: l_exc_text type c length 200.
  data: mtext type string.
*--------------------------------------------------------------------*

  loop at c_th_record into l_s_record.
    clear l_t_rule_table_head.
    call method validation_rules->get_rules_by_obj
      exporting
        infoobject          = l_s_record-infoobject
        rbmodule            = i_v_rbmodule
      importing
        e_t_rule_table_head = l_t_rule_table_head.

    " Proecess each rule
    loop at l_t_rule_table_head into l_s_rule_table_head.
      try.
          clear success_tmp.
          i_r_filter->check(
    exporting
      rbmodule = i_v_rbmodule
      record_table = record_table
      i_recno = i_v_recno
      i_rule = l_s_rule_table_head-ruleid
      importing
        success = success_tmp ).
          if success_tmp <> abap_true. e_success = abap_true. continue. endif.

          case l_s_rule_table_head-vld_rule_type.
            when 3.
              clear success_tmp.
              call method me->process_exit_rule
                exporting
                  rule_id = l_s_rule_table_head-ruleid
                receiving
                  success = e_success.
            when others.
              e_success = abap_true.
          endcase.

        catch ycx_cl_xf_vld_exceptions into l_ref_exc.
          l_exc_text = l_ref_exc->get_text( ).
          message id y0bw_if_vld_constants=>e_msg_class
           type y0bw_if_vld_constants=>error_type
           number y0bw_if_vld_constants=>default_message_nr
           into mtext
           with l_exc_text(50) l_exc_text+49(50) l_exc_text+99(50) l_exc_text+149(50).
          if i_r_message is not INITIAL. i_r_message->add_msg( ). endif.
          success_tmp = abap_false.
      endtry.

      if e_success <> abap_true.
        message id l_s_rule_table_head-messageclass
         type l_s_rule_table_head-msg_type
         number l_s_rule_table_head-messageid
         into mtext
         with i_v_recno l_s_rule_table_head-ruleid l_s_record-value.

        if i_r_message is not initial.
          i_r_message->add_msg( ).
        endif.

        e_success = abap_false. "Set overall status to false and process next rule to get all error messages
      endif.

    endloop.
  endloop.

endmethod.


method _do_generic_validations.
  data: l_s_record type ts_record_table.
  data: l_t_rule_table_head type y0bw_cl_xf_vld_rule_table=>tt_head_data.
  data: l_s_rule_table_head like line of l_t_rule_table_head.
  data: success_tmp type boolean.

*--------------------------------------------------------------------*
* Messages
*--------------------------------------------------------------------*
  data: l_ref_exc type ref to ycx_cl_xf_vld_exceptions.
  data: l_exc_text type c length 200.
  data: mtext type string.
*--------------------------------------------------------------------*

  loop at i_th_record into l_s_record.
    clear l_t_rule_table_head.
    call method validation_rules->get_rules_by_obj
      exporting
        infoobject          = l_s_record-infoobject
        rbmodule            = i_v_rbmodule
      importing
        e_t_rule_table_head = l_t_rule_table_head.

    " Proecess each rule
    loop at l_t_rule_table_head into l_s_rule_table_head.
      try.
          clear success_tmp.
          i_r_filter->check(
    exporting
      rbmodule = i_v_rbmodule
      record_table = record_table
      i_recno = i_v_recno
      i_rule = l_s_rule_table_head-ruleid
      importing
        success = success_tmp ).
          if success_tmp <> abap_true. success_tmp = abap_true. continue. endif.
          case l_s_rule_table_head-vld_rule_type.
            when 1.
              "If rule is direct
              clear success_tmp.
              call method me->process_generic_rule
                exporting
                  rule_id      = l_s_rule_table_head-ruleid
                changing
                  record_table = record_table
                  success      = success_tmp.
            when 2.
              clear success_tmp.
              call method me->process_generic_rule
                exporting
                  rule_id      = l_s_rule_table_head-ruleid
                changing
                  record_table = record_table
                  success      = success_tmp.
            when others.
              success_tmp = abap_true.
          endcase.

        catch ycx_cl_xf_vld_exceptions into l_ref_exc.
          l_exc_text = l_ref_exc->get_text( ).
          message id y0bw_if_vld_constants=>e_msg_class
           type y0bw_if_vld_constants=>error_type
           number y0bw_if_vld_constants=>default_message_nr
           into mtext
           with l_exc_text(50) l_exc_text+49(50) l_exc_text+99(50) l_exc_text+149(50).
          if i_r_message is not INITIAL. i_r_message->add_msg( ). endif.
          success_tmp = abap_false.
      endtry.

      if success_tmp <> abap_true.
        message id l_s_rule_table_head-messageclass
         type l_s_rule_table_head-msg_type
         number l_s_rule_table_head-messageid
         into mtext
         with i_v_recno l_s_rule_table_head-ruleid l_s_record-value.

        if i_r_message is not initial.
          i_r_message->add_msg( ).
        endif.

        e_success = abap_false. "Set overall status to false and process next rule to get all error messages
      endif.

    endloop.
  endloop.

endmethod.


method _do_real_derivations.
  data: l_s_record type ts_record_table.
  data: l_t_rule_table_head type y0bw_cl_xf_vld_rule_table=>tt_head_data.
  data: l_s_rule_table_head like line of l_t_rule_table_head.
  data: success_tmp type boolean.

*--------------------------------------------------------------------*
* Messages
*--------------------------------------------------------------------*
  data: l_ref_exc type ref to ycx_cl_xf_vld_exceptions.
  data: l_exc_text type c length 200.
  data: mtext type string.
*--------------------------------------------------------------------*

  loop at c_th_record into l_s_record.
    clear l_t_rule_table_head.
    call method validation_rules->get_rules_by_obj
      exporting
        infoobject          = l_s_record-infoobject
        rbmodule            = i_v_rbmodule
      importing
        e_t_rule_table_head = l_t_rule_table_head.

    " Proecess each rule
    loop at l_t_rule_table_head into l_s_rule_table_head.
      try.
          clear success_tmp.
          i_r_filter->check(
    exporting
      rbmodule = i_v_rbmodule
      record_table = record_table
      i_recno = i_v_recno
      i_rule = l_s_rule_table_head-ruleid
      importing
        success = success_tmp ).
          if success_tmp <> abap_true. success_tmp = abap_true. continue. endif.
          case l_s_rule_table_head-vld_rule_type.
            when 6.
              clear success_tmp.
              call method me->process_generic_rule
                exporting
                  rule_id      = l_s_rule_table_head-ruleid
                  i_derivation = abap_true "with derivation
                changing
                  record_table = record_table
                  success      = success_tmp.
            when others.
              success_tmp = abap_true.
          endcase.

        catch ycx_cl_xf_vld_exceptions into l_ref_exc.
          l_exc_text = l_ref_exc->get_text( ).
          message id y0bw_if_vld_constants=>e_msg_class
           type y0bw_if_vld_constants=>error_type
           number y0bw_if_vld_constants=>default_message_nr
           into mtext
           with l_exc_text(50) l_exc_text+49(50) l_exc_text+99(50) l_exc_text+149(50).
          if i_r_message is not initial. i_r_message->add_msg( ). endif.
          success_tmp = abap_false.
      endtry.

      if success_tmp <> abap_true.
        message id l_s_rule_table_head-messageclass
         type l_s_rule_table_head-msg_type
         number l_s_rule_table_head-messageid
         into mtext
         with i_v_recno l_s_rule_table_head-ruleid l_s_record-value.
        if i_r_message is not initial. i_r_message->add_msg( ). endif.

        e_success = abap_false. "Set overall status to false and process next rule to get all error messages
      endif.

    endloop.
  endloop.

endmethod.


method _DO_VRT_DERIVATIONS.
  data: l_s_record type ts_record_table.
  data: l_t_rule_table_head type y0bw_cl_xf_vld_rule_table=>tt_head_data.
  data: l_s_rule_table_head like line of l_t_rule_table_head.
  data: success_tmp type boolean.

*--------------------------------------------------------------------*
* Messages
*--------------------------------------------------------------------*
  data: l_ref_exc type ref to ycx_cl_xf_vld_exceptions.
  data: l_exc_text type c length 200.
  data: mtext type string.
*--------------------------------------------------------------------*

  loop at c_th_record into l_s_record.

    " Get Rules
    clear l_t_rule_table_head.
    call method i_r_validations->get_derivation_rules_by_obj
      exporting
        infoobject          = l_s_record-infoobject
        rbmodule            = i_v_rbmodule
      importing
        e_t_rule_table_head = l_t_rule_table_head.

    " Proecess each rule
    loop at l_t_rule_table_head into l_s_rule_table_head.
      try.
          clear success_tmp.
          i_r_filter->check(
          exporting
            rbmodule = i_v_rbmodule
            record_table = record_table
            i_recno = i_v_recno
            i_rule = l_s_rule_table_head-ruleid
            importing
              success = success_tmp ).
          if success_tmp <> abap_true. e_success = abap_true. continue. endif.
          clear e_success.
          call method me->process_generic_rule
            exporting
              rule_id      = l_s_rule_table_head-ruleid
              i_derivation = abap_true
            changing
              record_table = record_table
              success      = e_success.

        catch ycx_cl_xf_vld_exceptions into l_ref_exc.
          l_exc_text = l_ref_exc->get_text( ).
          message id y0bw_if_vld_constants=>e_msg_class
           type y0bw_if_vld_constants=>error_type
           number y0bw_if_vld_constants=>default_message_nr
           into mtext
           with l_exc_text(50) l_exc_text+49(50) l_exc_text+99(50) l_exc_text+149(50).
          i_r_message->add_msg( ).
          e_success = abap_false.

      endtry.

      if e_success <> abap_true.
        message id l_s_rule_table_head-messageclass
         type l_s_rule_table_head-msg_type
         number l_s_rule_table_head-messageid
         into mtext
         with i_v_recno l_s_rule_table_head-ruleid l_s_record-value.
        i_r_message->add_msg( ).
      endif.
      "
    endloop.
  endloop.

endmethod.
ENDCLASS.