class Y0BW_XF_KPI_IL_V2 definition
  public
  final
  create public .

public section.
*"* public components of class Y0BW_XF_KPI_IL_V2
*"* do not include other source files here!!!
  type-pools ABAP .
  type-pools RS .

  data AS_MEASURE_DETAIL type Y0BW_XF_MEAS_ID .
  data AS_MEASURE_DETAIL_M type Y0BW_XF_MEAS_ID .
  data AS_MEASURE_TEXTS type Y0BW_XF_MEAS_TXT .
  data AS_MEASURE_TEXTS_M type Y0BW_XF_MEAS_TXT .
  data AT_MEASURE_FILTERS type Y0BW_XF_MEAS_FIS_T .
  data AT_MEASURE_FILTERS_M type Y0BW_XF_MEAS_FIS_T .
  data AS_MEASURE_ADDITIONAL type Y0BW_XF_MEAS_ADD .
  data AS_MEASURE_ADDITIONAL_M type Y0BW_XF_MEAS_ADD .
  data AT_MEASURE_DIM_SETS type Y0BW_XF_MEAS_DIS_T .
  data AT_MEASURE_DIM_SETS_M type Y0BW_XF_MEAS_DIS_T .
  data AT_MEASURE_OUTPUT type Y0BW_XF_MEAS_REP_T .
  data AT_MEASURE_OUTPUT_M type Y0BW_XF_MEAS_REP_T .
  data AT_MEASURE_SETS type Y0BW_XF_MEAS_SET_T .
  data AT_MEASURE_SETS_M type Y0BW_XF_MEAS_SET_T .
  data AV_DEPENDENCY_LEVEL type INT1 value 4 ##NO_TEXT.
  data AT_BASE_MEASURES type Y0BW_XF_MEAS_BAS_T .
  data AV_BM_MULTIPLE type ABAP_BOOL read-only .

  class-methods CLASS_CONSTRUCTOR .
  class-methods DEQUEUE_MEASURE_ID
    importing
      !IV_MEASID type Y0XF_MEASID .
  class-methods ENQUEUE_MEASURE_ID
    importing
      !IV_MEASID type Y0XF_MEASID
    exceptions
      MEASURE_IS_ALREADY_LOCKED .
  class-methods FILL_MEASURE_ID .
  class-methods FILL_MEASURE_TEXT .
  class-methods FILL_MEAS_ID
    importing
      !I_DSOURCE type ROOSOURCER optional
      !I_IOBJNM type RSDIOBJNM optional
      !I_HIENM type RSHIENM optional
    returning
      value(R_Y0BW_XF_MEAS) type Y0BW_T_XF_MEAS_ID .
  class-methods GET_ACLU_HIER
    importing
      !I_GENERATE type ABAP_BOOL optional
    returning
      value(R_HIERTAB) type RSSH_T_HTAB
    exceptions
      HIERARCHY_NOT_AVAILABLE .
  class-methods GET_CORE_DIMENSIONS
    importing
      !IV_OBJVERS type Y0XF_OBJ_VERS default 'A'
    returning
      value(RT_CORE_DIMENSIONS) type Y0BW_XF_REP_DIMS_T .
  class-methods GET_DIMENSION_TEXT
    importing
      !IV_DIMNM type Y0XF_IOBJNM
    returning
      value(RV_SHORT_TEXT) type RSTXTSH .
  class-methods GET_MEASID_HIER
    importing
      !I_HIENM type RSHIENM
    returning
      value(R_HIERTAB) type Y0BW_T_HZXFMEAS
    exceptions
      HIERARCHY_NOT_AVAILABLE .
  class-methods GET_MEASID_HIER_LIST
    returning
      value(R_HIERLIST) type Y0BW_XF_S_HIERLIST_T
    exceptions
      SRC_HIERARCHY_NOT_AVAILABLE
      TGT_HIERARCHY_NOT_AVAILABLE .
  class-methods GET_MEASURE_LIST
    importing
      !IT_SEL_PARAMETERS type IF_WD_SELECT_OPTIONS=>TT_SELECTION_SCREEN_ITEM optional
      !IV_MAX_HITS type INT4 default 500
    returning
      value(RT_MEASURE_LIST) type Y0BW_XF_MEAS_ID_T .
  class-methods GET_MEASURE_LIST_TRFN
    importing
      !IV_SRC type RSBKSRCNM
      !IV_TGT type RSBKTGTNM
    returning
      value(RT_MEASURE_LIST) type Y0BW_XF_MEAS_CDM_T .
  class-methods GET_MEASURE_SINGLE_TEXT
    importing
      !IV_MEASID type Y0XF_MEASID
      !IV_LANGU type SY-LANGU default SY-LANGU
    returning
      value(RS_TEXTS) type Y0BW_XF_DS_ZXF_MEAS_TEXT .
  class-methods GET_MEASURE_TEXT
    returning
      value(R_Y0BW_XF_MEAS_TXT) type Y0BW_T_XF_DS_ZXF_MEAS_TEXT .
  class-methods GET_MEAS_IDA_DATA
    importing
      !IT_SEL_PARAMETERS type IF_WD_SELECT_OPTIONS=>TT_SELECTION_SCREEN_ITEM optional
    returning
      value(RT_IDA_DATA) type Y0BW_XF_MEAS_IDA_T .
  class-methods GET_REPORTING_DIMENSION
    importing
      !IV_DIMNM type Y0XF_IOBJNM
      !IV_OBJVERS type Y0XF_OBJ_VERS default 'A'
    returning
      value(RS_DIMENSION) type Y0BW_XF_REP_DIMS .
  class-methods GET_REPORTING_DIMENSIONS
    importing
      !IV_OBJVERS type Y0XF_OBJ_VERS default 'A'
    returning
      value(RT_DIMENSIONS) type Y0BW_XF_REP_DIMS_T .
  class-methods GET_UPHEADER_DATA
    importing
      !IV_OBJVERS type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
    exporting
      !EV_SUBRC type SYSUBRC
      !ET_RESULT type Y0BW_XF_UPHEADER_T .
  class-methods GET_Y0BW_XF_MEAS_CLUSTER
    importing
      !I_OBJVERS type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
      !I_T_RANGE_PURPOSE type RSRCC_T_RANGE
    exporting
      !E_SUBRC type SYSUBRC
      !E_T_RESULT type Y0XFU_T_TH_MEAS_CLUSTER .
  class-methods GET_Y0BW_XF_MEAS_DIS
    importing
      !I_T_RANGE_MEASID type RSRCC_T_RANGE optional
      !I_T_RANGE_DIMNM type RSRCC_T_RANGE optional
      !I_T_RANGE_PURPOSE type RSRCC_T_RANGE optional
      !I_OBJVERS type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
    exporting
      !E_SUBRC type SYSUBRC
      !E_T_RESULT type Y0BW_XF_MEAS_DIS_T .
  class-methods GET_Y0BW_XF_MEAS_FIS
    importing
      !I_T_RANGE_MEASID type RSRCC_T_RANGE optional
      !I_T_RANGE_PURPOSE type RSRCC_T_RANGE optional
      value(I_OBJVERS) type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_T_RESULT type Y0BW_XF_MEAS_FIS_T .
  class-methods GET_Y0BW_XF_MEAS_ID
    importing
      !I_T_RANGE_MEASID type RSRCC_T_RANGE
      !I_OBJVERS type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
    exporting
      !E_SUBRC type SYSUBRC
      !E_T_RESULT type Y0BW_XF_MEAS_ID_T .
  class-methods GET_Y0BW_XF_MEAS_SET
    importing
      !I_T_RANGE_MEASID type RSRCC_T_RANGE optional
      !I_T_RANGE_PURPOSE type RSRCC_T_RANGE optional
      !I_OBJVERS type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
    exporting
      !E_SUBRC type SYSUBRC
      !E_T_RESULT type Y0BW_XF_MEAS_SET_T .
  class-methods GET_Y0BW_XF_UPHEADER
    importing
      !I_OBJVERS type Y0XF_OBJ_VERS default RS_C_OBJVERS-ACTIVE
    exporting
      !E_SUBRC type SYSUBRC
      !E_T_RESULT type Y0BW_XF_UPHEADER_T .
  class-methods SAVE_MEAS_IDA_DATA
    importing
      !IT_IDA_DATA type Y0BW_XF_MEAS_IDA_T
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods ACTIVATE_MEASURE_DATA
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods CHECK_FOR_UNACTIVATED_DATA
    returning
      value(RV_EXIST) type ABAP_BOOL .
  methods CONSTRUCTOR
    importing
      !IV_MEASID type Y0XF_MEASID
      value(IV_PURPOSE) type Y0XF_PURPOSE optional
    raising
      YCX_BW_XF_KPI .
  methods DELETE_DIMENSIONS_SET
    importing
      !IV_OBJVERS type Y0XF_OBJ_VERS
      !IV_PURPOSE type Y0XF_PURPOSE
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods DELETE_MEASURE_DATA
    importing
      !IV_OBJVERS type Y0XF_OBJ_VERS
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods GET_CDM_DATA
    importing
      !IV_OBJVERS type Y0XF_OBJ_VERS default 'A'
    returning
      value(RT_CDM_DATA) type Y0BW_XF_MEAS_CDM_T .
  methods GET_CE_RESTRICTIONS
    importing
      !IV_OBJVERS type RSOBJVERS default Y0BW_CL_XF_CE_CUSTOMIZING=>AC_STATUS_ACTIVE
    exporting
      !ET_AGGREGATIONS type Y0BW_XF_T_CE_AGGREGATIONS
      !ET_FILTERS type Y0BW_XF_T_CE_FILTERS
      !ET_CONSTANT_SELECTION type Y0BW_XF_T_CE_CONSTANT .
  methods GET_DEPENDENCIES
    importing
      !IV_WHERE_USED type ABAP_BOOL default ABAP_FALSE
    returning
      value(RT_DEPENDENCIES) type Y0BW_XF_KPI_DEPENDENCIES_T .
  methods GET_DIMENSION_CLUSTER
    returning
      value(RT_DIMENSION_CLUSTER) type Y0BW_XF_MEAS_HAS_T .
  methods GET_MEASURE_ELEM_PROP
    importing
      !I_INFOPROV type RSINFOPROV
    returning
      value(R_ELEM_PROP) type Y0BW_XF_MEAS_ELEM_PROP .
  methods RELOAD_MEASURE_DATA .
  methods SAVE_MEASURE_DATA
    importing
      !IS_MEASURE_DATA type Y0BW_XF_MEAS_DATA_IMPORT_S
    returning
      value(RT_RETURN) type BAPIRET2_T .
protected section.
*"* protected components of class Y0BW_XF_KPI_IL_V2
*"* do not include other source files here!!!
private section.

  types:
*"* private components of class Y0BW_XF_KPI_IL_V2
*"* do not include other source files here!!!
    begin of ts_table_buffer,
    tabname type tabname,
    htab type ref to data,
    hash type ref to data,
    end of ts_table_buffer .
  types:
    begin of ts_hash,
    idx type sytabix,
    hash type hash160,
    end of ts_hash .
  types:
    tt_table_buffer type hashed table of ts_table_buffer with unique key tabname .

  data AV_PURPOSE type Y0XF_PURPOSE .
  data AV_MEASID type Y0XF_MEASID .
  data AV_LOCKED type ABAP_BOOL .
  class-data:
    at_cus_mpro type standard table of y0bw_xf_cus_mpro .
  data AT_TABLE_BUFFER type TT_TABLE_BUFFER .
  data AT_TABLE_TMP type TT_TABLE_BUFFER .
  data AT_CDM type Y0BW_XF_MEAS_CDM_T .

  class-methods _GENERATE_ACLU_HIER
    returning
      value(R_HIERTAB) type RSSH_T_HTAB
    exceptions
      GENERATING_ERROR .
  methods GET_BASE_MEASURES .
  methods GET_MEASURE_ADDITIONAL .
  methods GET_MEASURE_DETAIL .
  methods GET_MEASURE_DIM_SETS .
  methods GET_MEASURE_FILTERS .
  methods GET_MEASURE_OUTPUT .
  methods GET_MEASURE_SETS .
  methods GET_MEASURE_TEXTS .
  methods LOAD_MEASURE_DATA .
  methods SAVE_MEASURE_ADDITIONAL
    importing
      !IS_ADDITIONAL_DATA type Y0BW_XF_MEAS_ADD
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods SAVE_MEASURE_DIMENSIONS
    importing
      !IT_DIMENSIONS type Y0BW_XF_MEAS_SET_T
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods SAVE_MEASURE_DIM_SETS
    importing
      !IT_DIMENSION_SETS type Y0BW_XF_MEAS_DIS_T
      !IV_ADD_CORE_DIMENSIONS type ABAP_BOOL default ABAP_TRUE
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods SAVE_MEASURE_FILTERS
    importing
      !IT_DIM_FILTER type Y0BW_XF_MEAS_FIS_T
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods SAVE_MEASURE_OUTPUT
    importing
      !IT_REPORTING_SETTINGS type Y0BW_XF_MEAS_REP_T
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods SAVE_MEASURE_TEXTS
    importing
      !IS_TEXTS type Y0BW_XF_MEAS_TXT
    returning
      value(RT_RETURN) type BAPIRET2_T .
  methods _FILL_MEASURE_DIS .
  methods _FILL_MEASURE_DISSET .
  methods _FILL_MEASURE_ID .
  methods _FILL_MEASURE_TEXT .
  methods _FILL_MEAS_ADD .
  methods _FILL_MEAS_CLUSTER
    importing
      !I_HIEID type RSHIEID optional .
  methods _FILL_MEAS_REP .
  methods _GENERATE_DELTA
    importing
      !I_TABNAME type TABNAME
    changing
      !E_T_DELREC type STANDARD TABLE
      !E_T_MODREC type STANDARD TABLE .
  methods _GET_DB_TABLE
    importing
      !I_TABNAME type TABNAME
      !I_FORCE_RELOAD type BOOLEAN optional
    changing
      !C_TH_DATA type STANDARD TABLE .
  methods _MODIFY_DB_TABLE
    importing
      !I_TABNAME type TABNAME
    changing
      !C_TH_DATA type STANDARD TABLE .
  methods _SAVE_DB_TABLE
    importing
      !I_TABNAME type TABNAME
      !I_DELETE type BOOLEAN .
ENDCLASS.



CLASS Y0BW_XF_KPI_IL_V2 IMPLEMENTATION.


METHOD activate_measure_data.
  DATA: wa_xf_meas_id TYPE y0bw_xf_meas_id,
        wa_xf_meas_id_old TYPE y0bw_xf_meas_id,
        wa_xf_meas_add TYPE y0bw_xf_meas_add,
        wa_xf_meas_add_old TYPE y0bw_xf_meas_add.
  DATA: wa_xf_meas_txt_old TYPE y0bw_xf_meas_txt,
        wa_xf_meas_set_old TYPE y0bw_xf_meas_set,
        wa_xf_meas_dis_old TYPE y0bw_xf_meas_dis,
        wa_xf_meas_fis_old TYPE y0bw_xf_meas_fis,
        wa_xf_meas_rep_old TYPE y0bw_xf_meas_rep.
  DATA: lt_xf_meas_txt TYPE STANDARD TABLE OF y0bw_xf_meas_txt,
        lt_xf_meas_set TYPE STANDARD TABLE OF y0bw_xf_meas_set,
        lt_xf_meas_dis TYPE STANDARD TABLE OF y0bw_xf_meas_dis,
        lt_xf_meas_dis_old TYPE STANDARD TABLE OF y0bw_xf_meas_dis,
        lt_xf_meas_fis TYPE STANDARD TABLE OF y0bw_xf_meas_fis,
        lt_xf_meas_fis_old TYPE STANDARD TABLE OF y0bw_xf_meas_fis,
        lt_xf_meas_rep TYPE STANDARD TABLE OF y0bw_xf_meas_rep,
        lt_xf_meas_rep_old TYPE STANDARD TABLE OF y0bw_xf_meas_rep.
  DATA: lv_error TYPE flag.
  DATA: lv_purpose TYPE string.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2,
                 <wa_xf_meas_txt> TYPE y0bw_xf_meas_txt,
                 <wa_xf_meas_set> TYPE y0bw_xf_meas_set,
                 <wa_xf_meas_dis> TYPE y0bw_xf_meas_dis,
                 <wa_xf_meas_fis> TYPE y0bw_xf_meas_fis,
                 <wa_xf_meas_rep> TYPE y0bw_xf_meas_rep,
                 <wa_xf_meas_rep_old> TYPE y0bw_xf_meas_rep.

* ACTIVATE table y0bw_xf_meas_id
* Get M dataset
  SELECT SINGLE *
  INTO wa_xf_meas_id
  FROM y0bw_xf_meas_id
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Get old dataset
    SELECT SINGLE *
    INTO wa_xf_meas_id_old
    FROM y0bw_xf_meas_id
    WHERE measid = me->av_measid
    AND objvers = 'A'.

    MOVE 'A' TO wa_xf_meas_id-objvers.

* Update A dataset
    MODIFY y0bw_xf_meas_id
    FROM wa_xf_meas_id.

    IF sy-subrc IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 022 TO <wa_return>-number.
      UNASSIGN: <wa_return>.
    ELSE.
* Delete existing M dataset
      DELETE FROM y0bw_xf_meas_id
      WHERE measid = me->av_measid
        AND objvers = 'M'.

      IF wa_xf_meas_id <> wa_xf_meas_id_old.
* Log data changes
        y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_ID'
                                                  iv_object_key = me->av_measid
                                                  is_new_data   = wa_xf_meas_id
                                                  is_old_data   = wa_xf_meas_id_old ).
      ENDIF.

      CLEAR: wa_xf_meas_id_old.
    ENDIF.
  ENDIF.

* ACTIVATE table y0bw_xf_meas_add
* Get M dataset
  SELECT SINGLE *
  INTO wa_xf_meas_add
  FROM y0bw_xf_meas_add
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Get existing A dataset
    SELECT SINGLE *
    INTO wa_xf_meas_add_old
    FROM y0bw_xf_meas_add
    WHERE measid = me->av_measid
      AND objvers = 'A'.

    MOVE 'A' TO wa_xf_meas_add-objvers.

* Update A dataset
    MODIFY y0bw_xf_meas_add
    FROM wa_xf_meas_add.

    IF sy-subrc IS NOT INITIAL.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 023 TO <wa_return>-number.
      UNASSIGN: <wa_return>.
    ELSE.
      DELETE FROM y0bw_xf_meas_add
      WHERE measid = me->av_measid
        AND objvers = 'M'.

      IF wa_xf_meas_add <> wa_xf_meas_add_old.
* Log data changes
        y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_ADD'
                                                  iv_object_key = me->av_measid
                                                  is_new_data   = wa_xf_meas_add
                                                  is_old_data   = wa_xf_meas_add_old ).
      ENDIF.

      CLEAR: wa_xf_meas_add_old.
    ENDIF.
  ENDIF.

* ACTIVATE table y0bw_xf_meas_txt
* Get M datasets
  SELECT *
  INTO TABLE lt_xf_meas_txt
  FROM y0bw_xf_meas_txt
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Activate data
    LOOP AT lt_xf_meas_txt ASSIGNING <wa_xf_meas_txt>.
* Get old dataset
      SELECT SINGLE *
      INTO wa_xf_meas_txt_old
      FROM y0bw_xf_meas_txt
      WHERE measid = me->av_measid
        AND langu = <wa_xf_meas_txt>-langu
        AND objvers = 'A'.

      MOVE 'A' TO <wa_xf_meas_txt>-objvers.

* Update A dataset
      MODIFY y0bw_xf_meas_txt
      FROM <wa_xf_meas_txt>.

      IF sy-subrc IS NOT INITIAL.
        MOVE abap_true TO lv_error.
      ELSE.
        DELETE FROM y0bw_xf_meas_txt
        WHERE measid = me->av_measid
          AND langu = <wa_xf_meas_txt>-langu
          AND objvers = 'M'.

        IF sy-subrc IS INITIAL AND <wa_xf_meas_txt> <> wa_xf_meas_txt_old.
* Log data changes
          y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_TXT'
                                                    iv_object_key = me->av_measid
                                                    is_new_data   = <wa_xf_meas_txt>
                                                    is_old_data   = wa_xf_meas_txt_old ).

          CLEAR: wa_xf_meas_txt_old.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF lv_error = abap_true.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 024 TO <wa_return>-number.
      UNASSIGN: <wa_return>.

      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      EXIT.
    ENDIF.
  ENDIF.
  CLEAR: lv_error.

* ACTIVATE table y0bw_xf_meas_set
* Get M datasets
  SELECT *
  INTO TABLE lt_xf_meas_set
  FROM y0bw_xf_meas_set
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Activate data
    LOOP AT lt_xf_meas_set ASSIGNING <wa_xf_meas_set>.
* Get existing A dataset
      SELECT SINGLE *
      INTO wa_xf_meas_set_old
      FROM y0bw_xf_meas_set
      WHERE measid = me->av_measid
       AND objvers = 'A'
       AND purpose = <wa_xf_meas_set>-purpose.

      MOVE 'A' TO <wa_xf_meas_set>-objvers.

* Update A dataset
      MODIFY y0bw_xf_meas_set
      FROM <wa_xf_meas_set>.

      IF sy-subrc IS NOT INITIAL.
        MOVE abap_true TO lv_error.
      ELSE.
        DELETE FROM y0bw_xf_meas_set
        WHERE measid = me->av_measid
          AND purpose = <wa_xf_meas_set>-purpose
          AND objvers = 'M'.

        IF sy-subrc IS INITIAL AND <wa_xf_meas_set> <> wa_xf_meas_set_old.
* Log data changes
          y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_SET'
                                                    iv_object_key = me->av_measid
                                                    is_new_data   = <wa_xf_meas_set>
                                                    is_old_data   = wa_xf_meas_set_old ).

          CLEAR: wa_xf_meas_set_old.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF lv_error = abap_true.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 025 TO <wa_return>-number.
      UNASSIGN: <wa_return>.

      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      EXIT.
    ENDIF.
  ENDIF.
  CLEAR: lv_error.

* ACTIVATE table y0bw_xf_meas_dis
* Get M datasets
  SELECT *
  INTO TABLE lt_xf_meas_dis
  FROM y0bw_xf_meas_dis
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Get existing dimension sets
    SELECT *
    INTO TABLE lt_xf_meas_dis_old
    FROM y0bw_xf_meas_dis
    WHERE measid = me->av_measid
      AND objvers = 'A'.

    SORT lt_xf_meas_dis BY purpose.

* Activate dataset
    LOOP AT lt_xf_meas_dis ASSIGNING <wa_xf_meas_dis>.
      IF lv_purpose <> <wa_xf_meas_dis>-purpose.
* Delete existing sets
        DELETE FROM y0bw_xf_meas_dis
        WHERE measid = me->av_measid
          AND objvers = 'A'
          AND purpose = <wa_xf_meas_dis>-purpose.

        MOVE <wa_xf_meas_dis>-purpose TO lv_purpose.
      ENDIF.

* Get existing A dataset
      READ TABLE lt_xf_meas_dis_old
      INTO wa_xf_meas_dis_old
      WITH KEY measid = me->av_measid
               dimnm = <wa_xf_meas_dis>-dimnm
               purpose = <wa_xf_meas_dis>-purpose
               objvers = 'A'.

      MOVE 'A' TO <wa_xf_meas_dis>-objvers.

* Update A dataset
      MODIFY y0bw_xf_meas_dis
      FROM <wa_xf_meas_dis>.

      IF sy-subrc IS NOT INITIAL.
        MOVE abap_true TO lv_error.
      ELSE.
        DELETE FROM y0bw_xf_meas_dis
        WHERE measid = me->av_measid
          AND dimnm = <wa_xf_meas_dis>-dimnm
          AND purpose = <wa_xf_meas_dis>-purpose
          AND objvers = 'M'.

        IF sy-subrc IS INITIAL AND <wa_xf_meas_dis> <> wa_xf_meas_dis_old.
* Log data changes
          y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_DIS'
                                                    iv_object_key = me->av_measid
                                                    is_new_data   = <wa_xf_meas_dis>
                                                    is_old_data   = wa_xf_meas_dis_old ).

          CLEAR: wa_xf_meas_dis_old.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF lv_error = abap_true.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 026 TO <wa_return>-number.
      UNASSIGN: <wa_return>.

      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      EXIT.
    ENDIF.

    CLEAR: lv_purpose.
    FREE: lt_xf_meas_dis_old.
  ENDIF.
  CLEAR: lv_error.

* ACTIVATE table y0bw_xf_meas_fis
* Get M datasets
  SELECT *
  INTO TABLE lt_xf_meas_fis
  FROM y0bw_xf_meas_fis
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Get existing datasets
    SELECT *
    INTO TABLE lt_xf_meas_fis_old
    FROM y0bw_xf_meas_fis
    WHERE measid = me->av_measid
      AND objvers = 'A'.

    SORT lt_xf_meas_fis BY purpose.

* Activiate dataset
    LOOP AT lt_xf_meas_fis ASSIGNING <wa_xf_meas_fis>.
      IF lv_purpose <> <wa_xf_meas_fis>-purpose.
* Delete existing A datasets
        DELETE FROM y0bw_xf_meas_fis
        WHERE measid = me->av_measid
          AND objvers = 'A'
          AND purpose = <wa_xf_meas_fis>-purpose.

        MOVE <wa_xf_meas_fis>-purpose TO lv_purpose.
      ENDIF.

      MOVE 'A' TO <wa_xf_meas_fis>-objvers.

* Update A dataset
      INSERT INTO y0bw_xf_meas_fis
      VALUES <wa_xf_meas_fis>.

      IF sy-subrc IS NOT INITIAL.
        MOVE abap_true TO lv_error.
      ELSE.
        DELETE FROM y0bw_xf_meas_fis
        WHERE measid = me->av_measid
          AND dimnm = <wa_xf_meas_fis>-dimnm
          AND purpose = <wa_xf_meas_fis>-purpose
          AND index_number = <wa_xf_meas_fis>-index_number
          AND objvers = 'M'.

        IF sy-subrc IS INITIAL AND <wa_xf_meas_fis> <> wa_xf_meas_fis_old.
* Get existing A dataset
          READ TABLE lt_xf_meas_fis_old
          INTO wa_xf_meas_fis_old
          WITH KEY dimnm = <wa_xf_meas_fis>-dimnm
                   purpose = <wa_xf_meas_fis>-purpose
                   index_number = <wa_xf_meas_fis>-index_number
                   objvers = 'A'.

* Log data changes
          y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_FIS'
                                                    iv_object_key = me->av_measid
                                                    is_new_data   = <wa_xf_meas_fis>
                                                    is_old_data   = wa_xf_meas_fis_old ).

          CLEAR: wa_xf_meas_fis_old.
        ENDIF.
      ENDIF.
    ENDLOOP.

    IF lv_error = abap_true.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 027 TO <wa_return>-number.
      UNASSIGN: <wa_return>.

      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      EXIT.
    ENDIF.

    CLEAR: lv_purpose.
    FREE: lt_xf_meas_fis_old.
  ENDIF.
  CLEAR: lv_error.

* ACTIVATE table y0bw_xf_meas_rep
* Get M datasets
  SELECT *
  INTO TABLE lt_xf_meas_rep
  FROM y0bw_xf_meas_rep
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  IF sy-subrc IS INITIAL.
* Get old values
    SELECT *
    INTO TABLE lt_xf_meas_rep_old
    FROM y0bw_xf_meas_rep
    WHERE measid = me->av_measid
      AND objvers = 'A'.

* Delete existing data
    DELETE FROM y0bw_xf_meas_rep
    WHERE measid = me->av_measid
      AND objvers = 'A'.

* Activate data
    LOOP AT lt_xf_meas_rep ASSIGNING <wa_xf_meas_rep>.
* Get existing A dataset
      READ TABLE lt_xf_meas_rep_old
      INTO wa_xf_meas_rep_old
      WITH KEY measid = me->av_measid
               query = <wa_xf_meas_rep>-query
               username = <wa_xf_meas_rep>-username
               report = <wa_xf_meas_rep>-report
               paramid = <wa_xf_meas_rep>-paramid.

      MOVE 'A' TO <wa_xf_meas_rep>-objvers.

* Update A dataset
      INSERT INTO y0bw_xf_meas_rep
      VALUES <wa_xf_meas_rep>.

      IF sy-subrc IS NOT INITIAL.
        MOVE abap_true TO lv_error.
      ELSE.
        DELETE FROM y0bw_xf_meas_rep
        WHERE measid = me->av_measid
          AND query = <wa_xf_meas_rep>-query
          AND username = <wa_xf_meas_rep>-username
          AND report = <wa_xf_meas_rep>-report
          AND paramid = <wa_xf_meas_rep>-paramid
          AND objvers = 'M'.

        IF sy-subrc IS INITIAL AND <wa_xf_meas_rep> <> wa_xf_meas_rep_old.
* Log data changes
          y0bw_xf_kpi_log_master=>log_data_changes( iv_tabname    = 'Y0BW_XF_MEAS_REP'
                                                    iv_object_key = me->av_measid
                                                    is_new_data   = <wa_xf_meas_rep>
                                                    is_old_data   = wa_xf_meas_rep_old ).
        ENDIF.


* Delete dataset
        IF wa_xf_meas_rep_old IS NOT INITIAL.
          DELETE TABLE lt_xf_meas_rep_old
          FROM wa_xf_meas_rep_old.

          CLEAR: wa_xf_meas_rep_old.
        ENDIF.
      ENDIF.
    ENDLOOP.

* Delete existing temp datasets
    LOOP AT lt_xf_meas_rep_old ASSIGNING <wa_xf_meas_rep_old>.
      y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_REP'
                                                 iv_object_key   = me->av_measid
                                                 is_deleted_data = <wa_xf_meas_rep_old> ).
    ENDLOOP.

    FREE: lt_xf_meas_rep_old.

    IF lv_error = abap_true.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'E' TO <wa_return>-type.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 028 TO <wa_return>-number.
      UNASSIGN: <wa_return>.

      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      EXIT.
    ENDIF.
  ENDIF.
  CLEAR: lv_error.

* Set success message
  IF rt_return[] IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'S' TO <wa_return>-type.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 029 TO <wa_return>-number.
    UNASSIGN: <wa_return>.

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.
  ENDIF.

* Reload data
  me->load_measure_data( ).

  FREE: lt_xf_meas_txt, lt_xf_meas_set, lt_xf_meas_fis, lt_xf_meas_dis, lt_xf_meas_rep.
  CLEAR: wa_xf_meas_id, wa_xf_meas_add.
ENDMETHOD.


METHOD check_for_unactivated_data.
  IF me->av_locked = abap_false.
* Reload data
    me->load_measure_data( ).
  ENDIF.

* Check if modified data exist
  IF me->as_measure_detail_m IS NOT INITIAL OR
     me->as_measure_texts_m IS NOT INITIAL OR
     me->at_measure_filters_m[] IS NOT INITIAL OR
     me->as_measure_additional_m IS NOT INITIAL OR
     me->at_measure_dim_sets_m[] IS NOT INITIAL OR
     me->at_measure_output_m[] IS NOT INITIAL.
    MOVE abap_true TO rv_exist.
  ENDIF.
ENDMETHOD.


METHOD class_constructor.
* Track usage
  CALL FUNCTION 'Y0BC_WHEN_USED'.
ENDMETHOD.


METHOD constructor.


*  CALL FUNCTION 'Y0BC_WHEN_USED'. "PAU-JF: removed to CLASS_CONSTRUCTOR

* Set class attributes
  MOVE iv_measid TO me->av_measid.

* "PAU-JF: Purpose of Method Call: TRA (Transformation), REP (Reporting), ...
  MOVE iv_purpose TO me->av_purpose.

* Load measure data
  me->load_measure_data( ).
ENDMETHOD.


METHOD delete_dimensions_set.
  FIELD-SYMBOLS: <wa_return> TYPE bapiret2,
                 <lt_meas_dis> TYPE y0bw_xf_meas_dis_t,
                 <wa_meas_dis> TYPE y0bw_xf_meas_dis.

* Set field symbols
  IF iv_objvers = 'A'.
    ASSIGN me->at_measure_dim_sets TO <lt_meas_dis>.
  ELSEIF iv_objvers = 'M'.
    ASSIGN me->at_measure_dim_sets_m TO <lt_meas_dis>.
  ELSE.
    EXIT.
  ENDIF.

* 1. Delete dimension sets
* Write change log
  LOOP AT <lt_meas_dis> ASSIGNING <wa_meas_dis>
  WHERE purpose = iv_purpose.
    y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_DIS'
                                               iv_object_key   = me->av_measid
                                               is_deleted_data = <wa_meas_dis> ).
  ENDLOOP.

* Delete data
  DELETE FROM y0bw_xf_meas_dis
  WHERE measid = me->av_measid
    AND objvers = iv_objvers
    AND purpose = iv_purpose.

* 2. Delete measure filter sets
  DELETE FROM y0bw_xf_meas_fis
  WHERE measid = me->av_measid
    AND objvers = iv_objvers
    AND purpose = iv_purpose.

* 3. Delete measure sets
  DELETE FROM y0bw_xf_meas_set
  WHERE measid = me->av_measid
    AND objvers = iv_objvers
    AND purpose = iv_purpose.

* Set message
  APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
  MOVE 'I' TO <wa_return>.
  MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
  MOVE 055 TO <wa_return>-number.
  MOVE iv_purpose TO <wa_return>-message_v1.
  MOVE me->av_measid TO <wa_return>-message_v2.
  MOVE iv_objvers TO <wa_return>-message_v3.

* Reload data
  me->reload_measure_data( ).
ENDMETHOD.


METHOD delete_measure_data.
  DATA: lt_meas_dis TYPE STANDARD TABLE OF y0bw_xf_meas_dis.
  DATA: wa_meas_id TYPE y0bw_xf_meas_id,
        wa_meas_cdm TYPE y0bw_xf_meas_cdm,
        wa_meas_fis TYPE y0bw_xf_meas_fis,
        wa_meas_fom TYPE y0bw_xf_meas_fom,
        wa_meas_set TYPE y0bw_xf_meas_set,
        wa_meas_txt TYPE y0bw_xf_meas_txt.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2,
                 <lt_meas_dis> TYPE y0bw_xf_meas_dis_t,
                 <wa_meas_dis> TYPE y0bw_xf_meas_dis,
                 <wa_meas_id> TYPE y0bw_xf_meas_id,
                 <wa_meas_add> TYPE y0bw_xf_meas_add,
                 <lt_meas_rep> TYPE y0bw_xf_meas_rep_t,
                 <wa_meas_rep> TYPE y0bw_xf_meas_rep.

* Set field symbols
  IF iv_objvers = 'A'.
    ASSIGN me->as_measure_detail TO <wa_meas_id>.
    ASSIGN me->as_measure_additional TO <wa_meas_add>.
    ASSIGN me->at_measure_dim_sets TO <lt_meas_dis>.
    ASSIGN me->at_measure_output TO <lt_meas_rep>.
  ELSEIF iv_objvers = 'M'.
    ASSIGN me->as_measure_detail_m TO <wa_meas_id>.
    ASSIGN me->as_measure_additional_m TO <wa_meas_add>.
    ASSIGN me->at_measure_dim_sets_m TO <lt_meas_dis>.
    ASSIGN me->at_measure_output_m TO <lt_meas_rep>.
  ELSE.
    EXIT.
  ENDIF.

* 1. Delete measure ID data
* Write change log y0bw_xf_meas_id
  IF <wa_meas_id> IS ASSIGNED.
    y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_ID'
                                               iv_object_key   = me->av_measid
                                               is_deleted_data = <wa_meas_id> ).

* Delete Measure data
    DELETE FROM y0bw_xf_meas_id
    WHERE measid = me->av_measid
     AND objvers = iv_objvers.
  ENDIF.

* 2. Delete Measure Add data
* Write change log y0bw_xf_meas_add
  IF <wa_meas_add> IS ASSIGNED.
    y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_ADD'
                                               iv_object_key   = me->av_measid
                                               is_deleted_data = <wa_meas_add> ).

* Delete additional measure data
    DELETE FROM y0bw_xf_meas_add
    WHERE measid = me->av_measid
      AND objvers = iv_objvers.
  ENDIF.

* 3. Delete CDM data
* Delete measure corporate data
  DELETE FROM y0bw_xf_meas_cdm
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* 4. Delete dimension sets
* Write change log
  LOOP AT <lt_meas_dis> ASSIGNING <wa_meas_dis>.
    y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_DIS'
                                               iv_object_key   = me->av_measid
                                               is_deleted_data = <wa_meas_dis> ).
  ENDLOOP.

* Delete data
  DELETE FROM y0bw_xf_meas_dis
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* 5. Delete measure filter sets
  DELETE FROM y0bw_xf_meas_fis
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* 6. Delete measure formulas
  DELETE FROM y0bw_xf_meas_fom
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* 7. Delete measure reporting settings
* Write change log
  LOOP AT <lt_meas_rep> ASSIGNING <wa_meas_rep>.
    y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_REP'
                                               iv_object_key   = me->av_measid
                                               is_deleted_data = <wa_meas_rep> ).
  ENDLOOP.

* Delete data
  DELETE FROM y0bw_xf_meas_rep
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* 8. Delete measure sets
  DELETE FROM y0bw_xf_meas_set
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* 9. Delete measure texts
* Write change log y0bw_xf_meas_txt
  SELECT SINGLE *
  INTO wa_meas_txt
  FROM y0bw_xf_meas_txt
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

  y0bw_xf_kpi_log_master=>log_data_deletion( iv_tabname      = 'Y0BW_XF_MEAS_TXT'
                                             iv_object_key   = me->av_measid
                                             is_deleted_data = wa_meas_id ).

  CLEAR: wa_meas_txt.

* Delete data
  DELETE FROM y0bw_xf_meas_txt
  WHERE measid = me->av_measid
    AND objvers = iv_objvers.

* Set message
  APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
  MOVE 'I' TO <wa_return>.
  MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
  MOVE 054 TO <wa_return>-number.
  MOVE me->av_measid TO <wa_return>-message_v1.
  MOVE iv_objvers TO <wa_return>-message_v2.

* Reload data
  me->reload_measure_data( ).
ENDMETHOD.


METHOD dequeue_measure_id.
* Dequeue measure id
  CALL FUNCTION 'DEQUEUE_EY0BW_XF_MEAS_ID'
    EXPORTING
      mode_y0bw_xf_meas_id = 'E'
      measid               = iv_measid
      x_measid             = ' '
      _scope               = '3'
      _synchron            = ' '
      _collect             = ' '.
ENDMETHOD.


METHOD enqueue_measure_id.
* Enqueue measure
  CALL FUNCTION 'ENQUEUE_EY0BW_XF_MEAS_ID'
    EXPORTING
      mode_y0bw_xf_meas_id = 'E'
      measid               = iv_measid
      x_measid             = ' '
      _scope               = '2'
      _wait                = ' '
      _collect             = ' '
    EXCEPTIONS
      foreign_lock         = 1
      system_failure       = 2
      OTHERS               = 3.

  IF sy-subrc IS NOT INITIAL.
    RAISE measure_is_already_locked.
  ENDIF.
ENDMETHOD.


method fill_measure_id.
  data: lc_kpi type ref to y0bw_xf_kpi_il_v2.

  if lc_kpi is not bound.
    create object lc_kpi
      exporting
        iv_measid = ''.
  endif.

  lc_kpi->_fill_measure_id( ).
  lc_kpi->_fill_meas_cluster( ).
  lc_kpi->_fill_meas_rep( ).
  lc_kpi->_fill_meas_add( ).

  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_id' i_delete = abap_false ).
  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_fis' i_delete = abap_false ).
  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_set' i_delete = abap_false ).
  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_add' i_delete = abap_false ).
  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_dis' i_delete = abap_false ).
  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_rep' i_delete = abap_false ).

  lc_kpi->_fill_measure_disset( ).

  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_dis' i_delete = abap_true ).
  lc_kpi->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_set' i_delete = abap_true ).

endmethod.


method FILL_MEASURE_TEXT.
  data: lc_kpi type ref to y0bw_xf_kpi_il_v2.

  if lc_kpi is not bound.
    create object lc_kpi
      exporting
        iv_measid = ''.
  endif.

  lc_kpi->_fill_measure_text( ).
endmethod.


method fill_meas_id.




* PAU-MRI: this method fills the measure Id Table and passes the result of the table back, to use it for Datasources etc.
* Datasource is an importparameter, at now only account information is important (some things have to be hardcoded, like the appropriate sourcetables,
* so if we need more in future we can append the additional coding and steer the whole thing with the importparameter datasource



  data: ls_hiedir type rshiedir.
  data: lt_hier_accnt type standard table of /bi0/haccount.
  data: lt_y0bw_xf_meas_id type standard table of y0bw_xf_meas_id .
  data: ls_lt_y0bw_xf_meas_id like line of lt_y0bw_xf_meas_id .
  data: lt_y0bw_xf_meas_id2 type standard table of y0bw_xf_meas_id .
  data: ls_lt_y0bw_xf_meas_id2 like line of lt_y0bw_xf_meas_id .
  data: lt_y0bw_xf_meas_id3 type standard table of y0bw_xf_meas_id .
  data: ls_lt_y0bw_xf_meas_id3 like line of lt_y0bw_xf_meas_id .
  data: lt_y0bw_xf_meas_id4 type standard table of y0bw_xf_meas_id.
  data: ls_lt_y0bw_xf_meas_id4 like line of lt_y0bw_xf_meas_id .
  data: l_y0bw_xf_meas_id type y0bw_xf_meas_id.
  data: lt_measid type range of y0bw_xf_meas_id-measid.
  data: ls_measid like line of lt_measid.
  data: ld_measid type y0xf_measid.
  data: lf_measid type y0xf_measid.            "helpfield to delete leading zeros of accounts
  data: lt_new_measid type range of y0bw_xf_meas_id-measid.
  data: ls_new_measid like line of lt_measid.
  data: ld_new_measid type y0xf_measid.
  data: lt_y0bw_xf_meas_set type standard table of y0bw_xf_meas_set.
  data: ls_y0bw_xf_meas_set like line of lt_y0bw_xf_meas_set.
  data: l_y0bw_xf_meas_set type y0bw_xf_meas_set.
  data: lt_y0bw_xf_meas_dis type standard table of y0bw_xf_meas_dis.
  data: ls_y0bw_xf_meas_dis like line of lt_y0bw_xf_meas_dis.
  data: l_y0bw_xf_meas_dis type y0bw_xf_meas_dis.
  data: lt_y0bw_xf_meas_fis type standard table of y0bw_xf_meas_fis.
  data: ls_y0bw_xf_meas_fis like line of lt_y0bw_xf_meas_fis.
  data: l_y0bw_xf_meas_fis type y0bw_xf_meas_fis.
  data: lt_y0bw_xf_meas_dit type standard table of y0bw_xf_meas_dit.
  data: ls_y0bw_xf_meas_dit like line of lt_y0bw_xf_meas_dit.
  data: l_y0bw_xf_meas_dit type y0bw_xf_meas_dit.
  data: lt_y0bw_xf_meas_rep type standard table of y0bw_xf_meas_rep.
  data: ls_y0bw_xf_meas_rep like line of lt_y0bw_xf_meas_rep.
  data: l_y0bw_xf_meas_rep type y0bw_xf_meas_rep.
  data: lt_y0bw_xf_meas_gen type standard table of y0bw_xf_meas_gen.
  data: ls_y0bw_xf_meas_gen like line of lt_y0bw_xf_meas_gen.
  data: temp_y0bw_xf_meas_id type y0bw_xf_meas_id.
  data: p_update type c.

* Reference to me
  data y0bw_xf_kpi_il_v2  type ref to y0bw_xf_kpi_il_v2.

  field-symbols: <fs_hier_accnt> type /bi0/haccount .
  field-symbols: <fs_y0bw_xf_meas_id> type y0bw_xf_meas_id.

  clear  ls_hiedir.
  clear temp_y0bw_xf_meas_id.

* first get the list of hierarchies to be generated
  select * from y0bw_xf_meas_gen into table lt_y0bw_xf_meas_gen where iobjnm = '0ACCOUNT' and objvers = 'A'.
* now sort descending -> so highest priority is last (this to ensure that the overwrite runs correctly
  sort lt_y0bw_xf_meas_gen by priority descending.

* now loop over table and do the genereation for each hierarchy defined in y0bw_xf_meas_gen.
  loop at lt_y0bw_xf_meas_gen into ls_y0bw_xf_meas_gen.

* get the data of the appropriate template to derive the attributes later on.
    select * from y0bw_xf_meas_id into temp_y0bw_xf_meas_id where measid = ls_y0bw_xf_meas_gen-measure_template and objvers = 'A'.
    endselect.

* get the details of the hierarchie
    select single * from rshiedir into ls_hiedir
        where hienm = ls_y0bw_xf_meas_gen-hienm and
             objvers = 'A' and iobjnm = ls_y0bw_xf_meas_gen-iobjnm.

* read the nodenames and hierarchy itself
    select * from /bi0/haccount
              into table lt_hier_accnt
              where hieid = ls_hiedir-hieid and
                    objvers = 'A'.


* here fill the attributes
    loop at  lt_hier_accnt assigning <fs_hier_accnt> .
      clear ls_lt_y0bw_xf_meas_id .
      clear ls_y0bw_xf_meas_set.
      clear ls_y0bw_xf_meas_dis.
      clear l_y0bw_xf_meas_fis.

* when it is an account -> delete leading zeros
      if <fs_hier_accnt>-iobjnm = '0ACCOUNT'.
        move <fs_hier_accnt>-nodename+4 to lf_measid.
        shift lf_measid left deleting leading '0'.
        concatenate 'CARB' lf_measid into ls_lt_y0bw_xf_meas_id-measid.      " for measure id
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_set-measid.        " for measure set
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_dis-measid.        " for measure dis
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_fis-measid.        " for filter sets
      else.
        ls_lt_y0bw_xf_meas_id-measid = <fs_hier_accnt>-nodename.             " for measure id
        ls_y0bw_xf_meas_set-measid = <fs_hier_accnt>-nodename.              " for measure set
        ls_y0bw_xf_meas_dis-measid = <fs_hier_accnt>-nodename.               " for measure dis
        ls_y0bw_xf_meas_fis-measid = <fs_hier_accnt>-nodename.              " for filter sets
      endif.
      ls_lt_y0bw_xf_meas_id-objvers = 'A'.
*    ls_lt_y0bw_xf_meas_id-measid = <fs_hier_accnt>-nodename.     "replaced as leading zeros shall be deleted when it is an accoung
* Technical type depends if it is a node or a real infoobject (H = Node, B = infoobject)
      if  <fs_hier_accnt>-iobjnm = '0HIER_NODE'.
        ls_lt_y0bw_xf_meas_id-technical_type = 'H'.
        ls_y0bw_xf_meas_fis-high = '0HIER_NODE'.                        " for filter sets
      else.
        ls_lt_y0bw_xf_meas_id-technical_type = 'B'.
        ls_y0bw_xf_meas_fis-high = ''.                                   " for filter sets
      endif.
*    ls_lt_y0bw_xf_meas_id-def_multi_prov = ''.    " tbd
      ls_lt_y0bw_xf_meas_id-phys_key_figure = temp_y0bw_xf_meas_id-phys_key_figure.
      ls_lt_y0bw_xf_meas_id-base_measure = ''.
* physical storage depends if it is a node or infobject itself ('' = Node, 'X' = iobj)
      if  <fs_hier_accnt>-iobjnm = '0HIER_NODE'.
        ls_lt_y0bw_xf_meas_id-phys_storage = ''.
      else.
        ls_lt_y0bw_xf_meas_id-phys_storage = 'X'.
      endif.
* take the attributes from the template
      ls_lt_y0bw_xf_meas_id-phys_infoprov = temp_y0bw_xf_meas_id-phys_infoprov.
      ls_lt_y0bw_xf_meas_id-active = temp_y0bw_xf_meas_id-active.
      ls_lt_y0bw_xf_meas_id-def_multiprov = temp_y0bw_xf_meas_id-def_multiprov.
      ls_lt_y0bw_xf_meas_id-unit_conversion = temp_y0bw_xf_meas_id-unit_conversion.
      ls_lt_y0bw_xf_meas_id-unit_type = temp_y0bw_xf_meas_id-unit_type.
      ls_lt_y0bw_xf_meas_id-default_unit = temp_y0bw_xf_meas_id-default_unit.
      ls_lt_y0bw_xf_meas_id-hier_aggr = temp_y0bw_xf_meas_id-hier_aggr.
      ls_lt_y0bw_xf_meas_id-time_aggr = temp_y0bw_xf_meas_id-time_aggr.
      ls_lt_y0bw_xf_meas_id-currency_conv = temp_y0bw_xf_meas_id-currency_conv.
      ls_lt_y0bw_xf_meas_id-time_granularity = temp_y0bw_xf_meas_id-time_granularity.
      ls_lt_y0bw_xf_meas_id-time_delivery = temp_y0bw_xf_meas_id-time_delivery.
      ls_lt_y0bw_xf_meas_id-delivery_date = temp_y0bw_xf_meas_id-delivery_date.
      ls_lt_y0bw_xf_meas_id-disp_spor_data = temp_y0bw_xf_meas_id-disp_spor_data.
      ls_lt_y0bw_xf_meas_id-bench_logic = temp_y0bw_xf_meas_id-bench_logic.
      ls_lt_y0bw_xf_meas_id-workflow_status  = temp_y0bw_xf_meas_id-workflow_status.
      ls_lt_y0bw_xf_meas_id-measure_type = temp_y0bw_xf_meas_id-measure_type.
      ls_lt_y0bw_xf_meas_id-workflow_cluster  = temp_y0bw_xf_meas_id-workflow_cluster.
      ls_lt_y0bw_xf_meas_id-auth_module  = temp_y0bw_xf_meas_id-auth_module.
      ls_lt_y0bw_xf_meas_id-auth_cluster  = temp_y0bw_xf_meas_id-auth_cluster.   " entries overwritten later on by records of table y0bw_xf_meas_ida
      ls_lt_y0bw_xf_meas_id-factor  = temp_y0bw_xf_meas_id-factor.
      ls_lt_y0bw_xf_meas_id-responsible  = temp_y0bw_xf_meas_id-responsible.
      ls_lt_y0bw_xf_meas_id-accountable  = temp_y0bw_xf_meas_id-accountable.
      ls_lt_y0bw_xf_meas_id-deviation  = temp_y0bw_xf_meas_id-deviation.
      ls_lt_y0bw_xf_meas_id-relevancy  = temp_y0bw_xf_meas_id-relevancy.
*    ls_lt_y0bw_xf_meas_id-created_by  = ''.
*    ls_lt_y0bw_xf_meas_id-created_on  = ''.
*    ls_lt_y0bw_xf_meas_id-changed_by  = ''.
*    ls_lt_y0bw_xf_meas_id-changed_on  = ''.

      ls_y0bw_xf_meas_set-purpose = 'HIE'.
      ls_y0bw_xf_meas_set-objvers = 'A'.

      ls_y0bw_xf_meas_dis-purpose = 'HIE'.
      ls_y0bw_xf_meas_dis-dimnm = 'ZXF_MEAS'.
      ls_y0bw_xf_meas_dis-objvers = 'A'.

      ls_y0bw_xf_meas_fis-purpose = 'HIE'.
      ls_y0bw_xf_meas_fis-dimnm = 'ZXF_MEAS'.
      ls_y0bw_xf_meas_fis-index_number = '0001'.
      ls_y0bw_xf_meas_fis-objvers = 'A'.
      ls_y0bw_xf_meas_fis-sign = 'I'.
      ls_y0bw_xf_meas_fis-opt = 'EQ'.
      if <fs_hier_accnt>-iobjnm = '0ACCOUNT'.
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_fis-low.
        ls_y0bw_xf_meas_fis-seltp = 1.
        ls_y0bw_xf_meas_fis-hienm = ''.
        ls_y0bw_xf_meas_fis-version = ''.
        ls_y0bw_xf_meas_fis-dateto = ''.
      else.
        ls_y0bw_xf_meas_fis-low = <fs_hier_accnt>-nodename.
        ls_y0bw_xf_meas_fis-seltp = 2.
        ls_y0bw_xf_meas_fis-hienm = 'CARBPROFIT'.
        ls_y0bw_xf_meas_fis-version = 'A'.
        ls_y0bw_xf_meas_fis-dateto = '99991231'.
      endif.



* fill measure id's in a rangetable to compare them afterwards with existing entries to don't loose any information, only important for table y0bw_xf_meas_id
      move ls_lt_y0bw_xf_meas_id-measid to ld_measid.
      ls_measid-sign = 'I'.
      ls_measid-option  = 'EQ'.
      ls_measid-low = ld_measid.
      append ls_measid to lt_measid.

* append the result
      append ls_lt_y0bw_xf_meas_id to lt_y0bw_xf_meas_id .    "for measure id
      append ls_lt_y0bw_xf_meas_id to lt_y0bw_xf_meas_id4.    " checktable for changes
      append ls_y0bw_xf_meas_set to lt_y0bw_xf_meas_set.      " for measure set
      append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.      " for measure dis
      append ls_y0bw_xf_meas_fis to lt_y0bw_xf_meas_fis.      " for filter sets
    endloop.


*-------------------------------------------------------------------------------
*------------------------------------------------------------------------------
*just a try
*----------------------------------------------------------
*--------------------------------------------------------
* end of loop over lt_y0bw_xf_meas_gen
  endloop.
*----------------------------------------------------------




if p_update is initial. " now do the further checks

* do the checks if update is necessary
*1st look if in Accounthierarchie are new nodes or accounts which are not in KPI so far
* lade y0bw_xf_meas_id in interne tabelle rein (objvers A und measid like 'CARB' , sortiere nach measid. sortiere lt_y0bw_xf_meas_id nach measid.
* danach zeile für zeile vergleichen, wenn unterschied dann ist wohl was neues. und parameter p_update wird auf X gesetzt -> update ja!
* habe ein besseres Gefühl bei Änderungen immer alles upzudaten...ist weit sicherer und Änderungen passieren nicht oft!
    select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id3 where objvers = 'A' and measid like 'CARB%' and active = 'X'. " to get the actually valid entries
    sort lt_y0bw_xf_meas_id3 by measid ascending.
    sort lt_y0bw_xf_meas_id4 by measid ascending.   " workarea actually do be checked

delete ADJACENT DUPLICATES FROM lt_y0bw_xf_meas_id4 COMPARING measid. "(possible double entries remove)


      loop at lt_y0bw_xf_meas_id4 into ls_lt_y0bw_xf_meas_id4.  "go through the actual workpackage
        READ TABLE lt_y0bw_xf_meas_id3 TRANSPORTING NO FIELDS WITH KEY measid = ls_lt_y0bw_xf_meas_id4-measid. "check against entries in KPI DB

        if sy-subrc ne 0. "if nothing has been found -> the measure is new so update is needed

* collect newly determined fields maybe we need this later on.
      move ls_lt_y0bw_xf_meas_id4-measid to ld_new_measid.
      ls_new_measid-sign = 'I'.
      ls_new_measid-option  = 'EQ'.
      ls_new_measid-low = ld_measid.
      append ls_new_measid to lt_new_measid.
* set the update flag to X
          p_update = 'X'.
        endif.
      endloop.


* here rework, da passts no net ganz
*2nd check
* zuerst müssen mal alle relévanten Hierarchien eingelesen sein sonst geht das net ausserdem muss zuerst alles neue rein, dann erst da drüber gehen
* get existing ones which are not longer in the hierarchy, set them to inactive and add them to the result.
    select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id2 where objvers = 'A' and measid like 'CARB%'.
    loop at lt_y0bw_xf_meas_id2 into ls_lt_y0bw_xf_meas_id2.
      if ls_lt_y0bw_xf_meas_id2-measid not in lt_measid.
        ls_lt_y0bw_xf_meas_id2-active = ''.
        p_update = 'X'.  "update  of KPI DB necessary

        append ls_lt_y0bw_xf_meas_id2 to lt_y0bw_xf_meas_id.
         endif.
    endloop.


endif. "belongs to question if p_update is initial.
*3rd check if template has been changed

*4th check if ida table has been changed

* is update necessary, the parameter will be filled with an X and tables will be updated, else exit program.
if p_update is initial.

*fill return Parameter
    select * from y0bw_xf_meas_id into corresponding fields of table r_y0bw_xf_meas where objvers = 'A'.
* and exit
  exit.
  endif.
*----------------------------------------------------------------------------------------------------------------
*------------------------------------------------------------------------------------------------------------------


* update the table y0bw_xf_meas_id
*  loop at lt_y0bw_xf_meas_id into  l_y0bw_xf_meas_id.
*    modify y0bw_xf_meas_id from l_y0bw_xf_meas_id.
*  endloop.
    modify y0bw_xf_meas_id from table lt_y0bw_xf_meas_id.
*
*
** update the table y0bw_xf_meas_set
**  loop at lt_y0bw_xf_meas_set into l_y0bw_xf_meas_set.
**    modify y0bw_xf_meas_set from l_y0bw_xf_meas_set.
**  endloop.
    modify y0bw_xf_meas_set from table lt_y0bw_xf_meas_set.
*
*
** update the table y0bw_xf_meas_dis, but before delete 'old' entries
*    delete from y0bw_xf_meas_dis where measid like 'CARB%'
*    and objvers = 'A'.
**  loop at lt_y0bw_xf_meas_dis into l_y0bw_xf_meas_dis.
**    modify y0bw_xf_meas_dis from l_y0bw_xf_meas_dis.
**  endloop.
    modify y0bw_xf_meas_dis from table lt_y0bw_xf_meas_dis.
*
*
** update the table y0bw_xf_meas_fis
**  loop at lt_y0bw_xf_meas_fis into l_y0bw_xf_meas_fis.
**    modify y0bw_xf_meas_fis from l_y0bw_xf_meas_fis.
**  endloop.
*   modify y0bw_xf_meas_fis from table lt_y0bw_xf_meas_fis.
*
** to go for sure
    commit work.


* update y0bw_xf_meas from y0bw_xf_meas_ida
*    create object y0bw_xf_kpi_il_v2
*      exporting
*        iv_measid = ''.

*    call method y0bw_xf_kpi_il_v2->_FILL_MEAS_CLUSTER.
* fill reptable = update y0bw_xf_meas_rep from y0bw_xf_rep_ida
*    call method y0bw_xf_kpi_il_v2->fill_meas_rep.


* fill y0bw_xf_meas_set, y0bw_xf_meas_dis with GEN information
* read relevant information from ID Table (only Hierarchynodes and active)
    clear: lt_y0bw_xf_meas_id, ls_lt_y0bw_xf_meas_id, lt_y0bw_xf_meas_dis, ls_y0bw_xf_meas_dis, lt_y0bw_xf_meas_dit, ls_y0bw_xf_meas_dit.
    clear: lt_y0bw_xf_meas_set, ls_y0bw_xf_meas_set, l_y0bw_xf_meas_set.

    select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id where objvers = 'A' and technical_type = 'H'.
    select * from y0bw_xf_meas_dit into table  lt_y0bw_xf_meas_dit where hienm = 'CARBPROFIT'.      "Contains the possible dimensions for CO
    loop at lt_y0bw_xf_meas_id into ls_lt_y0bw_xf_meas_id.

      loop at lt_y0bw_xf_meas_dit into ls_y0bw_xf_meas_dit.

        ls_y0bw_xf_meas_dis-measid = ls_lt_y0bw_xf_meas_id-measid.
        ls_y0bw_xf_meas_dis-dimnm = ls_y0bw_xf_meas_dit-dimension.
        ls_y0bw_xf_meas_dis-objvers = 'A'.
        ls_y0bw_xf_meas_dis-purpose = 'GEN'.
        ls_y0bw_xf_meas_dis-optional = ls_y0bw_xf_meas_dit-optional.

        append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.

* create entries for set
        ls_y0bw_xf_meas_set-measid = ls_lt_y0bw_xf_meas_id-measid.
        ls_y0bw_xf_meas_set-objvers = 'A'.
        ls_y0bw_xf_meas_set-purpose = 'GEN'.
        append ls_y0bw_xf_meas_set to lt_y0bw_xf_meas_set.

      endloop.
    endloop.

* update the table y0bw_xf_meas_dis
    modify y0bw_xf_meas_dis from table lt_y0bw_xf_meas_dis.


* update table y0bw_xf_meas_set
    modify y0bw_xf_meas_set from table lt_y0bw_xf_meas_set.

    clear: lt_y0bw_xf_meas_id.

* fill entries and string Source_system in Table y0bw_xf_meas_add
*    call method y0bw_xf_kpi_il_v2->_FILL_MEAS_ADD.


*  select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id where objvers = 'A'.
*  fill return parameter, e.g for datasource
*  r_y0bw_xf_meas = lt_y0bw_xf_meas_id.

*fill return Parameter
    select * from y0bw_xf_meas_id into corresponding fields of table r_y0bw_xf_meas where objvers = 'A'.



** end of loop over lt_y0bw_xf_meas_gen
*  endloop.

endmethod.


METHOD get_aclu_hier.
  DATA: ls_hiedir TYPE rshiedir ,
        ls_hiekey    TYPE rsndi_s_hiekey,
        ls_subtrsel  TYPE rssh_s_nodebynamewol,
        ls_hierstruc TYPE rsndi_s_htab,
        lt_hierstruc TYPE TABLE OF rsndi_s_htab,
        lv_subrc     TYPE sy-subrc
    .

*Only read h-table and export
  IF i_generate = '' .
* get the details of the hierarchie
    SELECT SINGLE * FROM rshiedir INTO ls_hiedir
        WHERE objvers = 'A' AND iobjnm = 'ZXF_ACLU' AND  hienm = 'AUTHORIZATION' .

    IF sy-subrc <> 0.
      RAISE hierarchy_not_available.
    ELSE.

      clear   ls_HIEKEY .
      MOVE-CORRESPONDING  ls_hiedir to  ls_HIEKEY .

      CALL FUNCTION 'RSNDI_SHIE_STRUCTURE_GET3'
        EXPORTING
          i_s_hiekey        = ls_HIEKEY
*         I_S_HIESEL        =
*         i_s_subtreesel    = ls_subtrsel
*         I_T_NODENAME      =
*         I_NO_NODENM_TABLE = RS_C_FALSE
        IMPORTING
          e_subrc           = lv_subrc
        TABLES
          e_t_hierstruc     = r_hiertab.


      IF lv_subrc   <> 0 .
        RAISE   hierarchy_not_available .
      ENDIF .
    ENDIF .
*genreate new one
  ELSE.

    y0bw_xf_kpi_il_v2=>_generate_aclu_hier(
      RECEIVING
        r_hiertab        = r_hiertab
      EXCEPTIONS
        generating_error = 1
           ).
    IF sy-subrc <> 0.
      RAISE hierarchy_not_available.
    ENDIF.


  ENDIF .
ENDMETHOD.


METHOD get_base_measures.
**************START**************
*developer:           Iwan Uchanow
*last change:         30.09.2014
*task:                KPI Enhancements - base measures
*responsible person:  Doris Kern
  DATA: lv_compid         TYPE rszcompid,
        lt_range          TYPE TABLE OF RSZRANGE,
        lt_base_measures  TYPE y0bw_xf_meas_bas_t,
        lv_base_measure   TYPE y0bw_xf_meas_bas_s,
        lv_bm_lines       TYPE i,
        lv_compuid        TYPE SYSUUID_25,
        lv_multiprov      TYPE STRING.

  FIELD-SYMBOLS: <ls_range>  TYPE RSZRANGE.

* Build compif search string
  CONCATENATE me->as_measure_detail-def_multiprov '_RKF_%' me->av_measid INTO lv_compid.

* Search for correct compid
  SELECT SINGLE compuid
  FROM rszcompdir
  INTO lv_compuid
  WHERE compid LIKE lv_compid
    AND objvers = 'A'.

* Get all selections for current restricted key figure
  SELECT *
  FROM rszrange
  INTO CORRESPONDING FIELDS OF TABLE lt_range
  WHERE eltuid = lv_compuid
    AND objvers = 'A'.

*loop over all selections
  LOOP AT lt_range ASSIGNING <ls_range> WHERE iobjnm = 'ZXF_MEAS' OR iobjnm = '1KYFNM'.
*if selection is a calculated key figure -> low is a uid and not a compid
    IF <ls_range>-iobjnm = '1KYFNM' AND <ls_range>-seltp = 5.
      SELECT SINGLE compid
      FROM rszcompdir
      INTO lv_compid
      WHERE compuid = <ls_range>-low
        AND objvers = 'A'.
*       Check if component exists
        IF SY-SUBRC = 0.
*         check if calculated key figure is a auxiliary key figure
          FIND '_CKF_99' IN lv_compid.
          IF SY-SUBRC = 0.
            SPLIT lv_compid AT '_CKF_99' INTO lv_multiprov lv_base_measure.
          ENDIF.
*         check if calculated key figure is standard
          FIND '_CKF_00' IN lv_compid.
          IF SY-SUBRC = 0.
            SPLIT lv_compid AT '_CKF_00' INTO lv_multiprov lv_base_measure.
          ENDIF.
        ENDIF.
    ENDIF.
*if selection is a calculated key figure and selection type is 7 -> low is a uid and not a compid
    IF <ls_range>-iobjnm = '1KYFNM' AND <ls_range>-seltp = 7.
      SELECT SINGLE compid
      FROM rszcompdir
      INTO lv_compid
      WHERE compuid = <ls_range>-low
        AND objvers = 'A'.
      SPLIT lv_compid AT '_CKF_00' INTO lv_multiprov lv_base_measure.
    ENDIF.
*if selection is a restricted key figure and selection type is 7 -> low is a uid and not a compid
    IF <ls_range>-iobjnm = '1KYFNM' AND <ls_range>-seltp = 7.
      SELECT SINGLE compid
      FROM rszcompdir
      INTO lv_compid
      WHERE compuid = <ls_range>-low
        AND objvers = 'A'.
*       Check if component exists
        IF SY-SUBRC = 0.
*         check if restricted key figure is a auxiliary key figure
          FIND '_RKF_99' IN lv_compid.
          IF SY-SUBRC = 0.
            SPLIT lv_compid AT '_RKF_99' INTO lv_multiprov lv_base_measure.
          ENDIF.
*         check if restricted key figure is standard
          FIND '_RKF_00' IN lv_compid.
          IF SY-SUBRC = 0.
            SPLIT lv_compid AT '_RKF_00' INTO lv_multiprov lv_base_measure.
          ENDIF.
        ENDIF.
    ENDIF.
    IF <ls_range>-iobjnm = 'ZXF_MEAS' AND <ls_range>-seltp = 1.
      lv_base_measure-base_measure = <ls_range>-low.
    ENDIF.
    IF lv_base_measure <> ''.
      APPEND lv_base_measure TO lt_base_measures.
    ENDIF.
  ENDLOOP.

  DESCRIBE TABLE lt_base_measures LINES lv_bm_lines.

  IF lv_bm_lines > 1.
*    me->as_measure_detail-base_measure = 'multiple'.
    me->av_bm_multiple = 'X'.
  ENDIF.

  me->at_base_measures = lt_base_measures.

ENDMETHOD.
**************END**************


  METHOD get_cdm_data.
* Get data from database
    SELECT *
    INTO TABLE me->at_cdm
    FROM y0bw_xf_meas_cdm
    WHERE measid = me->av_measid.

* Return cdm data from buffer
    rt_cdm_data[] = me->at_cdm[].

* Delete not necessary cdm data
    DELETE rt_cdm_data
    WHERE objvers <> iv_objvers.
  ENDMETHOD.


  METHOD get_ce_restrictions.
* Get aggregation values
    DATA(lt_aggregations) = y0bw_cl_xf_ce_customizing=>get_instance( )->get_aggregation( iv_measid               = me->av_measid
                                                                                         iv_objvers              = iv_objvers
                                                                                         iv_structure_field_name = abap_false ).

    MOVE-CORRESPONDING lt_aggregations TO et_aggregations.

* Get calculation key fields
    DATA(lt_calc_key) = y0bw_cl_xf_ce_customizing=>get_instance( )->get_calculation_key( iv_measid               = me->av_measid
                                                                                         iv_objvers              = iv_objvers
                                                                                         iv_structure_field_name = abap_false ).

    LOOP AT et_aggregations ASSIGNING FIELD-SYMBOL(<wa_aggregations>).
* Check if field exist also in calculation key table
      IF NOT line_exists( lt_calc_key[ char_key = <wa_aggregations>-aggr_char ] ).
        DELETE TABLE et_aggregations FROM <wa_aggregations>.
      ENDIF.
    ENDLOOP.

* Get filter values
    DATA(lt_filter) = y0bw_cl_xf_ce_customizing=>get_instance( )->get_filter( iv_measid               = me->av_measid
                                                                              iv_objvers              = iv_objvers
                                                                              iv_seltp                = y0bw_cl_xf_ce_customizing=>ac_seltp_sel_opt
                                                                              iv_structure_field_name = abap_false  ).

    MOVE-CORRESPONDING lt_filter TO et_filters.

* Get constant selection values
    DATA(lt_constant_selection) = y0bw_cl_xf_ce_customizing=>get_instance( )->get_filter( iv_measid               = me->av_measid
                                                                                          iv_objvers              = iv_objvers
                                                                                          iv_seltp                = y0bw_cl_xf_ce_customizing=>ac_seltp_query_var
                                                                                          iv_structure_field_name = abap_false  ).

    MOVE-CORRESPONDING lt_constant_selection TO et_constant_selection.

    FREE: lt_aggregations, lt_filter, lt_constant_selection, lt_calc_key.
  ENDMETHOD.


METHOD get_core_dimensions.
* Get core dimensions
  SELECT *
  INTO TABLE rt_core_dimensions
  FROM y0bw_xf_rep_dims
  WHERE core_dim = abap_true
    AND objvers = iv_objvers.
ENDMETHOD.


METHOD get_dependencies.
  DATA: lt_compounds TYPE y0bw_xf_kpi_compounds_t.

* Get compounds kpi object
  DATA(obj_compounds) = NEW y0bw_xf_kpi_compounds( me->av_measid ).

  IF iv_where_used = abap_true.
* Get where used
    lt_compounds = obj_compounds->get_where_used( ).
  ELSE.
* Get components
    lt_compounds = obj_compounds->get_components( ).
  ENDIF.

  MOVE-CORRESPONDING lt_compounds TO rt_dependencies.

  FREE: lt_compounds.
  FREE: obj_compounds.
ENDMETHOD.


METHOD get_dimension_cluster.
* Get dimension cluster
  SELECT *
  INTO TABLE rt_dimension_cluster
  FROM y0bw_xf_meas_has
  WHERE except_cluster = me->as_measure_detail-except_cluster.
ENDMETHOD.


METHOD get_dimension_text.
* Get dimension text
  MOVE y0bw_xf_dimension_il=>get_single_dimension( iv_dimnm )->as_texts-txtsh TO rv_short_text.
ENDMETHOD.


method get_measid_hier.

  data: ls_hiedir type rshiedir.

* get the details of the hierarchie
  select single * from rshiedir into ls_hiedir
      where hienm = i_hienm and
           objvers = 'A' and iobjnm = 'ZXF_MEAS'.

if sy-subrc <> 0.
  RAISE HIERARCHY_NOT_AVAILABLE.
endif.

* read the nodenames and hierarchy itself
  select * from /bic/hzxf_meas
            into table r_hiertab
            where hieid = ls_hiedir-hieid and
                  objvers = 'A'.
endmethod.


method get_measid_hier_list .


  CONSTANTS:
          lc_IOBJNM TYPE Y0XF_IOBJNM value 'ZXF_MEAS'  .

  data:    ls_hiedir type rshiedir
         , lt_hier TYPE STANDARD TABLE OF rshiedir
         , lt_meas_hier TYPE STANDARD TABLE OF rshiedir
         , lt_Y0BW_XF_MEAS_GEN TYPE STANDARD TABLE OF Y0BW_XF_MEAS_GEN
         , ls_Y0BW_XF_S_HIERLIST TYPE Y0BW_XF_S_HIERLIST
         , lt_Y0BW_XF_S_HIERLIST type STANDARD TABLE OF Y0BW_XF_S_HIERLIST
         .


  FIELD-SYMBOLS:   <fs_Y0BW_XF_MEAS_GEN> TYPE Y0BW_XF_MEAS_GEN
                 , <fs_hier> TYPE rshiedir
                 , <fs_hier_meas> TYPE rshiedir
                 .

  clear  ls_hiedir .

**************
*INIT
select * into CORRESPONDING FIELDS OF TABLE lt_Y0BW_XF_MEAS_GEN
  from Y0BW_XF_MEAS_GEN where OBJVERS = 'A' .

* get the details hierarchy data
select  * into TABLE lt_hier
  from rshiedir for all ENTRIES IN lt_Y0BW_XF_MEAS_GEN
  where IOBJNM = lt_Y0BW_XF_MEAS_GEN-IOBJNM and objvers = 'A' .

* get the details for meas data
select  * into TABLE lt_meas_hier
  from rshiedir
  where IOBJNM = lc_IOBJNM  and objvers = 'A' .


DESCRIBE TABLE lt_hier  .
if sy-tfill < 1  .
    RAISE SRC_HIERARCHY_NOT_AVAILABLE.
endif .


DESCRIBE TABLE lt_meas_hier .
if sy-tfill < 1  .
      RAISE TGT_HIERARCHY_NOT_AVAILABLE.
endif .



************************
*GET LIST
loop at lt_Y0BW_XF_MEAS_GEN ASSIGNING <fs_Y0BW_XF_MEAS_GEN>.
  clear: ls_Y0BW_XF_S_HIERLIST .
  move <fs_Y0BW_XF_MEAS_GEN>-IOBJNM to ls_Y0BW_XF_S_HIERLIST-SRC_OBJECT .
  move <fs_Y0BW_XF_MEAS_GEN>-HIENM to ls_Y0BW_XF_S_HIERLIST-SRC_HIENM .
  move <fs_Y0BW_XF_MEAS_GEN>-PRIORITY to ls_Y0BW_XF_S_HIERLIST-PRIORITY .
  loop at lt_hier ASSIGNING  <fs_hier> where HIENM = <fs_Y0BW_XF_MEAS_GEN>-HIENM and IOBJNM = <fs_Y0BW_XF_MEAS_GEN>-IOBJNM .
    ls_Y0BW_XF_S_HIERLIST-SRC_HIEID =  <fs_hier>-HIEID .
    LOOP AT lt_meas_hier ASSIGNING <fs_hier_meas> where  HIENM = <fs_Y0BW_XF_MEAS_GEN>-HIENM .
       move lc_IOBJNM  to ls_Y0BW_XF_S_HIERLIST-TGT_OBJECT  .
       move <fs_hier_meas>-HIENM to ls_Y0BW_XF_S_HIERLIST-TGT_HIENM .
       move <fs_hier_meas>-HIEID to ls_Y0BW_XF_S_HIERLIST-TGT_HIEID .
       APPEND ls_Y0BW_XF_S_HIERLIST to R_HIERLIST   .
    endloop.
  endloop .
ENDLOOP .

sort r_HIERLIST by PRIORITY .

endmethod.


METHOD get_measure_additional.
* Get measure detail Active dataset
  SELECT SINGLE *
  INTO me->as_measure_additional
  FROM y0bw_xf_meas_add
  WHERE measid = me->av_measid
    AND objvers = 'A'.

* Get measure detail Modified dataset
  SELECT SINGLE *
  INTO me->as_measure_additional_m
  FROM y0bw_xf_meas_add
  WHERE measid = me->av_measid
    AND objvers = 'M'.
ENDMETHOD.


METHOD get_measure_detail.
* Get measure detail Active dataset
  SELECT SINGLE *
  INTO me->as_measure_detail
  FROM y0bw_xf_meas_id
  WHERE measid = me->av_measid
    AND objvers = 'A'.

  IF me->av_purpose IS INITIAL.

* Get measure detail Modified dataset
    SELECT SINGLE *
    INTO me->as_measure_detail_m
    FROM y0bw_xf_meas_id
    WHERE measid = me->av_measid
      AND objvers = 'M'.

  ENDIF.

*  IF me->as_measure_detail IS INITIAL AND me->as_measure_detail_m IS INITIAL.
*    RAISE EXCEPTION TYPE ycx_bw_xf_kpi
*      EXPORTING
*        textid = 'MEASURE_ID_NOT_EXIST'.
*  ENDIF.
ENDMETHOD.


METHOD get_measure_dim_sets.
* Get measure detail Active dataset
  SELECT *
  INTO TABLE me->at_measure_dim_sets
  FROM y0bw_xf_meas_dis
  WHERE measid = me->av_measid
    AND objvers = 'A'.

* Get measure detail Modified dataset
  SELECT *
  INTO TABLE me->at_measure_dim_sets_m
  FROM y0bw_xf_meas_dis
  WHERE measid = me->av_measid
    AND objvers = 'M'.
ENDMETHOD.


METHOD get_measure_elem_prop.

**********************************************************************
*** This methods returns query element properties
**********************************************************************

  DATA: value_kpidb TYPE i,
        expo_kpidb  TYPE i,
        s_cus_mpro  TYPE y0bw_xf_cus_mpro.

  FIELD-SYMBOLS:  <measure_output> TYPE y0bw_xf_meas_rep.

  r_elem_prop-measid = av_measid.

  " Check decimal places rsz_x_eltprop-NUM_PREC Nachkomma
  LOOP AT at_measure_output ASSIGNING <measure_output>
    WHERE measid = av_measid AND
          paramid = 'DECPLACES_TABLE' AND
          objvers = 'A' AND
          report = '' AND
          component = '' AND
          query = '' AND
          username = ''.
    IF <measure_output>-value <> 'none'.
      value_kpidb = <measure_output>-value.
      r_elem_prop-num_prec = value_kpidb.
    ENDIF.

  ENDLOOP.

  "rsz_x_eltprop-NUM_SCALE Scaling
  LOOP AT at_measure_output ASSIGNING <measure_output>
    WHERE measid = av_measid AND
      paramid = 'DISPLAY_SCALING_TABLES' AND
      objvers = 'A' AND
      report = '' AND
      component = '' AND
      query = '' AND
      username = ''.
    IF <measure_output>-value <> 'none'.
      value_kpidb = <measure_output>-value.
      expo_kpidb = ceil( log10( value_kpidb ) ).
      r_elem_prop-num_scale = expo_kpidb.
    ENDIF.
  ENDLOOP.

  " Buffer the MPRO Customizing Table for Text Definition
  IF at_cus_mpro IS INITIAL.
    SELECT * FROM y0bw_xf_cus_mpro INTO CORRESPONDING FIELDS OF TABLE at_cus_mpro.
  ENDIF.

  IF at_cus_mpro IS  NOT INITIAL .
    "Dertermine the correct depending on the customizing of the MPRO
    READ TABLE at_cus_mpro INTO s_cus_mpro
      WITH KEY infoprov = i_infoprov.
    IF sy-subrc = 0. "
      CASE s_cus_mpro-txtdef.
        WHEN 'S'.
          r_elem_prop-txtlg = as_measure_texts-short_name.
        WHEN 'M'.
          r_elem_prop-txtlg = as_measure_texts-middle_name.
        WHEN 'L'.
          r_elem_prop-txtlg = as_measure_texts-long_name.
      ENDCASE.

    ELSE. "Nothing found? We take the default (LONG)

      r_elem_prop-txtlg = as_measure_texts-long_name.

    ENDIF.
  ENDIF.

ENDMETHOD.


METHOD get_measure_filters.
* Get measure detail Active dataset
  SELECT *
  INTO TABLE me->at_measure_filters
  FROM y0bw_xf_meas_fis
  WHERE measid = me->av_measid
    AND objvers = 'A'.

  IF av_purpose IS INITIAL.

* Get measure detail Modified dataset
    SELECT *
    INTO TABLE me->at_measure_filters_m
    FROM y0bw_xf_meas_fis
    WHERE measid = me->av_measid
      AND objvers = 'M'.

  ENDIF.

ENDMETHOD.


METHOD get_measure_list.
  DATA: obj_struct TYPE REF TO cl_abap_structdescr,
        obj_range TYPE REF TO data.
  DATA: lt_sel_parameters TYPE if_wd_select_options=>tt_selection_screen_item.
  DATA: lt_comp_table TYPE cl_abap_structdescr=>component_table.
  DATA: lv_fieldname TYPE string,
        lv_condition TYPE string.

  FIELD-SYMBOLS: <wa_sel_parameters> LIKE LINE OF it_sel_parameters,
                 <wa_comp_table> TYPE abap_componentdescr,
                 <lt_range_table> TYPE ANY TABLE,
                 <wa_range_table> TYPE ANY,
                 <lt_range> TYPE ANY,
                 <lt_sel_option> TYPE ANY TABLE.

  IF it_sel_parameters[] IS NOT INITIAL.
    lt_sel_parameters[] = it_sel_parameters[].

* Build select options
    LOOP AT lt_sel_parameters ASSIGNING <wa_sel_parameters>.
      ASSIGN <wa_sel_parameters>-mt_range_table->* TO <lt_range_table>.

      IF <lt_range_table>[] IS INITIAL.
        DELETE TABLE lt_sel_parameters
        FROM <wa_sel_parameters>.

        CONTINUE.
      ENDIF.

* Build parameter name
      APPEND INITIAL LINE TO lt_comp_table ASSIGNING <wa_comp_table>.
      MOVE <wa_sel_parameters>-m_id TO <wa_comp_table>-name.
      <wa_comp_table>-type ?= cl_abap_elemdescr=>describe_by_data_ref( <wa_sel_parameters>-mt_range_table ).

      UNASSIGN: <wa_comp_table>.
    ENDLOOP.

* Create Range object
    obj_struct = cl_abap_structdescr=>create( lt_comp_table ).
    CREATE DATA obj_range TYPE HANDLE obj_struct.
    ASSIGN obj_range->* TO <lt_range>.

* Build dynamic conditions
    LOOP AT lt_sel_parameters ASSIGNING <wa_sel_parameters>.
      ASSIGN <wa_sel_parameters>-mt_range_table->* TO <lt_range_table>.

      READ TABLE lt_comp_table
      ASSIGNING <wa_comp_table>
      INDEX sy-tabix.

* Build field name
      CONCATENATE '<lt_range>-' <wa_comp_table>-name INTO lv_fieldname.

      IF sy-tabix = 1.
        CONCATENATE <wa_sel_parameters>-m_id 'in' lv_fieldname INTO lv_condition SEPARATED BY space.
      ELSE.
        CONCATENATE lv_condition 'and' <wa_sel_parameters>-m_id 'in' lv_fieldname INTO lv_condition SEPARATED BY space.
      ENDIF.

      ASSIGN COMPONENT <wa_comp_table>-name OF STRUCTURE <lt_range> TO <lt_sel_option>.
      <lt_sel_option> = <lt_range_table>.

      UNASSIGN: <lt_sel_option>.
    ENDLOOP.
  ENDIF.

* Select data
  IF lv_condition IS INITIAL.
    SELECT *
    INTO TABLE rt_measure_list
    FROM y0bw_xf_meas_id
    UP TO iv_max_hits ROWS.
  ELSE.
    SELECT *
    INTO TABLE rt_measure_list
    FROM y0bw_xf_meas_id
    UP TO iv_max_hits ROWS
    WHERE (lv_condition).
  ENDIF.

  FREE: obj_struct, obj_range.
  FREE: lt_sel_parameters, lt_comp_table.
ENDMETHOD.


METHOD get_measure_list_trfn.
* Retrieve the relevant measures per transformation
  SELECT *
  INTO CORRESPONDING FIELDS OF TABLE rt_measure_list
  FROM y0bw_xf_meas_cdm
  WHERE source = iv_src
    AND target = iv_tgt
    AND objvers = rs_c_objvers-active.
ENDMETHOD.


METHOD get_measure_output.
* Get measure detail Active dataset
  SELECT *
  INTO TABLE me->at_measure_output
  FROM y0bw_xf_meas_rep
  WHERE measid = me->av_measid
    AND objvers = 'A'.

  IF av_purpose IS INITIAL.

* Get measure detail Modified dataset
    SELECT *
    INTO TABLE me->at_measure_output_m
    FROM y0bw_xf_meas_rep
    WHERE measid = me->av_measid
      AND objvers = 'M'.

  ENDIF.

ENDMETHOD.


METHOD get_measure_sets.
* Get active measure sets
  SELECT *
  INTO TABLE me->at_measure_sets
  FROM y0bw_xf_meas_set
  WHERE measid = me->av_measid
    AND objvers = 'A'.

* Get modified measure sets
  SELECT *
  INTO TABLE me->at_measure_sets_m
  FROM y0bw_xf_meas_set
  WHERE measid = me->av_measid
    AND objvers = 'M'.
ENDMETHOD.


METHOD get_measure_single_text.
  SELECT SINGLE *
  INTO CORRESPONDING FIELDS OF  rs_texts
  FROM y0bw_xf_meas_txt
  WHERE measid = iv_measid
    AND objvers = 'A'
    AND langu = iv_langu.
ENDMETHOD.


method get_measure_text.
  select * from y0bw_xf_meas_txt into corresponding fields of table r_y0bw_xf_meas_txt where objvers = 'A'.
endmethod.


METHOD get_measure_texts.
* Get measure texts Active dataset
  SELECT SINGLE *
  INTO me->as_measure_texts
  FROM y0bw_xf_meas_txt
  WHERE measid = me->av_measid
    AND objvers = 'A'
    AND langu = sy-langu.

* Get measure detail Modified dataset
  SELECT SINGLE *
  INTO me->as_measure_texts_m
  FROM y0bw_xf_meas_txt
  WHERE measid = me->av_measid
    AND objvers = 'M'
    AND langu = sy-langu.
ENDMETHOD.


METHOD get_meas_ida_data.
  DATA: obj_struct TYPE REF TO cl_abap_structdescr,
        obj_range TYPE REF TO data.
  DATA: lt_sel_parameters TYPE if_wd_select_options=>tt_selection_screen_item.
  DATA: lt_comp_table TYPE cl_abap_structdescr=>component_table.
  DATA: lv_fieldname TYPE string,
        lv_condition TYPE string.

  FIELD-SYMBOLS: <wa_sel_parameters> LIKE LINE OF it_sel_parameters,
                 <wa_comp_table> TYPE abap_componentdescr,
                 <lt_range_table> TYPE ANY TABLE,
                 <wa_range_table> TYPE any,
                 <lt_range> TYPE any,
                 <lt_sel_option> TYPE ANY TABLE.

  IF it_sel_parameters[] IS NOT INITIAL.
     lt_sel_parameters[] = it_sel_parameters[].

* Build select options
    LOOP AT lt_sel_parameters ASSIGNING <wa_sel_parameters>.
      ASSIGN <wa_sel_parameters>-mt_range_table->* TO <lt_range_table>.

      IF <lt_range_table>[] IS INITIAL.
        DELETE TABLE lt_sel_parameters
        FROM <wa_sel_parameters>.

        CONTINUE.
      ENDIF.

* Build parameter name
      APPEND INITIAL LINE TO lt_comp_table ASSIGNING <wa_comp_table>.
      MOVE <wa_sel_parameters>-m_id TO <wa_comp_table>-name.
      <wa_comp_table>-type ?= cl_abap_elemdescr=>describe_by_data_ref( <wa_sel_parameters>-mt_range_table ).

      UNASSIGN: <wa_comp_table>.
    ENDLOOP.

* Create Range object
    obj_struct = cl_abap_structdescr=>create( lt_comp_table ).
    CREATE DATA obj_range TYPE HANDLE obj_struct.
    ASSIGN obj_range->* TO <lt_range>.

* Build dynamic conditions
    LOOP AT lt_sel_parameters ASSIGNING <wa_sel_parameters>.
      ASSIGN <wa_sel_parameters>-mt_range_table->* TO <lt_range_table>.

      READ TABLE lt_comp_table
      ASSIGNING <wa_comp_table>
      INDEX sy-tabix.

* Build field name
      CONCATENATE '<lt_range>-' <wa_comp_table>-name INTO lv_fieldname.

      IF sy-tabix = 1.
        CONCATENATE <wa_sel_parameters>-m_id 'in' lv_fieldname INTO lv_condition SEPARATED BY space.
      ELSE.
        CONCATENATE lv_condition 'and' <wa_sel_parameters>-m_id 'in' lv_fieldname INTO lv_condition SEPARATED BY space.
      ENDIF.

      ASSIGN COMPONENT <wa_comp_table>-name OF STRUCTURE <lt_range> TO <lt_sel_option>.
      <lt_sel_option> = <lt_range_table>.

      UNASSIGN: <lt_sel_option>.
    ENDLOOP.
  ENDIF.

* Select data
  IF lv_condition IS INITIAL.
    SELECT *
    INTO TABLE rt_ida_data
    FROM y0bw_xf_meas_ida.
  ELSE.
    SELECT *
    INTO TABLE rt_ida_data
    FROM y0bw_xf_meas_ida
    WHERE (lv_condition).
  ENDIF.

  FREE: obj_struct, obj_range.
  FREE: lt_sel_parameters, lt_comp_table.
ENDMETHOD.


METHOD get_reporting_dimension.
* Get dimension data
  SELECT SINGLE *
  INTO rs_dimension
  FROM y0bw_xf_rep_dims
  WHERE dimnm = iv_dimnm
    AND objvers = iv_objvers.
ENDMETHOD.


METHOD get_reporting_dimensions.
* Get dimension data
  SELECT *
  INTO TABLE rt_dimensions
  FROM y0bw_xf_rep_dims
  WHERE objvers = iv_objvers.
ENDMETHOD.


METHOD get_upheader_data.
* Get column header data
  SELECT *
  INTO TABLE et_result
  FROM y0bw_xf_upheader
  WHERE objvers = iv_objvers
    AND col_header <> ''.

  MOVE sy-subrc TO ev_subrc.
ENDMETHOD.


method get_y0bw_xf_meas_cluster.
  free: e_t_result[].

  select mset~measid
         mset~purpose
         mset~data_cluster

         dcls~target
         dcls~target_ncum
         dcls~source
         dcls~src_virt_prov
         dcls~process_chain

    into table e_t_result

    from y0bw_xf_meas_set as mset left outer join
         y0bw_xf_data_cls as dcls

             on mset~data_cluster = dcls~data_cluster

    where mset~objvers = i_objvers
      and mset~purpose in i_t_range_purpose
      and mset~measid <> space.

  e_subrc = sy-subrc.
endmethod.


method get_y0bw_xf_meas_dis.
  if not e_t_result is supplied.
    return.
  endif.

  e_subrc = 8.
  free: e_t_result[].

  select *
    from y0bw_xf_meas_dis
    into table e_t_result
    where objvers = i_objvers
      and measid  in i_t_range_measid
      and purpose in i_t_range_purpose
      and dimnm   in i_t_range_dimnm
    order by measid dimnm objvers purpose ascending.

  if sy-subrc = 0.
  endif.

  clear e_subrc.
endmethod.


method get_y0bw_xf_meas_fis.
  if not e_t_result is supplied.
    return.
  endif.

  e_subrc = 8.
  free: e_t_result[].

  select *
    from y0bw_xf_meas_fis
    into table e_t_result
    where objvers  =  i_objvers
      and measid   in i_t_range_measid
      and purpose  in i_t_range_purpose
    order by purpose                        "for Y0BW_XF_MEAS_FIS_TS
             measid
             dimnm
             index_number ascending.

  if sy-subrc = 0.
  endif.

  clear e_subrc.
endmethod.


method get_y0bw_xf_meas_id.
  if not e_t_result is supplied.
    return.
  endif.

  e_subrc = 8.
  free: e_t_result[].

  select *
    from y0bw_xf_meas_id
    into table e_t_result
    where objvers = i_objvers
      and measid  in i_t_range_measid
    order by objvers measid ascending.

  if sy-subrc = 0.

  endif.

  clear e_subrc.
endmethod.


method get_y0bw_xf_meas_set.
  if not e_t_result is supplied.
    return.
  endif.

  e_subrc = 8.
  free: e_t_result[].

  select *
    from y0bw_xf_meas_set
    into table e_t_result
    where objvers = i_objvers
      and measid in i_t_range_measid
      and purpose in i_t_range_purpose
    order by measid objvers purpose ascending.

  if sy-subrc = 0.
  endif.

  clear e_subrc.
endmethod.


method get_y0bw_xf_upheader.

  free: e_t_result[].

  select * from y0bw_xf_upheader
    into table e_t_result
    where objvers = i_objvers
      and col_header <> ''.

  e_subrc = sy-subrc.
endmethod.


METHOD load_measure_data.

  me->get_measure_detail( ). " Get Measure Detail

  IF me->as_measure_detail-technical_type = 'R'.
    me->get_base_measures( ). "Get base measures
  ENDIF.

  IF me->av_purpose IS INITIAL.

    me->get_measure_texts( ). " Get texts
    me->get_measure_filters( ). " Get Filters
    me->get_measure_additional( ). " Get additional data
    me->get_measure_dim_sets( ). " Get dimension sets
    me->get_measure_output( ). " Get reporting output settings
    me->get_measure_sets( ). " Get measure sets

  ELSEIF me->av_purpose EQ 'TRA'. "Transformation
    me->get_measure_filters( ). " Get Filters
  ELSEIF me->av_purpose EQ 'REP'. "Reporting
    me->get_measure_texts( ). " Get texts
    me->get_measure_output( ). " Get reporting output settings
  ENDIF.

ENDMETHOD.


METHOD reload_measure_data.
* Reload data
  me->load_measure_data( ).
ENDMETHOD.


METHOD save_measure_additional.
  DATA: wa_add_data TYPE y0bw_xf_meas_add.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2.

* Set objvers
  MOVE is_additional_data TO wa_add_data.
  MOVE 'M' TO wa_add_data-objvers.

* Set measid if empty
  IF wa_add_data-measid IS INITIAL.
    MOVE me->av_measid TO wa_add_data-measid.
  ENDIF.

* Save data to database
  MODIFY y0bw_xf_meas_add FROM wa_add_data.

  IF sy-subrc IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 005 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ELSE.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 006 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

  CLEAR: wa_add_data.
ENDMETHOD.


METHOD save_measure_data.
  DATA: wa_measure_data TYPE y0bw_xf_meas_data_import_s.
  DATA: lt_return TYPE bapiret2_t.
  DATA: wa_meas_id TYPE y0bw_xf_meas_id.
  DATA: lv_add_core_dims TYPE abap_bool.

  FIELD-SYMBOLS: <wa_meas_id> TYPE y0bw_xf_meas_id,
                 <wa_meas_texts> TYPE y0bw_xf_meas_txt,
                 <wa_meas_add> TYPE y0bw_xf_meas_add,
                 <lt_meas_sets> TYPE y0bw_xf_meas_set_t,
                 <lt_dim_sets> TYPE y0bw_xf_meas_dis_t,
                 <wa_return> TYPE bapiret2.

* Enqueue measure
  CALL METHOD y0bw_xf_kpi_il_v2=>enqueue_measure_id
    EXPORTING
      iv_measid                 = is_measure_data-measid
    EXCEPTIONS
      measure_is_already_locked = 1
      OTHERS                    = 2.

  IF sy-subrc IS NOT INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 043 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    MOVE is_measure_data-measid TO <wa_return>-message_v1.
    UNASSIGN: <wa_return>.

    EXIT.
  ENDIF.

* Move values
  wa_measure_data = is_measure_data.

* Set default multiprovider from Objvers a if new one is empty
  IF wa_measure_data-data-def_multiprov IS INITIAL AND me->as_measure_detail-def_multiprov IS NOT INITIAL.
    MOVE me->as_measure_detail-def_multiprov TO wa_measure_data-data-def_multiprov.
  ENDIF.

* Save data
* Check if meas_id data allready exist
  SELECT SINGLE *
  INTO wa_meas_id
  FROM y0bw_xf_meas_id
  WHERE measid = wa_measure_data-measid
    AND objvers = 'A'.

* Save measure id data
  ASSIGN wa_measure_data-data TO <wa_meas_id>.
  IF <wa_meas_id> IS NOT INITIAL.
* Set changed or created information
    IF wa_meas_id IS NOT INITIAL.
      MOVE sy-uname TO <wa_meas_id>-changed_by.
      MOVE sy-datum TO <wa_meas_id>-changed_on.
      MOVE sy-uzeit TO <wa_meas_id>-changed_time.
      MOVE wa_meas_id-created_by TO <wa_meas_id>-created_by.
      MOVE wa_meas_id-created_on TO <wa_meas_id>-created_on.
      MOVE wa_meas_id-created_time TO <wa_meas_id>-created_time.
    ELSE.
      MOVE sy-uname TO <wa_meas_id>-created_by.
      MOVE sy-datum TO <wa_meas_id>-created_on.
      MOVE sy-uzeit TO <wa_meas_id>-created_time.
    ENDIF.

    MOVE 'M' TO <wa_meas_id>-objvers.

* Set existing exception cluster
    MOVE me->as_measure_detail-except_cluster TO <wa_meas_id>-except_cluster.

* Set physical storage
    IF <wa_meas_id>-phys_key_figure IS NOT INITIAL AND <wa_meas_id>-phys_storage = abap_false.
      MOVE abap_true TO <wa_meas_id>-phys_storage.
    ENDIF.

* Modify database
    MODIFY y0bw_xf_meas_id FROM <wa_meas_id>.

    IF sy-subrc IS INITIAL.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 001 TO <wa_return>-number.
      MOVE 'S' TO <wa_return>-type.
      UNASSIGN: <wa_return>.
    ELSE.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 002 TO <wa_return>-number.
      MOVE 'E' TO <wa_return>-type.
      UNASSIGN: <wa_return>.
    ENDIF.
  ENDIF.
  UNASSIGN: <wa_meas_id>.

* Save Measure Texts
  IF wa_measure_data-texts IS NOT INITIAL.
    lt_return = me->save_measure_texts( wa_measure_data-texts ).

    APPEND LINES OF lt_return TO rt_return.
    FREE: lt_return.
  ENDIF.

* Save additional definitions
  IF wa_measure_data-add_definitions IS NOT INITIAL.
    lt_return = me->save_measure_additional( wa_measure_data-add_definitions ).

    APPEND LINES OF lt_return TO rt_return.
    FREE: lt_return.
  ENDIF.

* Save measure sets
  IF wa_measure_data-measure_sets[] IS NOT INITIAL.
    lt_return = me->save_measure_dimensions( wa_measure_data-measure_sets ).

    APPEND LINES OF lt_return TO rt_return.
    FREE: lt_return.
  ENDIF.

* Save measure sets
  IF wa_measure_data-dimension_sets[] IS NOT INITIAL.
    IF wa_measure_data-data-technical_type = 'X'.
      MOVE abap_false TO lv_add_core_dims.
    ELSE.
      MOVE abap_true TO lv_add_core_dims.
    ENDIF.

    lt_return = me->save_measure_dim_sets( it_dimension_sets      = wa_measure_data-dimension_sets
                                           iv_add_core_dimensions = lv_add_core_dims ).

    APPEND LINES OF lt_return TO rt_return.
    FREE: lt_return.
    CLEAR: lv_add_core_dims.
  ENDIF.

* Save reporting settings
  IF wa_measure_data-reporting_setting[] IS NOT INITIAL.
    lt_return = me->save_measure_output( wa_measure_data-reporting_setting ).

    APPEND LINES OF lt_return TO rt_return.
    FREE: lt_return.
  ENDIF.

* Save Filter sets
  IF wa_measure_data-dimension_filter_sets[] IS NOT INITIAL.
    lt_return = me->save_measure_filters( wa_measure_data-dimension_filter_sets ).

    APPEND LINES OF lt_return TO rt_return.
    FREE: lt_return.
  ENDIF.

  LOOP AT lt_return ASSIGNING <wa_return>
  WHERE type = 'E' OR type = 'A'.
* Make rollback and set error message
    CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.

    INSERT INITIAL LINE INTO rt_return INDEX 1 ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 045 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.

    EXIT.
  ENDLOOP.

  IF sy-subrc IS NOT INITIAL.
    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'.

    INSERT INITIAL LINE INTO rt_return INDEX 1 ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 044 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

* Dequeue measure
  CALL METHOD y0bw_xf_kpi_il_v2=>dequeue_measure_id
    EXPORTING
      iv_measid = is_measure_data-measid.

* Reload measure data
  me->reload_measure_data( ).

  CLEAR: wa_meas_id.
ENDMETHOD.


METHOD save_measure_dimensions.
  DATA: lt_dimensions TYPE y0bw_xf_meas_set_t.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2,
                 <wa_dimensions> TYPE y0bw_xf_meas_set.

  lt_dimensions[] = it_dimensions[].

* Set objvers
  LOOP AT lt_dimensions ASSIGNING <wa_dimensions>.
* Set measid if empty
    IF <wa_dimensions>-measid IS INITIAL.
      MOVE me->av_measid TO <wa_dimensions>-measid.
    ENDIF.

    MOVE 'M' TO <wa_dimensions>-objvers.
  ENDLOOP.

* Save data to database
  MODIFY y0bw_xf_meas_set
  FROM TABLE lt_dimensions.

* Set messages
  IF sy-subrc IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 030 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ELSE.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 031 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

  FREE: lt_dimensions.
ENDMETHOD.


METHOD save_measure_dim_sets.
  DATA: lt_core_dim TYPE STANDARD TABLE OF y0bw_xf_rep_dims,
        wa_dimension_set TYPE y0bw_xf_meas_dis.
  DATA: lt_dimension_sets TYPE y0bw_xf_meas_dis_t.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2,
                 <wa_core_dim> TYPE y0bw_xf_rep_dims,
                 <wa_dimension_sets> TYPE y0bw_xf_meas_dis.

  CONSTANTS: co_core_dim TYPE y0xf_type VALUE '1'.

  lt_dimension_sets[] = it_dimension_sets.

  LOOP AT lt_dimension_sets ASSIGNING <wa_dimension_sets>.
* Set measid if empty
    IF <wa_dimension_sets>-measid IS INITIAL.
      MOVE me->av_measid TO <wa_dimension_sets>-measid.
    ENDIF.

    MOVE 'M' TO <wa_dimension_sets>-objvers.
  ENDLOOP.

* Save data to database
  MODIFY y0bw_xf_meas_dis
  FROM TABLE lt_dimension_sets.

* Set messages
  IF sy-subrc IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 032 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ELSE.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 033 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

  IF iv_add_core_dimensions = abap_true.
* Get core dimensions
    SELECT *
    INTO TABLE lt_core_dim
    FROM y0bw_xf_rep_dims
    WHERE type = co_core_dim.
*      AND objvers = 'A'.

* Add core dimension sets
    LOOP AT lt_core_dim ASSIGNING <wa_core_dim>.
      SELECT SINGLE *
      INTO wa_dimension_set
      FROM y0bw_xf_meas_dis
      WHERE measid = <wa_dimension_sets>-measid
        AND dimnm = <wa_core_dim>-dimnm
        AND objvers = 'M'.

      IF sy-subrc IS NOT INITIAL.
        MOVE <wa_core_dim>-dimnm TO wa_dimension_set-dimnm.
        MOVE <wa_dimension_sets>-measid TO wa_dimension_set-measid.
        MOVE 'M' TO wa_dimension_set-objvers.
        MOVE 'GEN' TO wa_dimension_set-purpose.

* Save data
        MODIFY y0bw_xf_meas_dis
        FROM wa_dimension_set.
      ENDIF.

      CLEAR: wa_dimension_set.
    ENDLOOP.
  ENDIF.

  FREE: lt_core_dim, lt_dimension_sets.
ENDMETHOD.


METHOD save_measure_filters.
  DATA: lt_dim_filter TYPE y0bw_xf_meas_fis_t.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2,
                 <wa_dim_filter> TYPE y0bw_xf_meas_fis.

  lt_dim_filter[] = it_dim_filter[].

  LOOP AT lt_dim_filter ASSIGNING <wa_dim_filter>.
* Set measid if empty
    IF <wa_dim_filter>-measid IS INITIAL.
      MOVE me->av_measid TO <wa_dim_filter>-measid.
    ENDIF.

    MOVE 'M' TO <wa_dim_filter>-objvers.
  ENDLOOP.

* Save data to database
  MODIFY y0bw_xf_meas_fis
  FROM TABLE lt_dim_filter.

* Set messages
  IF sy-subrc IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 011 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ELSE.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 012 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

  FREE: lt_dim_filter.
ENDMETHOD.


METHOD save_measure_output.
  DATA: lt_reporting_settings TYPE y0bw_xf_meas_rep_t.

  FIELD-SYMBOLS: <wa_reporting_settings> TYPE y0bw_xf_meas_rep,
                 <wa_return> TYPE bapiret2.

  lt_reporting_settings[] = it_reporting_settings[].

* Delete existing M datasets
  DELETE FROM y0bw_xf_meas_rep
  WHERE measid = me->av_measid
    AND objvers = 'M'.

  LOOP AT lt_reporting_settings ASSIGNING <wa_reporting_settings>.
* Set measid if empty
    IF <wa_reporting_settings>-measid IS INITIAL.
      MOVE me->av_measid TO <wa_reporting_settings>-measid.
    ENDIF.

* Set objvers
    MOVE 'M' TO <wa_reporting_settings>-objvers.

* Save data to database
    MODIFY y0bw_xf_meas_rep
    FROM <wa_reporting_settings>.

    IF sy-subrc IS INITIAL.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 035 TO <wa_return>-number.
      MOVE 'S' TO <wa_return>-type.
      MOVE <wa_reporting_settings>-paramid TO <wa_return>-message_v1.
      MOVE <wa_reporting_settings>-measid TO <wa_return>-message_v2.
      UNASSIGN: <wa_return>.
    ELSE.
      APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
      MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
      MOVE 036 TO <wa_return>-number.
      MOVE 'E' TO <wa_return>-type.
      MOVE <wa_reporting_settings>-paramid TO <wa_return>-message_v1.
      MOVE <wa_reporting_settings>-measid TO <wa_return>-message_v2.
      UNASSIGN: <wa_return>.
    ENDIF.
  ENDLOOP.
ENDMETHOD.


METHOD save_measure_texts.
  DATA: wa_texts TYPE y0bw_xf_meas_txt.

  FIELD-SYMBOLS: <wa_return> TYPE bapiret2.

  MOVE is_texts TO wa_texts.

* Set objvers
  MOVE 'M' TO wa_texts-objvers.

* Set measid if empty
  IF wa_texts-measid IS INITIAL.
    MOVE me->av_measid TO wa_texts-measid.
  ENDIF.

* Modify database
  MODIFY y0bw_xf_meas_txt FROM wa_texts.

  IF sy-subrc IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 003 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ELSE.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 004 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

  CLEAR: wa_texts.
ENDMETHOD.


METHOD save_meas_ida_data.
  DATA: lt_ida_data  TYPE y0bw_xf_meas_ida_t.

  FIELD-SYMBOLS: <wa_ida_data> TYPE y0bw_xf_meas_ida,
                 <wa_return> TYPE bapiret2.

  lt_ida_data[] = it_ida_data[].

* Set objvers
  LOOP AT lt_ida_data ASSIGNING <wa_ida_data>.
    MOVE 'A' TO <wa_ida_data>-objvers.
  ENDLOOP.

* Delete existing data
  DELETE FROM y0bw_xf_meas_ida
  WHERE measid <> ''.

* Save data
  INSERT y0bw_xf_meas_ida
  FROM TABLE lt_ida_data.

  IF sy-subrc IS INITIAL.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 046 TO <wa_return>-number.
    MOVE 'S' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ELSE.
    APPEND INITIAL LINE TO rt_return ASSIGNING <wa_return>.
    MOVE 'Y0BW_XF_KPI_DATABASE' TO <wa_return>-id.
    MOVE 047 TO <wa_return>-number.
    MOVE 'E' TO <wa_return>-type.
    UNASSIGN: <wa_return>.
  ENDIF.

  FREE: lt_ida_data.
ENDMETHOD.


method _FILL_MEASURE_DIS.

   data: lt_y0bw_xf_meas_dis type standard table of y0bw_xf_meas_dis.
data: ls_y0bw_xf_meas_dis like line of lt_y0bw_xf_meas_dis.
data: l_y0bw_xf_meas_dis type y0bw_xf_meas_dis.
data: lt_sbbrn type standard table of /bic/pzxf_sbbrn.
data: lt_mpct type standard table of /bic/pzxf_mpct.
data: lt_scen type standard table of /bic/pzxf_scen.
data: lt_account type standard table of /bi0/paccount.
data: lt_prctr type standard table of /bi0/pprofit_ctr.


field-symbols: <sbrnn> type /bic/pzxf_sbbrn.
field-symbols: <mpct> type /bic/pzxf_mpct.
field-symbols: <scen> type /bic/pzxf_scen.
field-symbols: <account> type /bi0/paccount.
field-symbols: <prctr> type /bi0/pprofit_ctr.


* fill the internal tables
"select * from /bic/pzxf_sbbrn into table lt_sbbrn where objvers = 'A'.
    me->_get_db_table( exporting i_tabname = '/bic/pzxf_sbbrn' changing c_th_data = lt_sbbrn ).
    delete lt_sbbrn where objvers <> 'A'.

loop at lt_sbbrn assigning <sbrnn>.

ls_y0bw_xf_meas_dis-measid = <sbrnn>-/bic/zxf_sbbrn.
ls_y0bw_xf_meas_dis-purpose = 'HIE'.
ls_y0bw_xf_meas_dis-dimnm = 'ZXF_SBBRN'.
ls_y0bw_xf_meas_dis-objvers = 'A'.

append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.
endloop.
clear: ls_y0bw_xf_meas_dis.


"select * from /bic/pzxf_mpct
"into table lt_mpct
"where objvers = 'A'.
    me->_get_db_table( exporting i_tabname = '/bic/pzxf_mpct' changing c_th_data = lt_mpct ).
    delete lt_mpct where objvers <> 'A'.

loop at lt_mpct assigning <mpct>.

ls_y0bw_xf_meas_dis-measid = <mpct>-/bic/zxf_mpct.
ls_y0bw_xf_meas_dis-purpose = 'HIE'.
ls_y0bw_xf_meas_dis-dimnm = 'ZXF_MPCT'.
ls_y0bw_xf_meas_dis-objvers = 'A'.

append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.
endloop.

clear: ls_y0bw_xf_meas_dis.

*select * from /bic/pzxf_scen
*into table lt_scen
*where objvers = 'A'.

    me->_get_db_table( exporting i_tabname = '/bic/pzxf_scen' changing c_th_data = lt_scen ).
    delete lt_scen where objvers <> 'A'.


loop at lt_scen assigning <scen>.

ls_y0bw_xf_meas_dis-measid = <scen>-/bic/zxf_scen.
ls_y0bw_xf_meas_dis-purpose = 'HIE'.
ls_y0bw_xf_meas_dis-dimnm = 'ZXF_SCEN'.
ls_y0bw_xf_meas_dis-objvers = 'A'.

append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.
endloop.

clear: ls_y0bw_xf_meas_dis.

*select * from /bi0/paccount
*into table lt_account
*where objvers = 'A'
* and chrt_accts = 'CARB'.                   " i think all other Chart of Accounts are not relevant?
     me->_get_db_table( exporting i_tabname = '/bi0/paccount' changing c_th_data = lt_account ).
    delete lt_account where objvers <> 'A' or chrt_accts <> 'CARB'.

loop at lt_account assigning <account>.

ls_y0bw_xf_meas_dis-measid = <account>-account.
ls_y0bw_xf_meas_dis-purpose = 'HIE'.
ls_y0bw_xf_meas_dis-dimnm = '0ACCOUNT'.
ls_y0bw_xf_meas_dis-objvers = 'A'.

append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.
endloop.

*select * from /bi0/pprofit_ctr
*into table lt_prctr
*where objvers = 'A'.

     me->_get_db_table( exporting i_tabname = '/bi0/pprofit_ctr' changing c_th_data = lt_prctr ).
    delete lt_prctr where objvers <> 'A'.

  delete adjacent duplicates from lt_prctr.     " no restriction to CO Area so some profit center will occur more than once.


loop at lt_prctr assigning <prctr>.

ls_y0bw_xf_meas_dis-measid = <prctr>-profit_ctr.
ls_y0bw_xf_meas_dis-purpose = 'HIE'.
ls_y0bw_xf_meas_dis-dimnm = '0PROFIT_CTR'.
ls_y0bw_xf_meas_dis-objvers = 'A'.

append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.
endloop.


clear: ls_y0bw_xf_meas_dis.


"me->_delete_existing_recs( exporting I_TABNAME = 'y0bw_xf_meas_dis' changing c_th_data = lt_y0bw_xf_meas_dis ).
me->_modify_db_table( exporting I_TABNAME = 'y0bw_xf_meas_dis' changing c_th_data = lt_y0bw_xf_meas_dis ).
"modify y0bw_xf_meas_dis from table lt_y0bw_xf_meas_dis.
*
*loop at lt_y0bw_xf_meas_dis into  l_y0bw_xf_meas_dis.
*    modify y0bw_xf_meas_dis from l_y0bw_xf_meas_dis.
*  endloop.
endmethod.


method _fill_measure_disset.
  data: lt_meas_id type standard table of y0bw_xf_meas_id.
  data: ls_meas_id like line of lt_meas_id.
  data: lt_rep_dims type standard table of y0bw_xf_rep_dims.
  data: ls_rep_dims like line of lt_rep_dims.
  data: lt_meas_dim type standard table of y0bw_xf_meas_dim.
  data: ls_meas_dim like line of lt_meas_dim.
  data: lt_meas_dis type standard table of y0bw_xf_meas_dis.
  data: ls_meas_dis like line of lt_meas_dis.
  data: lt_meas_set type standard table of y0bw_xf_meas_set.
  data: ls_meas_set like line of lt_meas_set.

  field-symbols: <fs_meas_id> like line of lt_meas_id.
  field-symbols: <fs_rep_dims> like line of lt_rep_dims.
  field-symbols: <fs_meas_dim> like line of lt_meas_dim.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_id' i_force_reload = abap_true changing c_th_data = lt_meas_id ).
  delete lt_meas_id where objvers <> 'A'.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_rep_dims' changing c_th_data = lt_rep_dims ).
  delete lt_rep_dims where objvers <> 'A' or type ne 1.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_dim' changing c_th_data = lt_meas_dim ).
  delete lt_meas_dim where objvers <> 'A'.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_dis' changing c_th_data = lt_meas_dis ).
  delete lt_meas_dis where purpose = 'GEN'.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_set' changing c_th_data = lt_meas_set ).
  delete lt_meas_set where purpose = 'GEN'.

*
  loop at lt_meas_id assigning <fs_meas_id>.
    ls_meas_set-measid = <fs_meas_id>-measid.
    ls_meas_set-objvers = 'A'.
    ls_meas_set-purpose = 'GEN'.
    insert ls_meas_set into table lt_meas_set.

* Fill core dimension for all measures
    loop at lt_rep_dims assigning <fs_rep_dims>.
      ls_meas_dis-measid = <fs_meas_id>-measid.
      ls_meas_dis-dimnm = <fs_rep_dims>-dimnm.
      ls_meas_dis-objvers = 'A'.
      ls_meas_dis-purpose = ls_meas_set-purpose.
      clear ls_meas_dis-optional.
      insert ls_meas_dis into table lt_meas_dis.
    endloop.

    if <fs_meas_id>-technical_theme is initial.
    else.
      clear ls_meas_dis.
      loop at lt_meas_dim assigning <fs_meas_dim> where technical_theme = <fs_meas_id>-technical_theme.
        ls_meas_dis-measid = <fs_meas_id>-measid.
        ls_meas_dis-dimnm =  <fs_meas_dim>-dimnm.
        ls_meas_dis-objvers =  <fs_meas_dim>-objvers.
        ls_meas_dis-purpose =  <fs_meas_dim>-purpose.
        ls_meas_dis-optional = <fs_meas_dim>-optional.
        insert ls_meas_dis into table lt_meas_dis.
      endloop.
    endif.

  endloop.

  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_dis' changing c_th_data = lt_meas_dis ).
  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_set' changing c_th_data = lt_meas_set ).
endmethod.


method _fill_measure_id.


* PAU-MRI: this method fills the measure Id Table and passes the result of the table back, to use it for Datasources etc.
* Datasource is an importparameter, at now only account information is important (some things have to be hardcoded, like the appropriate sourcetables,
* so if we need more in future we can append the additional coding and steer the whole thing with the importparameter datasource



  data:  ls_hiedir type rshiedir.
  data:  lt_hier_accnt type standard table of /bi0/haccount.
  data:  lt_y0bw_xf_meas_id type standard table of y0bw_xf_meas_id .
  data:  ls_lt_y0bw_xf_meas_id like line of lt_y0bw_xf_meas_id .
  data:  lt_y0bw_xf_meas_id2 type standard table of y0bw_xf_meas_id .
  data:  ls_lt_y0bw_xf_meas_id2 like line of lt_y0bw_xf_meas_id .
  data:  l_y0bw_xf_meas_id type y0bw_xf_meas_id.
  data:   lt_measid type range of y0bw_xf_meas_id-measid.
  data:    ls_measid like line of lt_measid.
  data:    ld_measid type y0xf_measid.
  data:  lf_measid type y0xf_measid.            "helpfield to delete leading zeros of accounts
  data: lt_y0bw_xf_meas_set type standard table of y0bw_xf_meas_set.
  data: ls_y0bw_xf_meas_set like line of lt_y0bw_xf_meas_set.
  data: l_y0bw_xf_meas_set type y0bw_xf_meas_set.
  data: lt_y0bw_xf_meas_dis type standard table of y0bw_xf_meas_dis.
  data: ls_y0bw_xf_meas_dis like line of lt_y0bw_xf_meas_dis.
  data: l_y0bw_xf_meas_dis type y0bw_xf_meas_dis.
  data: lt_y0bw_xf_meas_fis type standard table of y0bw_xf_meas_fis.
  data: ls_y0bw_xf_meas_fis like line of lt_y0bw_xf_meas_fis.
  data: l_y0bw_xf_meas_fis type y0bw_xf_meas_fis.
  data: lt_y0bw_xf_meas_dit type standard table of y0bw_xf_meas_dit.
  data: ls_y0bw_xf_meas_dit like line of lt_y0bw_xf_meas_dit.
  data: l_y0bw_xf_meas_dit type y0bw_xf_meas_dit.
  data: lt_y0bw_xf_meas_rep type standard table of y0bw_xf_meas_rep.
  data: ls_y0bw_xf_meas_rep like line of lt_y0bw_xf_meas_rep.
  data: l_y0bw_xf_meas_rep type y0bw_xf_meas_rep.
  data: lt_y0bw_xf_meas_gen type standard table of y0bw_xf_meas_gen.
  data: ls_y0bw_xf_meas_gen like line of lt_y0bw_xf_meas_gen.
  data: temp_y0bw_xf_meas_id type y0bw_xf_meas_id.
  data:  lt_y0bw_xf_meas_add type standard table of y0bw_xf_meas_add .  "new values
  data:  ls_y0bw_xf_meas_add like line of lt_y0bw_xf_meas_add.
  data: string1 type string.
  data: string2 type string.
  data: ht_y0bw_xf_meas_adt type hashed table of y0bw_xf_meas_adt with unique key measid.
  data: ht_y0bw_xf_meas_add type hashed table of y0bw_xf_meas_add with unique key measid.
  data: lt_y0bw_xf_meas_adt type standard table of y0bw_xf_meas_adt.
  field-symbols: <fs_y0bw_xf_meas_adt> like line of lt_y0bw_xf_meas_adt.
  field-symbols: <fs_y0bw_xf_meas_add> like line of lt_y0bw_xf_meas_add.
  field-symbols: <fs_y0bw_xf_meas_id2> like line of lt_y0bw_xf_meas_id2.
  data: lv_created_on type ERDAT.


*--------------------------------------------------------------------*
* 1. FILL INTERNAL TABLES
*--------------------------------------------------------------------*

* Reference to me
  data y0bw_xf_kpi_il_v2  type ref to y0bw_xf_kpi_il_v2.

  field-symbols: <fs_hier_accnt> type /bi0/haccount .
  field-symbols: <fs_y0bw_xf_meas_id> type y0bw_xf_meas_id.

  clear  ls_hiedir.
  clear temp_y0bw_xf_meas_id.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_add' changing c_th_data = lt_y0bw_xf_meas_add ).
  delete lt_y0bw_xf_meas_add where objvers ne 'A'.
  ht_y0bw_xf_meas_add[] = lt_y0bw_xf_meas_add[].

* first get the list of hierarchies to be generated
  "select * from y0bw_xf_meas_gen into table lt_y0bw_xf_meas_gen where iobjnm = '0ACCOUNT' and objvers = 'A'.
  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_gen' changing c_th_data = lt_y0bw_xf_meas_gen ).
  delete lt_y0bw_xf_meas_gen where iobjnm <> '0ACCOUNT' or objvers <> 'A'.

      "select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id2 where objvers = 'A' and measid like 'CARB%'.
    me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id2 ).
    delete lt_y0bw_xf_meas_id2 where measid(4) <> 'CARB' or objvers <> 'A'.
* now sort descending -> so highest priority is last (this to ensure that the overwrite runs correctly
  sort lt_y0bw_xf_meas_gen by priority descending.

* now loop over table and do the genereation for each hierarchy defined in y0bw_xf_meas_gen.
  loop at lt_y0bw_xf_meas_gen into ls_y0bw_xf_meas_gen.

* get the data of the appropriate template to derive the attributes later on.
    select * from y0bw_xf_meas_id into temp_y0bw_xf_meas_id where measid = ls_y0bw_xf_meas_gen-measure_template and objvers = 'A'.
    endselect.
    "me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = temp_y0bw_xf_meas_id ).
    "delete temp_y0bw_xf_meas_id where measid <> ls_y0bw_xf_meas_gen-measure_template or objvers <> 'A'.

* get the details of the hierarchie
    select single * from rshiedir into ls_hiedir
        where hienm = ls_y0bw_xf_meas_gen-hienm and
             objvers = 'A' and iobjnm = ls_y0bw_xf_meas_gen-iobjnm.

* read the nodenames and hierarchy itself
    select * from /bi0/haccount
              into table lt_hier_accnt
              where hieid = ls_hiedir-hieid and
                    objvers = 'A'.


* here fill the attributes
    loop at  lt_hier_accnt assigning <fs_hier_accnt> .
      clear ls_lt_y0bw_xf_meas_id .
      clear ls_y0bw_xf_meas_set.
      clear ls_y0bw_xf_meas_dis.
      clear l_y0bw_xf_meas_fis.

* when it is an account -> delete leading zeros
      if <fs_hier_accnt>-iobjnm = '0ACCOUNT'.
        move <fs_hier_accnt>-nodename+4 to lf_measid.
        shift lf_measid left deleting leading '0'.
        concatenate 'CARB' lf_measid into ls_lt_y0bw_xf_meas_id-measid.      " for measure id
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_set-measid.        " for measure set
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_dis-measid.        " for measure dis
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_fis-measid.        " for filter sets
      else.
        ls_lt_y0bw_xf_meas_id-measid = <fs_hier_accnt>-nodename.             " for measure id
        ls_y0bw_xf_meas_set-measid = <fs_hier_accnt>-nodename.              " for measure set
        ls_y0bw_xf_meas_dis-measid = <fs_hier_accnt>-nodename.               " for measure dis
        ls_y0bw_xf_meas_fis-measid = <fs_hier_accnt>-nodename.              " for filter sets
      endif.
      ls_lt_y0bw_xf_meas_id-objvers = 'A'.
* Technical type depends if it is a node or a real infoobject (H = Node, B = infoobject)
      if  <fs_hier_accnt>-iobjnm = '0HIER_NODE'.
        ls_lt_y0bw_xf_meas_id-technical_type = 'H'.
        ls_y0bw_xf_meas_fis-high = '0HIER_NODE'.                        " for filter sets
        ls_lt_y0bw_xf_meas_id-measure_type = 'KPI'.                     "see HLA XF00026.....depending on Node or Base
      else.
        ls_lt_y0bw_xf_meas_id-technical_type = 'B'.
        ls_y0bw_xf_meas_fis-high = ''.                                  " for filter sets
        ls_lt_y0bw_xf_meas_id-measure_type = 'ACC'.                     "see HLA XF00026.....depending on Node or Base
      endif.
      ls_lt_y0bw_xf_meas_id-phys_key_figure = temp_y0bw_xf_meas_id-phys_key_figure.
      ls_lt_y0bw_xf_meas_id-base_measure = ''.
* physical storage depends if it is a node or infobject itself ('' = Node, 'X' = iobj)
      if  <fs_hier_accnt>-iobjnm = '0HIER_NODE'.
        ls_lt_y0bw_xf_meas_id-phys_storage = ''.
      else.
        ls_lt_y0bw_xf_meas_id-phys_storage = 'X'.
      endif.

clear lv_created_on.

      loop at lt_y0bw_xf_meas_id2 assigning <fs_y0bw_xf_meas_id2>
        where measid = ls_lt_y0bw_xf_meas_id-measid
        and created_on ne lv_created_on.
        endloop.
        if sy-subrc = 0.
         ls_lt_y0bw_xf_meas_id-created_on = <fs_y0bw_xf_meas_id2>-created_on.
          else.
          ls_lt_y0bw_xf_meas_id-created_on = sy-datum.
          endif.
          unassign <fs_y0bw_xf_meas_id2>.


* take the attributes from the template
      ls_lt_y0bw_xf_meas_id-phys_infoprov = temp_y0bw_xf_meas_id-phys_infoprov.
      ls_lt_y0bw_xf_meas_id-active = 'X'.
      ls_lt_y0bw_xf_meas_id-def_multiprov = temp_y0bw_xf_meas_id-def_multiprov.
      ls_lt_y0bw_xf_meas_id-unit_conversion = temp_y0bw_xf_meas_id-unit_conversion.
      ls_lt_y0bw_xf_meas_id-unit_type = temp_y0bw_xf_meas_id-unit_type.
      ls_lt_y0bw_xf_meas_id-default_unit = temp_y0bw_xf_meas_id-default_unit.
      ls_lt_y0bw_xf_meas_id-hier_aggr = temp_y0bw_xf_meas_id-hier_aggr.
      ls_lt_y0bw_xf_meas_id-time_aggr = temp_y0bw_xf_meas_id-time_aggr.
      ls_lt_y0bw_xf_meas_id-currency_conv = temp_y0bw_xf_meas_id-currency_conv.
      ls_lt_y0bw_xf_meas_id-time_granularity = temp_y0bw_xf_meas_id-time_granularity.
      ls_lt_y0bw_xf_meas_id-time_delivery = temp_y0bw_xf_meas_id-time_delivery.
      ls_lt_y0bw_xf_meas_id-delivery_date = temp_y0bw_xf_meas_id-delivery_date.
      ls_lt_y0bw_xf_meas_id-disp_spor_data = temp_y0bw_xf_meas_id-disp_spor_data.
      ls_lt_y0bw_xf_meas_id-bench_logic = temp_y0bw_xf_meas_id-bench_logic.
      ls_lt_y0bw_xf_meas_id-workflow_status  = temp_y0bw_xf_meas_id-workflow_status.
*     ls_lt_y0bw_xf_meas_id-measure_type = temp_y0bw_xf_meas_id-measure_type.     " see HLA XF00026.....depending on Node or Base
      ls_lt_y0bw_xf_meas_id-workflow_cluster  = temp_y0bw_xf_meas_id-workflow_cluster.
      ls_lt_y0bw_xf_meas_id-auth_module  = temp_y0bw_xf_meas_id-auth_module.
      ls_lt_y0bw_xf_meas_id-auth_cluster  = ''.   " entries overwritten later on by records of table y0bw_xf_meas_ida
      ls_lt_y0bw_xf_meas_id-factor  = temp_y0bw_xf_meas_id-factor.
      ls_lt_y0bw_xf_meas_id-responsible  = temp_y0bw_xf_meas_id-responsible.
      ls_lt_y0bw_xf_meas_id-accountable  = temp_y0bw_xf_meas_id-accountable.
      ls_lt_y0bw_xf_meas_id-deviation  = temp_y0bw_xf_meas_id-deviation.
      ls_lt_y0bw_xf_meas_id-relevancy  = temp_y0bw_xf_meas_id-relevancy.

      ls_lt_y0bw_xf_meas_id-project = temp_y0bw_xf_meas_id-project.
      ls_lt_y0bw_xf_meas_id-technical_theme = temp_y0bw_xf_meas_id-technical_theme.

      ls_y0bw_xf_meas_set-purpose = 'HIE'.
      ls_y0bw_xf_meas_set-objvers = 'A'.

      ls_y0bw_xf_meas_dis-purpose = 'HIE'.
      ls_y0bw_xf_meas_dis-dimnm = 'ZXF_MEAS'.
      ls_y0bw_xf_meas_dis-objvers = 'A'.

      ls_y0bw_xf_meas_fis-purpose = 'HIE'.
      ls_y0bw_xf_meas_fis-dimnm = 'ZXF_MEAS'.
      ls_y0bw_xf_meas_fis-index_number = '0001'.
      ls_y0bw_xf_meas_fis-objvers = 'A'.
      ls_y0bw_xf_meas_fis-sign = 'I'.
      ls_y0bw_xf_meas_fis-opt = 'EQ'.
      if <fs_hier_accnt>-iobjnm = '0ACCOUNT'.
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_fis-low.
        ls_y0bw_xf_meas_fis-seltp = 1.
        ls_y0bw_xf_meas_fis-hienm = ''.
        ls_y0bw_xf_meas_fis-version = ''.
        ls_y0bw_xf_meas_fis-dateto = ''.
      else.
        ls_y0bw_xf_meas_fis-low = <fs_hier_accnt>-nodename.
        ls_y0bw_xf_meas_fis-seltp = 2.
        ls_y0bw_xf_meas_fis-hienm = 'CARBPROFIT'.
        ls_y0bw_xf_meas_fis-version = 'A'.
        ls_y0bw_xf_meas_fis-dateto = '99991231'.
      endif.



* fill measure id's in a rangetable to compare them afterwards with existing entries to don't loose any information, only important for table y0bw_xf_meas_id
      move ls_lt_y0bw_xf_meas_id-measid to ld_measid.
      ls_measid-sign = 'I'.
      ls_measid-option  = 'EQ'.
      ls_measid-low = ld_measid.
      append ls_measid to lt_measid.

*
      ls_y0bw_xf_meas_add-measid = ls_lt_y0bw_xf_meas_id-measid.
      ls_y0bw_xf_meas_add-objvers = 'A'.
      string1 = 'SAP ERP Profit Center Accounting (For actual data of SAP companies); SAP BI CO Planning (For plan data of SAP companies);'.
      string2 = 'SAP HFM (For Actual and plan data of Non SAP companies in EUR , as well as for Consolidation & adjustment postings excluding Marketing Consolidation)'.
      concatenate string1 string2 into ls_y0bw_xf_meas_add-source_system.

      read table ht_y0bw_xf_meas_add assigning <fs_y0bw_xf_meas_add> with table key measid = ls_lt_y0bw_xf_meas_id-measid.
      if sy-subrc = 0.
        ls_y0bw_xf_meas_add-definitions = <fs_y0bw_xf_meas_add>-definitions.
      endif.


* append the result
      append ls_lt_y0bw_xf_meas_id to lt_y0bw_xf_meas_id .    "for measure id
      append ls_y0bw_xf_meas_set to lt_y0bw_xf_meas_set.      " for measure set
      append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.      " for measure dis
      append ls_y0bw_xf_meas_fis to lt_y0bw_xf_meas_fis.      " for filter sets

      append ls_y0bw_xf_meas_add to lt_y0bw_xf_meas_add.
      clear ls_y0bw_xf_meas_add.
    endloop. "AT lt_hier_accnt



* get existing ones which are not longer in the hierarchy, set them to inactive and add them to the result.

    loop at lt_y0bw_xf_meas_id2 into ls_lt_y0bw_xf_meas_id2.
      if ls_lt_y0bw_xf_meas_id2-measid not in lt_measid.
        ls_lt_y0bw_xf_meas_id2-active = ''.
        append ls_lt_y0bw_xf_meas_id2 to lt_y0bw_xf_meas_id.
      endif.
    endloop.



* update authorization cluster from y0bw_xf_meas_ida.
* update y0bw_xf_meas from y0bw_xf_meas_ida

*    create object y0bw_xf_kpi_il_v2
*      exporting
*        iv_measid = ''.


*    call method y0bw_xf_kpi_il_v2->fill_meas_cluster.

* fill reptable = update y0bw_xf_meas_rep from y0bw_xf_rep_ida
*    call method y0bw_xf_kpi_il_v2->fill_meas_rep.


* fill y0bw_xf_meas_set, y0bw_xf_meas_dis with GEN information
* read relevant information from ID Table (only Hierarchynodes and active)
*    clear: lt_y0bw_xf_meas_id, ls_lt_y0bw_xf_meas_id, lt_y0bw_xf_meas_dit, ls_y0bw_xf_meas_dit. "commented out 3107
*    clear: lt_y0bw_xf_meas_set, ls_y0bw_xf_meas_set, l_y0bw_xf_meas_set.


    "    select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id where objvers = 'A' and technical_type = 'H'.
    "    select * from y0bw_xf_meas_dit into table  lt_y0bw_xf_meas_dit where hienm = 'CARBPROFIT'.      "Contains the possible dimensions for CO
    me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_dit' changing c_th_data = lt_y0bw_xf_meas_dit ).
    delete lt_y0bw_xf_meas_dit where hienm <> 'CARBPROFIT'.

    loop at lt_y0bw_xf_meas_id into ls_lt_y0bw_xf_meas_id where technical_type = 'H' and objvers = 'A'.
      loop at lt_y0bw_xf_meas_dit into ls_y0bw_xf_meas_dit.
        ls_y0bw_xf_meas_dis-measid = ls_lt_y0bw_xf_meas_id-measid.
        ls_y0bw_xf_meas_dis-dimnm = ls_y0bw_xf_meas_dit-dimension.
        ls_y0bw_xf_meas_dis-objvers = 'A'.
        ls_y0bw_xf_meas_dis-purpose = 'GEN'.
        ls_y0bw_xf_meas_dis-optional = ls_y0bw_xf_meas_dit-optional.
        append ls_y0bw_xf_meas_dis to lt_y0bw_xf_meas_dis.

* create entries for set
        ls_y0bw_xf_meas_set-measid = ls_lt_y0bw_xf_meas_id-measid.
        ls_y0bw_xf_meas_set-objvers = 'A'.
        ls_y0bw_xf_meas_set-purpose = 'GEN'.
        append ls_y0bw_xf_meas_set to lt_y0bw_xf_meas_set.
      endloop.
    endloop.
*      clear: lt_y0bw_xf_meas_id.    ' commented out 3107 as lt_y0bw_xf_meas_id was empty
* update the table y0bw_xf_meas_dis
*    me->_delete_existing_recs( exporting I_TABNAME = 'y0bw_xf_meas_dis' changing c_th_data = lt_y0bw_xf_meas_dis ).
*    modify y0bw_xf_meas_dis from table lt_y0bw_xf_meas_dis.

    me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
    clear lt_y0bw_xf_meas_id.

  endloop.

*--------------------------------------------------------------------*
* 2. UPDATE DataBase TABLES
*--------------------------------------------------------------------*

*    me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
*    me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
  "modify y0bw_xf_meas_id from table lt_y0bw_xf_meas_id.
*    me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_fis' changing c_th_data = lt_y0bw_xf_meas_fis ).
  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_fis' changing c_th_data = lt_y0bw_xf_meas_fis ).
  "modify y0bw_xf_meas_fis from table lt_y0bw_xf_meas_fis.
*    me->_delete_existing_recs( exporting I_TABNAME = 'y0bw_xf_meas_add' changing c_th_data = lt_y0bw_xf_meas_add ).
  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_add' changing c_th_data = lt_y0bw_xf_meas_add ).
  "modify y0bw_xf_meas_add from table lt_y0bw_xf_meas_add.
*    me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_set' changing c_th_data = lt_y0bw_xf_meas_set ).
  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_set' changing c_th_data = lt_y0bw_xf_meas_set ).
  "insert y0bw_xf_meas_set from table lt_y0bw_xf_meas_set.

* to go for sure
  commit work.

* update table y0bw_xf_meas_set


* update the table y0bw_xf_meas_dis, but before delete 'old' entries
*    delete from y0bw_xf_meas_dis where measid like 'CARB%'
*    and objvers = 'A'.
* Delete not existing CARB records from y0bw_xf_meas_dis
  "Get Table y0bw_xf_meas_dis
  data: ls_y0bw_xf_meas_dis_tmp like line of lt_y0bw_xf_meas_dis.
  select * from y0bw_xf_meas_dis into ls_y0bw_xf_meas_dis_tmp where measid like 'CARB%' and purpose = 'HIE'.
    read table lt_y0bw_xf_meas_dis from ls_y0bw_xf_meas_dis_tmp transporting no fields.
    if sy-subrc <> 0.
      delete y0bw_xf_meas_dis from ls_y0bw_xf_meas_dis_tmp.
    endif.
    "For each record in the DB Table, try to find the corresponding record in internal table
    "If not found and MEASURE is like CARB%, then delete the record from DB.
  endselect.

*  me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_dis' i_force_reload = abap_true changing c_th_data = lt_y0bw_xf_meas_dis ).
  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_dis' changing c_th_data = lt_y0bw_xf_meas_dis ).
  "insert y0bw_xf_meas_dis from table lt_y0bw_xf_meas_dis.

endmethod.


method _fill_measure_text.

* PAU-MRI: with this method the texttable for Measure Id's will be populated, as Importparameter you can pass the Datasource, just for the case if we need in
* future more than the account information, then we can add  additional coding for other infoobjects and manage it by the importparameter
  data:  ls_hiedir type rshiedir.
  data:  lt_rsthiernode type standard table of  rsthiernode .
  data:  lt_y0bw_xf_meas_txt type standard table of y0bw_xf_meas_txt .
  data:  ls_y0bw_xf_meas_txt like line of lt_y0bw_xf_meas_txt .
  data: lt_y0bw_xf_meas_gen type standard table of y0bw_xf_meas_gen.
  data: ls_y0bw_xf_meas_gen like line of lt_y0bw_xf_meas_gen.
  data:  lt_hier_accnt type standard table of /bi0/haccount.
  data:  ls_hier_accnt like line of lt_hier_accnt.
  data:  lt_taccnt type standard table of /bi0/taccount .
  data:  lt_taccnt_tmp type standard table of /bi0/taccount .
  data:  l_y0bw_xf_meas_txt type y0bw_xf_meas_txt.
  data:    lt_account type table of /bi0/oiaccount.
  data:  lf_measid type y0xf_measid.
  data:  lt_y0bw_xf_ds_zxf_meas_text  type standard table of y0bw_xf_ds_zxf_meas_text.

  field-symbols: <fs_taccnt> type /bi0/taccount .
  field-symbols: <fs_hier_accnt> type /bi0/haccount .
  field-symbols: <fs_rsthiernode> type rsthiernode .
  field-symbols: <fs_lt_hier_accnt> type /bi0/haccount.




*select * from y0bw_xf_meas_gen into table lt_y0bw_xf_meas_gen where iobjnm = '0ACCOUNT' and objvers = 'A'.
  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_gen' changing c_th_data = lt_y0bw_xf_meas_gen ).
  delete lt_y0bw_xf_meas_gen where iobjnm <> '0ACCOUNT' or objvers <> 'A'.
  sort lt_y0bw_xf_meas_gen by priority descending.

  loop at lt_y0bw_xf_meas_gen into ls_y0bw_xf_meas_gen.

* get the details of the hierarchie
    clear  ls_hiedir.
    select single * from rshiedir into ls_hiedir
        where hienm = ls_y0bw_xf_meas_gen-hienm and
             objvers = 'A' and iobjnm = ls_y0bw_xf_meas_gen-iobjnm.



*--------------------------------------------------------------
* First handle only accounts (infoobjects)
*  select * from /bi0/haccount
*   into table lt_hier_accnt
*    where hieid = ls_hiedir-hieid
*          and objvers = 'A'
*          and iobjnm = '0ACCOUNT'.
    me->_get_db_table( exporting i_tabname = '/bi0/haccount' changing c_th_data = lt_hier_accnt ).
    delete lt_hier_accnt where hieid <> ls_hiedir-hieid or objvers <> 'A' or iobjnm <> '0ACCOUNT'.

* find the texts of the accounts we need
    loop at lt_hier_accnt assigning <fs_lt_hier_accnt>.
*    select * from /bi0/taccount appending table lt_taccnt  where langu = 'EN'
*      and account = <fs_lt_hier_accnt>-nodename+4
*      and chrt_accts = 'CARB'.
      clear lt_taccnt_tmp.
      me->_get_db_table( exporting i_tabname = '/bi0/taccount' changing c_th_data = lt_taccnt_tmp ).

      delete lt_taccnt_tmp where langu <> 'E' or account <> <fs_lt_hier_accnt>-nodename+4 or chrt_accts <> 'CARB'.

      lt_taccnt[] = lt_taccnt_tmp[].


* fill the texts of the accounts into the internal table
      loop at  lt_taccnt assigning <fs_taccnt> .
        clear ls_y0bw_xf_meas_txt .
        ls_y0bw_xf_meas_txt-langu = <fs_taccnt>-langu .

* when it is an account -> delete leading zeros
        move <fs_taccnt>-account to lf_measid.
        shift lf_measid left deleting leading '0'.
        concatenate 'CARB' lf_measid into ls_y0bw_xf_meas_txt-measid.

*    concatenate 'CARB' <fs_taccnt>-account into ls_y0bw_xf_meas_txt-measid.         "it's always the combination of Charts of accounts plus account
        ls_y0bw_xf_meas_txt-objvers = 'A'.
        ls_y0bw_xf_meas_txt-short_name = <fs_taccnt>-txtsh .
        ls_y0bw_xf_meas_txt-middle_name = <fs_taccnt>-txtmd .
        ls_y0bw_xf_meas_txt-long_name = <fs_taccnt>-txtmd .
*    ls_y0bw_xf_meas_txt-definitions = ''.
*    ls_y0bw_xf_meas_txt-explanation = ''.
*    ls_y0bw_xf_meas_txt-benefit = ''.
        append ls_y0bw_xf_meas_txt to lt_y0bw_xf_meas_txt .                             "append result to internal table
      endloop.
    endloop.
* handle the hierarchynodes and put them into the internal table
    select * from rsthiernode into table lt_rsthiernode where hieid = ls_hiedir-hieid
     and objvers = 'A' and langu = 'EN'   .
    loop at lt_rsthiernode assigning <fs_rsthiernode>.
      clear ls_y0bw_xf_meas_txt .
      ls_y0bw_xf_meas_txt-langu = <fs_rsthiernode>-langu .
      ls_y0bw_xf_meas_txt-measid =  <fs_rsthiernode>-nodename .                     " in the nodes the chart of accounts is already part of the name
      ls_y0bw_xf_meas_txt-objvers = 'A'.
      ls_y0bw_xf_meas_txt-short_name = <fs_rsthiernode>-txtsh .
      ls_y0bw_xf_meas_txt-middle_name = <fs_rsthiernode>-txtmd .
      ls_y0bw_xf_meas_txt-long_name = <fs_rsthiernode>-txtlg .
*    ls_y0bw_xf_meas_txt-definitions = ''.
*    ls_y0bw_xf_meas_txt-explanation = ''.
*    ls_y0bw_xf_meas_txt-benefit = ''.
      append ls_y0bw_xf_meas_txt to lt_y0bw_xf_meas_txt.                                " append result to internal table
    endloop .

* now we have the complete resultset

* fill return parameter, e.g for usage in a datasource etc.
*  r_y0bw_xf_meas_txt = lt_y0bw_xf_meas_txt.


* update the masterdata table
*  loop at lt_y0bw_xf_meas_txt into  l_y0bw_xf_meas_txt.
*    modify y0bw_xf_meas_txt from l_y0bw_xf_meas_txt.
*  endloop.
*

    "  modify y0bw_xf_meas_txt from TABLE lt_y0bw_xf_meas_txt .
    "    me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_txt' changing c_th_data = lt_y0bw_xf_meas_txt ).
    me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_txt' changing c_th_data = lt_y0bw_xf_meas_txt ).
    me->_save_db_table( exporting i_tabname = 'y0bw_xf_meas_txt' i_delete = abap_false ).

*  select  measid langu objvers short_name middle_name long_name from y0bw_xf_meas_txt into corresponding fields of table lt_y0bw_xf_ds_zxf_meas_text
*    where objvers = 'A'.
*
*  move lt_y0bw_xf_ds_zxf_meas_text to r_y0bw_xf_meas_txt.           "pass values to returnparameter (Datasource)

  endloop. "reading over GEN Table
endmethod.


method _FILL_MEAS_ADD.
*
*  data:  lt_y0bw_xf_meas_add type standard table of y0bw_xf_meas_add .  "original values
*  data:  ls_y0bw_xf_meas_add like line of lt_y0bw_xf_meas_add.
*  data: l_y0bw_xf_meas_add type y0bw_xf_meas_add.
*  data:  lt_y0bw_xf_meas_add2 type standard table of y0bw_xf_meas_add .  "new values
*  data:  ls_y0bw_xf_meas_add2 like line of lt_y0bw_xf_meas_add2.
*  data: l_y0bw_xf_meas_add2 type y0bw_xf_meas_add.
*  data:  lt_y0bw_xf_meas_id type standard table of y0bw_xf_meas_id .
*  data:  ls_lt_y0bw_xf_meas_id like line of lt_y0bw_xf_meas_id .
*  data: string1 type string.
*  data: string2 type string.
*  data: string3 type string.
*
*
*
** first write already existing in a table
**  select * into table lt_y0bw_xf_meas_add from y0bw_xf_meas_add where  objvers = 'A'.   "measid like 'CARB%' and ... for all relevant
*
** now set basis for creating all measure entries in add-table for CARBS
*
*  select * from y0bw_xf_meas_id into table lt_y0bw_xf_meas_id where objvers = 'A' and measid like 'CARB%'.
*
*  loop at lt_y0bw_xf_meas_id into ls_lt_y0bw_xf_meas_id.
*    ls_y0bw_xf_meas_add2-measid = ls_lt_y0bw_xf_meas_id-measid.
*    ls_y0bw_xf_meas_add2-objvers = 'A'.
*    append ls_y0bw_xf_meas_add2 to lt_y0bw_xf_meas_add2.
*  endloop.
*
** update the table y0bw_xf_meas_add for the first time...now get new entries for CARB's
**    me->_delete_existing_recs( exporting I_TABNAME = 'y0bw_xf_meas_add' changing c_th_data = lt_y0bw_xf_meas_add2 ).
**modify y0bw_xf_meas_add from table lt_y0bw_xf_meas_add2.
*
** update the table y0bw_xf_meas_add2 for the second time (here we write back the already existing data)
*    me->_delete_existing_recs( exporting I_TABNAME = 'y0bw_xf_meas_add' changing c_th_data = lt_y0bw_xf_meas_add ).
*modify y0bw_xf_meas_add from table lt_y0bw_xf_meas_add.
*
*
*
** too long so go via 2 helpfields which are going to be concatenated.
*  string1 = 'SAP ERP Profit Center Accounting (For actual data of SAP companies); SAP BI CO Planning (For plan data of SAP companies);'.
*  string2 = 'SAP HFM (For Actual and plan data of Non SAP companies in EUR , as well as for Consolidation & adjustment postings excluding Marketing Consolidation)'.
*
*  concatenate string1 string2 into string3.
*
*
*    update y0bw_xf_meas_add
*    set source_system = string3
*    where measid like 'CARB%'
*    and objvers = 'A'.



endmethod.


method _fill_meas_cluster.

  types: begin of ty_authlook ,
            auth_cluster type yoxf_auth_cluster,
            nodename type rsshnodename ,
            tlevel type rstlevel ,
           end of ty_authlook .

  data:  lt_y0bw_xf_meas_ida type hashed table of y0bw_xf_meas_ida with unique key measid objvers.
  data:  lt_y0bw_xf_meas_ida_tmp type standard table of y0bw_xf_meas_ida.
  data: r_tab_leaves type y0bw_t_hzxfmeas.
  data: lt_list type standard table of y0bw_t_hzxfmeas.
  data:  lt_y0bw_xf_meas_id type standard table of y0bw_xf_meas_id .
  data:  ls_y0bw_xf_meas_id like line of lt_y0bw_xf_meas_id .
  data:  l_y0bw_xf_meas_id type y0bw_xf_meas_id.
  data: ls_hierdir type rshiedir.
  data:  tabix like sy-tabix.
  data: lt_authlook type hashed table of ty_authlook  with unique key nodename.
  data: ls_authlook like line of lt_authlook.
  data: lt_hzxf_meas type hashed table of /bic/hzxf_meas with unique key hieid objvers nodeid.
  data: lv_y0xf_measid type rsshnodename.
  data:  lt2_y0bw_xf_meas_ida type y0bw_xf_meas_ida .
  data: tab_y0bw_xf_meas_ida type y0bw_t_xf_meas_ida.
  data:  ls_hiedir type rshiedir.
  data: lt_y0bw_xf_meas_gen type standard table of y0bw_xf_meas_gen.
  data: ls_y0bw_xf_meas_gen like line of lt_y0bw_xf_meas_gen.
  data: tab_y0bw_xf_meas_id type y0bw_t_xf_meas_id.
  data: lth_y0bw_xf_meas_id type hashed table of y0bw_xf_meas_id with unique key measid.



  data y0bw_cl_xf_utilities type ref to y0bw_cl_xf_utilities.


  field-symbols:   <list> type /bic/hzxf_meas,
                   <fs_y0bw_xf_meas_ida> type y0bw_xf_meas_ida   ,
                   <fs_hzxf_meas> type /bic/hzxf_meas,
                   <fs_authlook> type ty_authlook.


* ... read table Y0BW_XF_MEAS_IDA (Measure ID Table for manual redefinitions) ... only Carb is relevant
  "  select * from y0bw_xf_meas_ida into table tab_y0bw_xf_meas_ida where objvers = 'A'.
  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_ida' changing c_th_data = tab_y0bw_xf_meas_ida ).
  delete tab_y0bw_xf_meas_ida where objvers <> 'A'.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = tab_y0bw_xf_meas_id ).
  delete tab_y0bw_xf_meas_id where objvers <> 'A' or measid(4) <> 'CARB'.
  lth_y0bw_xf_meas_id[] = tab_y0bw_xf_meas_id[].


  "select * from y0bw_xf_meas_gen into table lt_y0bw_xf_meas_gen where iobjnm = '0ACCOUNT' and objvers = 'A'.
  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_gen' changing c_th_data = lt_y0bw_xf_meas_gen ).
  delete lt_y0bw_xf_meas_gen where iobjnm <> '0ACCOUNT' or objvers <> 'A'.
  sort lt_y0bw_xf_meas_gen by priority descending.

*das ist das neue
  loop at lt_y0bw_xf_meas_gen into ls_y0bw_xf_meas_gen.
* we have to assume that the name of the hierarchies of 0ACCOUNT and ZXF_MEAS are identically
* get the details of the hierarchie
    select single * from rshiedir into ls_hiedir
        where hienm = ls_y0bw_xf_meas_gen-hienm and
             objvers = 'A' and iobjnm = 'ZXF_MEAS'.

** importparameter i_hieid passes the info
*  select single * from rshiedir into ls_hiedir
*    where hienm = 'CARBPROFIT'
*    and iobjnm = 'ZXF_MEAS'
*    and objvers = 'A'.

    select * into table lt_hzxf_meas from /bic/hzxf_meas where  hieid = ls_hiedir-hieid. "get hierarchy in meas id masterdata h - table
    "select * into table lt_y0bw_xf_meas_ida from y0bw_xf_meas_ida where auth_cluster  <>  '' . "get hierarchy in meas id masterdata h - table
    me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_ida' changing c_th_data = lt_y0bw_xf_meas_ida_tmp ).
    delete lt_y0bw_xf_meas_ida_tmp where auth_cluster  =  ''.
    lt_y0bw_xf_meas_ida[] = lt_y0bw_xf_meas_ida_tmp[].
    clear lt_y0bw_xf_meas_ida_tmp[].

*now get all top nodes having authorization cluster assigned
    sort   lt_hzxf_meas by tlevel .

    loop at lt_y0bw_xf_meas_ida assigning <fs_y0bw_xf_meas_ida>.
      read table lt_hzxf_meas assigning <fs_hzxf_meas> with key nodename = <fs_y0bw_xf_meas_ida>-measid.

      if sy-subrc = 0 .
* create helping construct (nodenames with cluster and Level)
        clear ls_authlook .
        ls_authlook-auth_cluster = <fs_y0bw_xf_meas_ida>-auth_cluster .
        ls_authlook-nodename = <fs_hzxf_meas>-nodename  .
        ls_authlook-tlevel = <fs_hzxf_meas>-tlevel  .
        insert ls_authlook into table lt_authlook .
      endif .

    endloop . "at lt_authlook assigning <fs_authlook>.

* sorting is necessary as get_subtree doesn't sort, and a node can be occur more than once: e.g node 123 is a subnode from Topnode as well as maybe from node 12
    sort lt_authlook by tlevel ascending.

    create object y0bw_cl_xf_utilities.

    loop at lt_authlook assigning <fs_authlook>.
      move <fs_authlook>-nodename to lv_y0xf_measid.
      call method y0bw_cl_xf_utilities->get_subtree
        exporting
          i_hieid                        = ls_hiedir-hieid
          i_iobjnm                       = 'ZXF_MEAS'
          i_value                        = lv_y0xf_measid
        importing
          r_tab_leaves                   = r_tab_leaves
        exceptions
          hieid_not_exists               = 1
          wrong_combination_value_iobjnm = 2
          wrong_value                    = 3
          others                         = 4.
      if sy-subrc <> 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*            WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
      endif.


* create a list of nodes and write them in an internal table with clusterinfo in addition
      if r_tab_leaves is not initial.
        loop at r_tab_leaves assigning <list>.
          clear: ls_y0bw_xf_meas_id.
          read table lth_y0bw_xf_meas_id into ls_y0bw_xf_meas_id with table key measid = <list>-nodename.

          ls_y0bw_xf_meas_id-measid = <list>-nodename.
          ls_y0bw_xf_meas_id-auth_cluster = <fs_authlook>-auth_cluster.

          append ls_y0bw_xf_meas_id to lt_y0bw_xf_meas_id.

* PAU-MRI 29.11.2012 better to do it this way
*          update y0bw_xf_meas_id
*          set auth_cluster = <fs_authlook>-auth_cluster
*          where measid = <list>-nodename
*          and objvers = 'A'.

        endloop. "at r_tab_leaves assigning <list>.
* 05/08/2013  PAU-MRI sollt so passen.
*me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
        me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
        clear lt_y0bw_xf_meas_id.
      endif. "r_tab_leaves is not initial.

    endloop. "at lt_authlook assigning <fs_authlook>.

*  05/08/2013PAU-MRI das ghört oben rein sonst wirds vermutlich net passen
*    me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
*    me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).

*PAU-MW
*  delete lt_y0bw_xf_meas_id where objvers <> 'A' .
*  data:  lt_y0bw_xf_meas_id_up type standard table of y0bw_xf_meas_id .
*    field-symbols:   <fs_y0bw_xf_meas_id_up> type y0bw_xf_meas_id  .
*     field-symbols:   <fs_y0bw_xf_meas_id> type y0bw_xf_meas_id  .
*  clear lt_y0bw_xf_meas_id_up .
*  select * into TABLE lt_y0bw_xf_meas_id_up from y0bw_xf_meas_id FOR ALL ENTRIES IN lt_y0bw_xf_meas_id WHERE measid = lt_y0bw_xf_meas_id-measid and objvers = 'A' .
*  loop  at lt_y0bw_xf_meas_id_up ASSIGNING <fs_y0bw_xf_meas_id_up> .
*    read TABLE lt_y0bw_xf_meas_id ASSIGNING  <fs_y0bw_xf_meas_id> WITH KEY measid =  <fs_y0bw_xf_meas_id_up>-measid  objvers = 'A' .
*    if sy-subrc = 0 .
*      <fs_y0bw_xf_meas_id_up>-auth_cluster = <fs_y0bw_xf_meas_id>-auth_cluster .
*    endif .
*  endloop .
*MODIFY y0bw_xf_meas_id from TABLE lt_y0bw_xf_meas_id_up .

** update Relevancy
*    clear: lt2_y0bw_xf_meas_ida, lt_y0bw_xf_meas_id, lth_y0bw_xf_meas_id, tab_y0bw_xf_meas_id[]..
*
*    me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = tab_y0bw_xf_meas_id ).
*    delete tab_y0bw_xf_meas_id where objvers <> 'A'.
*    lth_y0bw_xf_meas_id[] = tab_y0bw_xf_meas_id[].
*    loop at tab_y0bw_xf_meas_ida into lt2_y0bw_xf_meas_ida.
*      clear ls_y0bw_xf_meas_id.
*      read table lth_y0bw_xf_meas_id into ls_y0bw_xf_meas_id with table key measid = lt2_y0bw_xf_meas_ida-measid.
*      if sy-subrc = 0.
*        ls_y0bw_xf_meas_id-relevancy = lt2_y0bw_xf_meas_ida-relevancy.
*        append ls_y0bw_xf_meas_id to lt_y0bw_xf_meas_id.
*      endif.
*    endloop.
*
**    me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).
*    me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = lt_y0bw_xf_meas_id ).

    "    loop at lt_y0bw_xf_meas_id into l_y0bw_xf_meas_id.


    "      update  y0bw_xf_meas_id
    "         set relevancy = l_y0bw_xf_meas_id-relevancy
    "         where measid = l_y0bw_xf_meas_id-measid
    "         and objvers = 'A'.

    "    endloop.
*
    commit work.


*PAU-MW
*  clear lt_y0bw_xf_meas_id_up .
*  select * into TABLE lt_y0bw_xf_meas_id_up from y0bw_xf_meas_id FOR ALL ENTRIES IN lt_y0bw_xf_meas_id WHERE measid = lt_y0bw_xf_meas_id-measid and objvers = 'A' .
*  loop  at lt_y0bw_xf_meas_id_up ASSIGNING <fs_y0bw_xf_meas_id_up> .
*    read TABLE lt_y0bw_xf_meas_id ASSIGNING  <fs_y0bw_xf_meas_id> WITH KEY measid =  <fs_y0bw_xf_meas_id_up>-measid  objvers = 'A' .
*    if sy-subrc = 0 .
*      <fs_y0bw_xf_meas_id_up>-relevancy = <fs_y0bw_xf_meas_id>-relevancy .
*    endif .
*  endloop .
*MODIFY y0bw_xf_meas_id from TABLE lt_y0bw_xf_meas_id_up .

  endloop. "belongs to loop over GEN-Table

endmethod.


method _fill_meas_rep.
  data: lt_y0bw_xf_meas_id type y0bw_xf_meas_id.
  data: lt_y0bw_xf_rep_ida type y0bw_xf_rep_ida.
  data: lt_y0bw_xf_meas_rep type standard table of y0bw_xf_meas_rep.
  data: ls_y0bw_xf_meas_rep like line of lt_y0bw_xf_meas_rep.
  data: l_y0bw_xf_meas_rep type y0bw_xf_meas_rep.
  data: tab_y0bw_xf_meas_id type y0bw_t_xf_meas_id.
  data: tab_y0bw_xf_meas_ida type y0bw_t_xf_meas_ida.
  data: tab_y0bw_xf_rep_ida type y0bw_t_xf_rep_ida.

* ... read table Y0BW_XF_MEAS_ID (Measure ID Table) ... only CARB's all other are not relevant here
  "select * from y0bw_xf_meas_id into table tab_y0bw_xf_meas_id where measid like 'CARB%' and objvers = 'A'.
  me->_get_db_table( exporting i_tabname = 'y0bw_xf_meas_id' changing c_th_data = tab_y0bw_xf_meas_id ).
  delete tab_y0bw_xf_meas_id where objvers <> 'A' or measid(4) <> 'CARB'.

* ... read table Y0BW_XF_MEAS_IDA (Measure ID Table for manual redefinitions) ... only Carb is relevant
  "select * from y0bw_xf_meas_ida into table tab_y0bw_xf_meas_ida where objvers = 'A'.

* ...read table y0bw_xf_rep_ida (template table for Reporting parameters)
  "select * from y0bw_xf_rep_ida into table tab_y0bw_xf_rep_ida where measid like 'CARB%' and objvers = 'A'.

  me->_get_db_table( exporting i_tabname = 'y0bw_xf_rep_ida' changing c_th_data = tab_y0bw_xf_rep_ida ).
  delete tab_y0bw_xf_rep_ida where objvers <> 'A' or measid(4) <> 'CARB'.


  loop at tab_y0bw_xf_meas_id into lt_y0bw_xf_meas_id.      "go through all measures
    loop at tab_y0bw_xf_rep_ida into lt_y0bw_xf_rep_ida.    "go through template table regarding Reporting parameters
* Now set the values
      ls_y0bw_xf_meas_rep-measid = lt_y0bw_xf_meas_id-measid.
      ls_y0bw_xf_meas_rep-objvers = 'A'.
      ls_y0bw_xf_meas_rep-report = lt_y0bw_xf_rep_ida-report.
      ls_y0bw_xf_meas_rep-component = lt_y0bw_xf_rep_ida-component.
      ls_y0bw_xf_meas_rep-query = lt_y0bw_xf_rep_ida-query.
      ls_y0bw_xf_meas_rep-username = lt_y0bw_xf_rep_ida-username.
      ls_y0bw_xf_meas_rep-paramid = lt_y0bw_xf_rep_ida-paramid.
      ls_y0bw_xf_meas_rep-boolean = lt_y0bw_xf_rep_ida-boolean.
      ls_y0bw_xf_meas_rep-value = lt_y0bw_xf_rep_ida-value.
      ls_y0bw_xf_meas_rep-pcomment = lt_y0bw_xf_rep_ida-pcomment.
      append ls_y0bw_xf_meas_rep to lt_y0bw_xf_meas_rep.    "append it to an table
    endloop.
  endloop.


* update the table y0bw_xf_meas_rep only for 'CARB' measures
*  loop at lt_y0bw_xf_meas_rep into  l_y0bw_xf_meas_rep
*    where measid(4) eq 'CARB'.
*    modify y0bw_xf_meas_rep from l_y0bw_xf_meas_rep.
*  endloop.

  data: lt_y0bw_xf_meas_rep_up type standard table of y0bw_xf_meas_rep.
  clear : lt_y0bw_xf_meas_rep_up .
  loop at lt_y0bw_xf_meas_rep into ls_y0bw_xf_meas_rep  where measid(4) eq 'CARB'  .
    append ls_y0bw_xf_meas_rep to lt_y0bw_xf_meas_rep_up .
  endloop .
*  me->_delete_existing_recs( exporting i_tabname = 'y0bw_xf_meas_rep' changing c_th_data = lt_y0bw_xf_meas_rep_up ).
  me->_modify_db_table( exporting i_tabname = 'y0bw_xf_meas_rep' changing c_th_data = lt_y0bw_xf_meas_rep_up ).
  "modify y0bw_xf_meas_rep from table lt_y0bw_xf_meas_rep_up .

endmethod.


METHOD _generate_aclu_hier.

**********************
*DEFINITIONS
  TYPES: BEGIN OF ty_authlook ,
           auth_cluster TYPE yoxf_auth_cluster,
           auth_parent TYPE yoxf_auth_cluster ,
           iobjnm TYPE  rsiobjnm ,
           hienm TYPE rshienm ,
           nodename TYPE rsshnodename ,
           tlevel TYPE rstlevel ,
           slevel TYPE rstlevel ,
           nodeid TYPE rsshnodeid ,
           is_linked TYPE abap_bool ,
          END OF ty_authlook ,
         BEGIN OF ty_authnode ,
           nodename TYPE rsshnodename ,
          END OF ty_authnode .

  CONSTANTS: lc_objectid  TYPE /bi0/oiobjectid  VALUE '' ,
             lc_iobjnm TYPE rsiobjnm VALUE 'ZXF_MEAS' ,
             lc_h_hienm  TYPE rshienm  VALUE 'AUTHORIZATION' ,
             lc_langu TYPE langu  VALUE 'E'  .
*CONSTANTS: lc_hienm TYPE HIENM VALUE 'AUTHORIZATION' .
  DATA:    lt_y0bw_xf_s_hierlist TYPE y0bw_xf_s_hierlist_t
         , lt_y0bw_xf_meas_id TYPE HASHED TABLE OF y0bw_xf_meas_id WITH
            UNIQUE KEY measid objvers
         , lt_authlook TYPE HASHED TABLE OF ty_authlook  WITH UNIQUE KEY
            nodename hienm
         , ls_authlook TYPE ty_authlook
         , lt_authnode TYPE HASHED TABLE OF ty_authnode WITH UNIQUE KEY
            nodename
         , lv_nodeidauth TYPE rsshnodeid VALUE  0
         , lv_y0xf_measid TYPE y0xf_measid
         , lv_tlevel TYPE  rsshtlevel VALUE 0
         , lv_hieid TYPE rshieid
         , ls_authnode TYPE  ty_authnode
         , lv_tabix LIKE sy-tabix
         , lt_y0bw_xf_meas_ida TYPE y0bw_xf_meas_ida_t
         , ls_hiertab TYPE rssh_s_htab
         , lt_y0bw_t_hzxfmeas TYPE y0bw_t_hzxfmeas
         , lt_y0bw_t_hzxfmeas_subtree TYPE y0bw_t_hzxfmeas
         .

  FIELD-SYMBOLS: <fs_y0bw_xf_meas_ida> TYPE y0bw_xf_meas_ida
                 , <fs_hiertab> TYPE RSSH_S_HTAB
                 , <fs_hiertab_check> TYPE RSSH_S_HTAB
                 , <fs_y0bw_xf_meas_id> TYPE y0bw_xf_meas_id
                 , <fs_authnode> TYPE   ty_authnode
                 , <fs_y0bw_t_hzxfmeas> TYPE /bic/hzxf_meas
                 , <fs_y0bw_t_hzxfmeas_subtree> TYPE /bic/hzxf_meas
                 , <fs_y0bw_xf_s_hierlist>  TYPE  y0bw_xf_s_hierlist
                 , <fs_authlook2>  LIKE LINE OF lt_authlook
                 ,  <fs_authlook>  LIKE LINE OF lt_authlook
  .
**********************
*INIT

*get hieid AUHTCLUSTER!!


  lt_y0bw_xf_meas_id = y0bw_xf_kpi_il_v2=>get_measure_list(
     iv_max_hits = 0 ).

  lv_nodeidauth  = lv_nodeidauth  +   1 .
  lv_tlevel = lv_tlevel  +  1 .
  ls_hiertab-hieid = lv_hieid .
  ls_hiertab-objvers = 'A' .
  ls_hiertab-nodeid = lv_nodeidauth  .
  ls_hiertab-iobjnm   = '0HIER_NODE' .
  ls_hiertab-nodename = 'AUTHORIZATION' .
  ls_hiertab-tlevel  = lv_tlevel .
  ls_hiertab-link = '' .
  ls_hiertab-parentid = 0 .
  ls_hiertab-childid = 1 .
  ls_hiertab-nextid  = '' .
  APPEND ls_hiertab TO r_hiertab .

**********************
*GENERATE AUTH CLUSTER WITH NOT CARB
  LOOP AT lt_y0bw_xf_meas_id ASSIGNING <fs_y0bw_xf_meas_id> WHERE objvers = 'A' .
    IF NOT <fs_y0bw_xf_meas_id>-measid CP 'CARB*' AND <fs_y0bw_xf_meas_id>-auth_cluster <> ''   .
      READ TABLE r_hiertab TRANSPORTING NO FIELDS WITH KEY  nodename = <fs_y0bw_xf_meas_id>-auth_cluster .
      IF sy-subrc <> 0 .
        lv_nodeidauth  = lv_nodeidauth  +   1 .
        ls_hiertab-hieid = lv_hieid .
        ls_hiertab-objvers = 'A' .
        ls_hiertab-nodeid = lv_nodeidauth  .
        ls_hiertab-iobjnm   = 'ZXF_ACLU'  .
        ls_hiertab-nodename = <fs_y0bw_xf_meas_id>-auth_cluster .
        ls_hiertab-tlevel  = 2 .
        ls_hiertab-link = '' .
        ls_hiertab-parentid = 1 .
        ls_hiertab-childid = '' .
        ls_hiertab-nextid  = '' .
        APPEND ls_hiertab TO r_hiertab .

      ENDIF .
    ENDIF .
  ENDLOOP .
**********************
*GENERATE HIER
*GENERATE THE EASY PART WITH HIERARCHY CLUSTER

*GET MEAS HIERARCHY LIST
  y0bw_xf_kpi_il_v2=>get_measid_hier_list(
    RECEIVING
      r_hierlist    =   lt_y0bw_xf_s_hierlist
    EXCEPTIONS
      src_hierarchy_not_available = 1
     tgt_hierarchy_not_available = 2
         ).
  IF sy-subrc <> 0.
    RAISE generating_error .
  ELSE.

*TAKE PRIO 1 FIRST
    SORT lt_y0bw_xf_s_hierlist   BY priority .


*GET IDA DATA FOR ACLU NODES
    lt_y0bw_xf_meas_ida = y0bw_xf_kpi_il_v2=>get_meas_ida_data(
*    it_sel_parameters = it_sel_parameters
           ).
    CLEAR lt_y0bw_t_hzxfmeas.
    LOOP AT lt_y0bw_xf_s_hierlist ASSIGNING <fs_y0bw_xf_s_hierlist>  .
      y0bw_xf_kpi_il_v2=>get_measid_hier(
        EXPORTING
          i_hienm                 =  <fs_y0bw_xf_s_hierlist>-tgt_hienm
        RECEIVING
          r_hiertab               = lt_y0bw_t_hzxfmeas
        EXCEPTIONS
          hierarchy_not_available = 1
             ).
      IF sy-subrc <> 0.
*error in hierarchy
        RAISE generating_error .
      ELSE.

        SORT lt_y0bw_t_hzxfmeas BY nodeid .

        lv_tlevel = 3 .
*now get all top nodes having authorization cluster assigned
        LOOP AT lt_y0bw_t_hzxfmeas ASSIGNING <fs_y0bw_t_hzxfmeas>  .
          READ TABLE  lt_y0bw_xf_meas_ida ASSIGNING
          <fs_y0bw_xf_meas_ida> WITH KEY measid =
          <fs_y0bw_t_hzxfmeas>-nodename  objvers = 'A' .
          IF sy-subrc = 0 .
            READ TABLE lt_authlook TRANSPORTING NO FIELDS WITH KEY
            auth_cluster = <fs_y0bw_xf_meas_ida>-auth_cluster  .
            IF sy-subrc <> 0 .
              CLEAR ls_authlook .
              ls_authlook-auth_cluster = <fs_y0bw_xf_meas_ida>-auth_cluster .
              ls_authlook-nodename = <fs_y0bw_t_hzxfmeas>-nodename  .
              ls_authlook-iobjnm = 'ZXF_ACLU' .
              ls_authlook-slevel = <fs_y0bw_t_hzxfmeas>-tlevel  .
              lv_nodeidauth = lv_nodeidauth + 1 .
              ls_authlook-nodeid = lv_nodeidauth .
              ls_authlook-hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
              ls_authlook-is_linked = abap_false .
              INSERT ls_authlook INTO TABLE lt_authlook .
            ELSE.
*linked node
              READ TABLE lt_authlook TRANSPORTING NO FIELDS WITH KEY
              auth_cluster = <fs_y0bw_xf_meas_ida>-auth_cluster hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm  .
              IF sy-subrc <>  0 .
                CLEAR ls_authlook .
                ls_authlook-auth_cluster = <fs_y0bw_xf_meas_ida>-auth_cluster .
                ls_authlook-nodename = <fs_y0bw_t_hzxfmeas>-nodename  .
                ls_authlook-slevel = <fs_y0bw_t_hzxfmeas>-tlevel  .
                lv_nodeidauth = lv_nodeidauth + 1 .
                ls_authlook-nodeid = lv_nodeidauth .
                ls_authlook-hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
                ls_authlook-is_linked = abap_true .
                ls_authlook-iobjnm = 'ZXF_ACLU' .
                INSERT ls_authlook INTO TABLE lt_authlook .
              ENDIF .
            ENDIF .
          ELSE.
*lese cluster as kpi db
            READ TABLE lt_y0bw_xf_meas_id ASSIGNING <fs_y0bw_xf_meas_id> WITH TABLE KEY  measid =
                      <fs_y0bw_t_hzxfmeas>-nodename  objvers = 'A' .
            IF sy-subrc = 0 .
*read autlook if kpi cluster drin für eigene hierarchy?
              if <fs_y0bw_xf_meas_id>-auth_cluster is not INITIAL .
              READ TABLE lt_authlook TRANSPORTING NO FIELDS WITH KEY
                 auth_cluster = <fs_y0bw_xf_meas_id>-auth_cluster hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm  .
              IF sy-subrc = 0 .
* mein node is in hierarchy do nothing
              ELSE .
*check if parent is in other hierarchy
                READ TABLE lt_authlook TRANSPORTING NO FIELDS WITH KEY auth_cluster = <fs_y0bw_xf_meas_id>-auth_cluster  is_linked = abap_false .
                IF sy-subrc = 0 .
                  CLEAR ls_authlook .
                  ls_authlook-auth_cluster = <fs_y0bw_xf_meas_id>-auth_cluster  .
                  ls_authlook-nodename = <fs_y0bw_t_hzxfmeas>-nodename  .
                  ls_authlook-slevel = <fs_y0bw_t_hzxfmeas>-tlevel  .
                  lv_nodeidauth = lv_nodeidauth + 1 .
                  ls_authlook-nodeid = lv_nodeidauth .
                  ls_authlook-hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
                  ls_authlook-is_linked = abap_true .
                  ls_authlook-iobjnm = 'ZXF_ACLU' .
                  INSERT ls_authlook INTO TABLE lt_authlook .
                ELSE .
                  RAISE generating_error .
                ENDIF .
              ENDIF.
*wenn nicht drin lies nach ob schon
              ENDIF.
*fehler
            ENDIF .

          ENDIF .
        ENDLOOP .


**GET THE RIGHT PARAENTS
        LOOP AT lt_authlook ASSIGNING <fs_authlook> WHERE hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
          lv_tabix = sy-tabix .
          CLEAR lt_y0bw_t_hzxfmeas .
          y0bw_cl_xf_utilities=>get_subtree(
            EXPORTING
              i_hieid                        = <fs_y0bw_xf_s_hierlist>-tgt_hieid
              i_iobjnm                       = lc_iobjnm
              i_value                        = <fs_authlook>-nodename
            IMPORTING
             r_tab_leaves                   =  lt_y0bw_t_hzxfmeas_subtree
            EXCEPTIONS
              hieid_not_exists               = 1
              wrong_combination_value_iobjnm = 2
              wrong_value                    = 3
                 ).
          IF sy-subrc <> 0.
            RAISE generating_error .
          ELSE .
*    *save childs level -> + 1 due to new node
            LOOP AT  lt_y0bw_t_hzxfmeas_subtree  ASSIGNING
            <fs_y0bw_t_hzxfmeas_subtree> .
              IF  <fs_y0bw_t_hzxfmeas_subtree>-nodename <>
              <fs_authlook>-nodename  .
*alle daruner
                READ TABLE lt_authlook ASSIGNING  <fs_authlook2>
                WITH KEY nodename = <fs_y0bw_t_hzxfmeas_subtree>-nodename hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm
                .
                IF sy-subrc =  0 .
*vater darf kein linked node sein
                  if <fs_authlook>-is_linked = abap_false .
                  <fs_authlook2>-auth_parent =
                  <fs_authlook>-auth_cluster .
                  else.
*delete under linked
                   delete lt_authlook where nodename = <fs_y0bw_t_hzxfmeas_subtree>-nodename and hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .

                  endif .
                ENDIF .
              ENDIF .
            ENDLOOP.
          ENDIF.
        ENDLOOP.

*now level
        SORT lt_authlook BY slevel .
        LOOP AT lt_authlook ASSIGNING <fs_authlook> WHERE hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
          IF <fs_authlook>-auth_parent EQ '' .
            <fs_authlook>-tlevel = 3 .
          ELSE.
            READ TABLE lt_authlook ASSIGNING  <fs_authlook2>
            WITH KEY auth_cluster = <fs_authlook>-auth_parent
            .
            IF sy-subrc =  0 .
              <fs_authlook>-tlevel = <fs_authlook2>-tlevel + 1   .
            ELSE.
*error in hierarchy
              RAISE generating_error .
              EXIT .
            ENDIF .
          ENDIF .
        ENDLOOP .
        SORT lt_authlook BY nodeid .

*genmerate topnode

        lv_nodeidauth  = lv_nodeidauth  +   1 .
        ls_hiertab-hieid = lv_hieid .
        ls_hiertab-objvers = 'A' .
        ls_hiertab-nodeid = lv_nodeidauth  .
        ls_hiertab-iobjnm   = '0HIER_NODE'  .
        ls_hiertab-nodename = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
        ls_hiertab-tlevel  = 2 .
        ls_hiertab-link = '' .
        ls_hiertab-parentid = 1 .
        ls_hiertab-childid = '' .
        ls_hiertab-nextid  = '' .
        APPEND ls_hiertab TO r_hiertab .


*get hier

       LOOP AT lt_authlook ASSIGNING <fs_authlook> WHERE hienm = <fs_y0bw_xf_s_hierlist>-tgt_hienm .
          IF <fs_authlook>-auth_parent EQ '' .
            ls_hiertab-parentid = 1 .
          else.

          endif .
              lv_nodeidauth  = lv_nodeidauth  +   1 .
              ls_hiertab-hieid = lv_hieid .
              ls_hiertab-objvers = 'A' .
              ls_hiertab-nodeid = lv_nodeidauth  .
              ls_hiertab-iobjnm   = <fs_authlook>-iobjnm   .
              ls_hiertab-nodename = <fs_authlook>-auth_cluster  .
              ls_hiertab-tlevel  = <fs_authlook>-tlevel .
              ls_hiertab-link = <fs_authlook>-is_linked .
              ls_hiertab-childid = '' .
              ls_hiertab-nextid  = '' .
              APPEND ls_hiertab TO r_hiertab .

        ENDLOOP .

      ENDIF.
    ENDLOOP.


          SORT r_hiertab BY nodeid ASCENDING .
          LOOP AT r_hiertab ASSIGNING  <fs_hiertab>   .
** Determine next id
            lv_tabix = sy-tabix + 1.
            LOOP AT r_hiertab  ASSIGNING
            <fs_hiertab_check>
            FROM lv_tabix.
              IF <fs_hiertab>-tlevel =
              <fs_hiertab_check>-tlevel.
                <fs_hiertab>-nextid =
                <fs_hiertab_check>-nodeid.
                EXIT.
              ELSEIF <fs_hiertab_check>-tlevel <
              <fs_hiertab>-tlevel.
                EXIT.
              ENDIF.
            ENDLOOP.
* Determine child id
            LOOP AT r_hiertab ASSIGNING
            <fs_hiertab_check>
            FROM lv_tabix.
              IF <fs_hiertab>-tlevel <
              <fs_hiertab_check>-tlevel.
                <fs_hiertab>-childid =
                <fs_hiertab_check>-nodeid.
                EXIT.
              ELSEIF <fs_hiertab>-tlevel >=
              <fs_hiertab_check>-tlevel.
                EXIT.
              ENDIF.
            ENDLOOP.
          ENDLOOP.
* Determine parent
          SORT  r_hiertab BY nodeid DESCENDING .
          LOOP AT  r_hiertab ASSIGNING <fs_hiertab>  .
            lv_tabix = sy-tabix + 1.
            LOOP AT  r_hiertab  ASSIGNING
            <fs_hiertab_check>
            FROM lv_tabix.
              IF <fs_hiertab>-tlevel >
              <fs_hiertab_check>-tlevel.
                <fs_hiertab>-parentid =
                <fs_hiertab_check>-nodeid.
                EXIT.
              ENDIF.

            ENDLOOP.
          ENDLOOP.
          SORT  r_hiertab BY nodeid ASCENDING .


  ENDIF.

ENDMETHOD.


method _GENERATE_DELTA.
  data: data_record    type ref to data,
        existingdatarecord type ref to data,
              dbtable type ref to data,
              ls_table_buffer type me->ts_table_buffer.
  field-symbols: <data> type any,
                 <existingdata> type any,
                 <buffer_table> type any table,
                 <htab> type any.

  data: ls_tmp type me->ts_table_buffer.
  data: ls_buffer type me->ts_table_buffer.
  data: ls_tmp_hash type me->ts_hash.
  data: lt_tmp_hash type hashed table of me->ts_hash with unique key hash.
  data: lt_buffer_hash type hashed table of me->ts_hash with unique key hash.
  data: ls_buffer_hash like line of lt_buffer_hash.
  data: ls_buffer_tmp type me->ts_hash.

  field-symbols: <fs_tmp_hash> type hashed table." of me->ts_hash.
  field-symbols: <fs_tmp_htab> type standard table.
  field-symbols: <fs_buffer_hash> type hashed table." me->ts_hash.
  field-symbols: <fs_buffer_htab> type standard table.
  field-symbols: <fs_s_tmp_htab> type any.
  field-symbols: <fs_s_tmp_hash> type me->ts_hash.
  field-symbols: <fs_s_buffer_hash> type me->ts_hash.

* Load i_tabname from DB into <buffer_table>
  create data dbtable type table of (i_tabname).
  assign dbtable->* to <buffer_table>.
  me->_get_db_table( exporting i_tabname = i_tabname i_force_reload = abap_true changing c_th_data = <buffer_table> ).

* Get tmp table and db table
  read table me->at_table_tmp into ls_tmp with table key tabname = i_tabname.
  read table me->at_table_buffer into ls_buffer with table key tabname = i_tabname.

  assign ls_tmp-hash->* to <fs_tmp_hash>.
  if sy-subrc <> 0. exit. endif.
  assign ls_tmp-htab->* to <fs_tmp_htab>.
  assign ls_buffer-hash->* to <fs_buffer_hash>.
  assign ls_buffer-htab->* to <fs_buffer_htab>.
  lt_tmp_hash[] = <fs_tmp_hash>[].
  lt_buffer_hash[] = <fs_buffer_hash>[].

* Identify new or changed records
  loop at <fs_tmp_hash> ASSIGNING <fs_s_tmp_hash>.
    read table lt_buffer_hash transporting no fields with table key hash = <fs_s_tmp_hash>-hash.
    if sy-subrc <> 0.
      read TABLE <fs_tmp_htab> INDEX <fs_s_tmp_hash>-idx ASSIGNING <fs_s_tmp_htab>.
      insert <fs_s_tmp_htab> into table e_t_modrec.
    endif.
  endloop.

* Identify records which should be deleted
  loop at <fs_buffer_hash> ASSIGNING <fs_s_buffer_hash>.
    read table lt_tmp_hash transporting no fields with table key hash = <fs_s_buffer_hash>-hash.
    if sy-subrc <> 0.
      read TABLE <fs_buffer_htab> INDEX <fs_s_buffer_hash>-idx ASSIGNING <fs_s_tmp_htab>.
      insert <fs_s_tmp_htab> into table e_t_delrec.
    endif.
  endloop.

endmethod.


method _get_db_table.
  data: ls_table_buffer type me->ts_table_buffer.
  data: ls_hash type me->ts_hash.
  data: lv_str type string.
  data: lv_str_tmp type string.
  field-symbols: <buffer_table> type any table.
  field-symbols: <fs_t_hash> type any table.
  field-symbols: <fs_s_buffer_table> type any.

  data: lt_keys       type standard table of fieldname.
  data: lv_key like line of lt_keys.
  data: lv_tabname type tabname.
  field-symbols: <lv_str> type any.

  data:   lr_structdescr1 type ref to cl_abap_structdescr,
   lt_comps1       type cl_abap_structdescr=>component_table,
   lw_comp1        type line of cl_abap_structdescr=>component_table.

  read table me->at_table_buffer into ls_table_buffer with table key tabname = i_tabname.
  if sy-subrc <> 0 or i_force_reload eq abap_true.
    clear ls_table_buffer.

    create data ls_table_buffer-htab type table of (i_tabname).
    assign ls_table_buffer-htab->* to <buffer_table>.
    select * from (i_tabname) into table <buffer_table>.
    ls_table_buffer-tabname = i_tabname.

    create data ls_table_buffer-hash type hashed table of me->ts_hash with unique key hash.
    assign ls_table_buffer-hash->* to <fs_t_hash>.

    loop at <buffer_table> assigning <fs_s_buffer_table>.
      ls_hash-idx = sy-tabix.
      lr_structdescr1 ?= cl_abap_structdescr=>describe_by_data(
                                               <fs_s_buffer_table> ).
      lt_comps1 = lr_structdescr1->get_components( ).
      sort lt_comps1 ascending.
      loop at lt_comps1 into lw_comp1.
        assign component lw_comp1-name of structure <fs_s_buffer_table> to <lv_str>.
        if sy-subrc = 0.
          lv_str_tmp = <lv_str>.
          concatenate lv_str_tmp lv_str into lv_str.
        endif.
      endloop.

      cl_abap_container_utilities=>fill_container_c(
      exporting
          im_value = lv_str
            importing
                  ex_container = lv_str ).

      call function 'CALCULATE_HASH_FOR_CHAR'
        exporting
          data = lv_str
        importing
          hash = ls_hash-hash.

      insert ls_hash into table <fs_t_hash>.
      clear: ls_hash, lv_str.
    endloop.

    insert ls_table_buffer into table me->at_table_buffer.
    if sy-subrc <> 0.
      modify table me->at_table_buffer from ls_table_buffer.
    endif.
  else.
    assign ls_table_buffer-htab->* to <buffer_table>.
  endif.

  c_th_data = <buffer_table>.
endmethod.


method _modify_db_table.
  data: ls_table_buffer type me->ts_table_buffer.
  data: ls_table_db type me->ts_table_buffer.
  data: lth_data_tmp type ref to data.
  data: lt_keys       type standard table of fieldname.
  data: lv_tabname type tabname.
  field-symbols: <buffer_table> type any table,
                 <hash_table> type any table,
                 <fs_data_tmp> type any table,
                 <ls_data> type any.


  data: ls_hash type me->ts_hash.
  data: lv_str type string.
  data: lv_str_tmp type string.
  data: lv_key like line of lt_keys.
  field-symbols: <fs_t_hash> type any table.
  field-symbols: <fs_s_buffer_table> type any.
  field-symbols: <lv_str> type any.
  field-symbols: <fs_t_db_table> type any table.
  data: dummy_data type ref to data.
  data: ls_table_orig type me->ts_table_buffer.
  data: dummy_hashed_data type ref to data.
  field-symbols: <fs_t_db_htable> type any table.
  data:   lr_structdescr1 type ref to cl_abap_structdescr,
 lt_comps1       type cl_abap_structdescr=>component_table,
 lw_comp1        type line of cl_abap_structdescr=>component_table.

  if c_th_data is not initial.

*  modify (i_tabname) from table c_th_data.

    read table me->at_table_tmp into ls_table_buffer with table key tabname = i_tabname.
    if sy-subrc <> 0.
      ls_table_buffer-tabname = i_tabname.
      create data ls_table_buffer-htab type standard table of (i_tabname).
      create data ls_table_buffer-hash type hashed table of me->ts_hash with unique key idx.
      insert ls_table_buffer into table me->at_table_tmp.
    endif.

    lv_tabname = i_tabname.
    translate lv_tabname to upper case.
    select fieldname from dd03l into table lt_keys where tabname = lv_tabname and keyflag = 'X'.

    assign ls_table_buffer-htab->* to <buffer_table>.
    assign ls_table_buffer-hash->* to <hash_table>.

    create data lth_data_tmp type hashed table of (i_tabname) with unique key (lt_keys).
    assign lth_data_tmp->* to <fs_data_tmp>.

    <fs_data_tmp> = <buffer_table>.

    loop at c_th_data assigning <ls_data>.
      modify table <fs_data_tmp> from <ls_data>.
      if sy-subrc <> 0.
        insert <ls_data> into table <fs_data_tmp>.
      endif.
    endloop.

    <buffer_table> = <fs_data_tmp>.

    assign ls_table_buffer-hash->* to <fs_t_hash>.
    clear <fs_t_hash>. "remove all contest from DB Table

    loop at <buffer_table> assigning <fs_s_buffer_table>.
      ls_hash-idx = sy-tabix.
      lr_structdescr1 ?= cl_abap_structdescr=>describe_by_data(
                                               <fs_s_buffer_table> ).
      lt_comps1 = lr_structdescr1->get_components( ).
      sort lt_comps1 ascending.
      loop at lt_comps1 into lw_comp1.
        assign component lw_comp1-name of structure <fs_s_buffer_table> to <lv_str>.
        if sy-subrc = 0.
          lv_str_tmp = <lv_str>.
          concatenate lv_str_tmp lv_str into lv_str.
        endif.
      endloop.

      cl_abap_container_utilities=>fill_container_c(
      exporting
          im_value = lv_str
            importing
                  ex_container = lv_str ).

      call function 'CALCULATE_HASH_FOR_CHAR'
        exporting
          data = lv_str
        importing
          hash = ls_hash-hash.

      "ls_hash-hash = lv_str.

      insert ls_hash into table <fs_t_hash>.
      clear: ls_hash, lv_str.
    endloop.

    <hash_table> = <fs_t_hash>.

*    Synchronize buffered tables
    delete me->at_table_buffer where tabname = i_tabname.
    insert ls_table_buffer into table me->at_table_buffer.

  endif. "c_th_data is not INITIAL.
endmethod.


method _save_db_table.
  data: ls_table_buffer type me->ts_table_buffer.
  data: ld_modrec type ref to data.
  data: ld_delrec type ref to data.

  field-symbols: <fs_t_modrec> type any table.
  field-symbols: <fs_t_delrec> type any table.

  create data ld_modrec type standard table of (i_tabname).
  assign ld_modrec->* to <fs_t_modrec>.
  create data ld_delrec type standard table of (i_tabname).
  assign ld_delrec->* to <fs_t_delrec>.

  me->_generate_delta( exporting i_tabname = i_tabname changing e_t_modrec = <fs_t_modrec> e_t_delrec = <fs_t_delrec> ).

  if i_delete eq abap_true.
    delete (i_tabname) from table <fs_t_delrec>.
    insert (i_tabname) from table <fs_t_modrec>.
  else.
    modify (i_tabname) from table <fs_t_modrec>.
  endif.


endmethod.
ENDCLASS.