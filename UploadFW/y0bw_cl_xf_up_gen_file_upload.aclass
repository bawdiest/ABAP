class Y0BW_CL_XF_UP_GEN_FILE_UPLOAD definition
  public
  create public

  global friends Y0BW_CL_XF_TRANSFORM_UPL .

public section.
*"* public components of class Y0BW_CL_XF_UP_GEN_FILE_UPLOAD
*"* do not include other source files here!!!
  type-pools RS .
  type-pools RSAA .
  type-pools RSD .
  type-pools RSTR .
  type-pools Y0XFU .

  interfaces IF_RSPLFA_SRVTYPE_IMP_EXEC .
  interfaces ZIF_EX_RSPLF_FILE_UPLOAD .

  types:
    begin of T_S_REC_MSG,
    ZXF_RECNO    type /BIC/OIZXF_RECNO,  "Record Number
    ZXF_LINNO    type /BIC/OIZXF_LINNO,  "Line Number (f. Messages)
    ZXF_MSGID    type /BIC/OIZXF_MSGID,  "Message Class
    ZXF_MSGTY    type /BIC/OIZXF_MSGTY,  "Message Type
    ZXF_MSGNO    type /BIC/OIZXF_MSGNO,  "Message Number
    ZXF_MSGV1    type /BIC/OIZXF_MSGV1,  "Message Variable 1
    ZXF_MSGV2    type /BIC/OIZXF_MSGV1,  "Message Variable 2
    ZXF_MSGV3    type /BIC/OIZXF_MSGV1,  "Message Variable 3
    ZXF_MSGV4    type /BIC/OIZXF_MSGV1,  "Message Variable 4
    ZXF_MSGT1    type /BIC/OIZXF_MSGT1,  "Message Text 1/4
    ZXF_MSGT2    type /BIC/OIZXF_MSGT2,  "Message Text 2/4
    ZXF_MSGT3    type /BIC/OIZXF_MSGT3,  "Message Text 3/4
    ZXF_MSGT4    type /BIC/OIZXF_MSGT4,  "Message Text 4/4
  end   of T_S_REC_MSG .
  types:
    T_T_REC_MSG type standard table of T_S_REC_MSG .
  types:
    begin of T_S_MPCT_CURR,
    ZXF_MPCT type /BIC/OIZXF_MPCT,               "Management Profit Center
    ZXF_CURR type /BIC/OIZXF_CURR,               "Currency Key
  end   of T_S_MPCT_CURR .
  types:
    T_T_MPCT_CURR  type standard table of T_S_MPCT_CURR .
  types:
    T_TH_MPCT_CURR type hashed   table of T_S_MPCT_CURR with unique key ZXF_MPCT
                                                                      ZXF_CURR .
  types:
    begin of T_S_TREATMENT_CHAS,
    CHARACTERISTIC   type /BI0/OITCTIOBJNM,     ">>KEY:  ZXF_MEAS: Name of characteristic
    n_ColIdx         type SY-TABIX,             "Column Index of data records for Index access rather than access by name
    b_chavl          type boolean,              "all characteristics
    b_toupper        type boolean,              "characteristics, which do not allow lowercase letters
    b_convexit       type boolean,              "characteristics, which have a conversion exit assigned
    b_typeconv       type boolean,              "numeric characteristics including time characteristics ("1" -> "12")
*   Data Type and conversion exit
    IOBJNM           type RSIOBJNM,             "InfoObject
    IOBJTP           type RSIOBJTP,             "Type of an InfoObject
    DATATP           type DATATYPE_D,           "Data Type in ABAP Dictionary
    INTLEN           type RSDINTLEN,            "Internal Length of InfoObjects in BW - see Docu
    OUTPUTLEN        type OUTPUTLEN,            "Output Length
    CONVEXIT         type CONVEXIT,             "Conversion Routine Typ: e.g.'ALPHA'
*   CONVEXIT_FUNC    type string,               "Conversion Routine:     e.g. 'CONVERSION_EXIT_ALPHA_INPUT'
    LOWERCASE        type LOWERCASE,            "Lowercase letters allowed/not allowed
    INTTP            type INTTYPE,              "ABAP data type (C,D,N,...)
    DECIMALS         type DECIMALS,             "Number of Decimal Places
    DIGITS           type RSDIGITS,             "Number of Characters in Field
    TXTSH            type RSTXTSH,              "Short description
    REF_VAL_INT      type REF TO DATA,          "Reference to the value in internal format
  end of T_S_TREATMENT_CHAS .
  types:
    T_T_TREATMENT_CHAS type standard table of T_S_TREATMENT_CHAS .
  types:
    begin of T_S_HEAD_TO_DIM,
*   Mapping from Source: Fieldname to Destination: Dimension
    FIELDNM_SRC      type /BI0/OITCTIOBJNM,  ">>KEY:  ZXF_CHA01: Name of characteristic or keyfigure name in the source record
    FIELDNM_DST      type /BI0/OITCTIOBJNM,  ">>ATTR: ZXF_MEAS:  Characteristic in the CDM Upload Cube(s) for CHARACTERISTICS,
                                             "                   the filed content is NOT DEFINED         for KEYFIGURES,
                                             "                   because the physical keyfigure depends on the measure id !!!
*   Attributes
    n_ColIdx         type SYTABIX,              "Column Index of data records  for Index access rather than access by name (CHAS and KYFS)
    n_ColIdxStatKyf  type SYTABIX,              "Column Index of status record for Index access rather than access by name
                                                "     ONLY FOR KEYFIGURE __DESCRIPTION__ IN THE STATUS RECORD !!!
    DIMNM            type Y0XF_IOBJNM,          "Dimension (Characteristic)
    COL_HEADER       type Y0XF_COLUMN_HEADER,   "Column Header for Upload
    HEADER_TYPE      type Y0XF_HEADER_TYPE,     "Header Type {CHA, KYF}
    HEADER_SUBTYPE   type Y0XF_HEADER_SUBTYPE,
    KFY_MONTH        type /BI0/OICALMONTH2,
    COL_HEAD_LOW     type RSTXTLG,              "Column Header as delivered
                                                "(not translated to uppcer case)
                                                "for messages
    ZKP_HEAD_NAME    type RSTXTLG,              "Column header CAPITALIZED
*  Treatment
   b_treatment       type boolean,              "Any treatment necessary ?
   LS_TREATMENT_CHAS type T_S_TREATMENT_CHAS,
  end   of T_S_HEAD_TO_DIM .
  types:
    T_T_HEAD_TO_DIM type standard table of T_S_HEAD_TO_DIM with non-unique default key .
  types:
    T_TH_HEAD_TO_DIM type hashed   table of T_S_HEAD_TO_DIM with unique key
                                                               FIELDNM_SRC .

  constants CN_MAX_TOT type I value 200. "#EC NOTEXT
  constants:
    begin of C_ZXF_CURT,
      LOC_CURR             type /BIC/OIZXF_CURT value '1', "Local currency
      GRP_CURR             type /BIC/OIZXF_CURT value '2', "Group currency
      NON_CURR             type /BIC/OIZXF_CURT value '3', "Non-currency related
    end   of C_ZXF_CURT .

  class-methods _GET_TIME
    returning
      value(R_TIME_STR) type TEXT60 .
  methods CONSTRUCTOR .
protected section.
*"* protected components of class Y0BW_CL_XF_UP_GEN_FILE_UPLOAD
*"* do not include other source files here!!!
private section.

*"* private components of class Y0BW_CL_XF_UP_GEN_FILE_UPLOAD
*"* do not include other source files here!!!
  constants CN_MAX_CHAS type I value 40 ##NO_TEXT.
  constants CN_MAX_KYFS type I value 12 ##NO_TEXT.
  constants C_0TCTSYSID_RBD777 type STRING value 'RBD777' ##NO_TEXT.
  constants:
    begin of C_Y0XF_HEADER_TYPE,
      CHAS type Y0XF_HEADER_TYPE value 'CHA',
      KYFS type Y0XF_HEADER_TYPE value 'KYF',
      XXXX type Y0XF_HEADER_TYPE value 'XXX',
    end of C_Y0XF_HEADER_TYPE .
  constants:
    begin of C_Y0XF_HEADER_SUBTYPE,
      KFYMON   type Y0XF_HEADER_SUBTYPE value 'KFYMON',
      KFYVAL   type Y0XF_HEADER_SUBTYPE value 'KFYVAL',
      TIMMONTH type Y0XF_HEADER_SUBTYPE value 'TIMMONTH',
      TIMYEAR  type Y0XF_HEADER_SUBTYPE value 'TIMYEAR',
      UNIT     type Y0XF_HEADER_SUBTYPE value 'UNIT',
      CUKY     type Y0XF_HEADER_SUBTYPE value 'CUKY',
    end of C_Y0XF_HEADER_SUBTYPE .
  constants:
    begin of C_FILETYPE_KYF,
      PERIODIC type string value 'KFYMON',
      VALUE    type string value 'KFYVAL',
    end of C_FILETYPE_KYF .
  constants:
    begin of C_FIELDNAME_PREAFIX,
      LEN  type N      value 7,
      CHAS type STRING value 'ZXF_CHA',                              "Upload Characteristics
      KYFS type STRING value 'ZXF_KYF',                              "Keyfigures
    end of C_FIELDNAME_PREAFIX .
  constants C_FIELDNAME_LEN type N value 9 ##NO_TEXT.
  constants:
    begin of C_CUBE,
      STATUS_ADMIN         type STRING value 'ZXF_R301',
      GENERIC_UPLOAD       type STRING value 'ZXF_R302',
      MESSAGES             type STRING value 'ZXF_R303',
    end of C_CUBE .
  constants:
    begin of C_ZXF_STAT,
      FILE_NOT_READABLE  type /BIC/OIZXF_STAT value 'FILENOTREAD',
      INVALID_FILE       type /BIC/OIZXF_STAT value 'INVALIDFILE',
      VALID_FILE         type /BIC/OIZXF_STAT value 'VALIDFILE',
      NO_AUTHORIZATION   type /BIC/OIZXF_STAT value 'NO_AUTHORIZATION',
      CANCELLED          type /BIC/OIZXF_STAT value 'CANCELLED',
      SUBMITREQ          type /BIC/OIZXF_STAT value 'SUBMITREQ',
      SUBMITTED          type /BIC/OIZXF_STAT value 'SUBMITTED',
      SUBMIT_FAILED      type /BIC/OIZXF_STAT value 'SUBMIT_FAILED',
      DELETEREQ          type /BIC/OIZXF_STAT value 'DELETEREQ',
      DELETED            type /BIC/OIZXF_STAT value 'DELETED',
      DELETE_FAILED      type /BIC/OIZXF_STAT value 'DELETE_FAILED',
    end of C_ZXF_STAT .
  constants:
    begin of C_Y0XF_PURPOSE,
      ACT type Y0XF_PURPOSE value 'ACT', "Actual Data (vs. Plan Data)
      AUX type Y0XF_PURPOSE value 'AUX', "Restriction for auxiliary measures
      GEN type Y0XF_PURPOSE value 'GEN', "General / Reporting
      HIE type Y0XF_PURPOSE value 'HIE', "Hierarchy Node (created automatically)
      NOS type Y0XF_PURPOSE value 'NOS', "Non SAP Data (vs. SAP Data)
      PLA type Y0XF_PURPOSE value 'PLA', "Plan Data (vs. Actual Data)
      SAP type Y0XF_PURPOSE value 'SAP', "SAP Data (vs. Non-SAP)
      SUM type Y0XF_PURPOSE value 'SUM', "Hierarchy Node Sum as constant selection
      TRA type Y0XF_PURPOSE value 'TRA', "Transformation
      UPL type Y0XF_PURPOSE value 'UPL', "Upload Framework
    end of C_Y0XF_PURPOSE .
  constants:
    begin of C_Y0XF_SELTP,
      _1 type RSZSELTP value '1', "Area Selection
      _2 type RSZSELTP value '2', "Nodes
      _3 type RSZSELTP value '3', "Compounded Value
      _4 type RSZSELTP value '4', "Selection Option
      _5 type RSZSELTP value '5', "Calculated Key Figure
      _6 type RSZSELTP value '6', "Basic Key Figure
      _7 type RSZSELTP value '7', "Restricted Key Figure
      _8 type RSZSELTP value '8', "Query Variable
    end   of C_Y0XF_SELTP .
  constants:
    begin of C_Y0XF_UNIT_TYPE,
      C type Y0XF_UNIT_TYPE value 'C', "Currency
      N type Y0XF_UNIT_TYPE value 'N', "Number
      U type Y0XF_UNIT_TYPE value 'U', " Unit
    end   of C_Y0XF_UNIT_TYPE .
  constants:
    begin of C_Y0XF_PHYS_KEY_FIGURE,
*     Cumulative keyfigures
      ZXF_AMNT type Y0XF_PHYS_KEY_FIGURE value 'ZXF_AMNT',    "Amount
      ZXF_QUAN type Y0XF_PHYS_KEY_FIGURE value 'ZXF_QUAN',    "Quantity
      ZXF_NUMB type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NUMB',    "Number
      ZXF_AMNF type Y0XF_PHYS_KEY_FIGURE value 'ZXF_AMNF',    "Amount (Float.)
      ZXF_QUAF type Y0XF_PHYS_KEY_FIGURE value 'ZXF_QUAF',    "Quantity (Float.)
      ZXF_NUMF type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NUMF',    "Number (Float.)
*     Non-Cumulative keyfigures
*      ZXF_NCAMN type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NCAMN',  "(Non-Kumulative Betraege - Basiskennzahl ZXF_AMNT)
*      ZXF_NCQUA type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NCQUA',  "(Non-Kumulative Mengen   - Basiskennzahl ZXF_QUAN)
*      ZXF_NCNUM type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NCNUM',  "(Non-Kumulative Zahlen   - Basiskennzahl ZXF_NUMB)
*      ZXF_NCAMF type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NCAMF',  "(Non-Kumulative Betraege - Basiskennzahl ZXF_AMNF)
*      ZXF_NCQUF type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NCQUF',  "(Non-Kumulative Mengen   - Basiskennzahl ZXF_QUAF)
*      ZXF_NCNUF type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NCNUF',  "(Non-Kumulative Zahlen   - Basiskennzahl ZXF_NUMF)
*     ZXF_FLTP type Y0XF_PHYS_KEY_FIGURE value 'ZXF_FLTP', "Floating point
*     ZXF_INTE type Y0XF_PHYS_KEY_FIGURE value 'ZXF_INTE', "Integer
*     ZXF_NOCU type Y0XF_PHYS_KEY_FIGURE value 'ZXF_NOCU', "Non-cumulative value
    end   of C_Y0XF_PHYS_KEY_FIGURE .
  constants:
    begin of C_Y0XF_TECHNICAL_TYPE,
      A type Y0XF_TECHNICAL_TYPE value 'A', "Authorization Exceptions
      B type Y0XF_TECHNICAL_TYPE value 'B', "Input (Basic)
      C type Y0XF_TECHNICAL_TYPE value 'C', "Calculated (Formula)
      H type Y0XF_TECHNICAL_TYPE value 'H', "Hierarchy Node (automatically created)
      R type Y0XF_TECHNICAL_TYPE value 'R', "Restricted (Auxiliary Measures, manually created)
    end of   C_Y0XF_TECHNICAL_TYPE .
  constants:
    begin of C_PARAM_SERVTP,
      NAME                         type RSPLF_PARNM value 'P_SERVTP',
      begin of VALUE,
        NO_OPERATION               type STRING value 'NO_OPERATION',
        LOG_ENTRY                  type STRING value 'LOG_ENTRY',
        SAVE_DATA                  type STRING value 'SAVE_DATA',
        SAVE_DATA_ON_INVALID       type STRING value 'SAVE_DATA_ON_INVALID',
        SET_STATUS_NO_AUTH         type STRING value 'SET_STATUS_NO_AUTH',
        SET_STATUS_VALID_FILE      type STRING value 'SET_STATUS_VALIDFILE',
        COPY_TO_CDM                type STRING value 'COPY_TO_CDM',          "Step (1)
        DELETE_FROM_UPL            type STRING value 'DELETE_FROM_UPL',      "Step (2)
        CANCEL                     type STRING value 'CANCEL',               "Step (1)
        CANCEL_STEP2               type STRING value 'CANCEL_STEP2',         "Step (2)
        SUBMIT                     type STRING value 'SUBMIT',
        UPDATE_STATUS              type STRING value 'UPDATE_STATUS',
        DELETE                     type STRING value 'DELETE',               "Step (1)
        DELETE_STEP2               type STRING value 'DELETE_STEP2',         "Step (2)
        TRIGGER_PCST               type STRING value 'TRIGGER_PCST',
      end of VALUE,
      begin of FUNCT,
        NO_OPERATION               type STRING value 'EXEC_NO_OPERATION',
        LOG_ENTRY                  type STRING value 'EXEC_LOG_ENTRY',
        SAVE_DATA                  type STRING value 'EXEC_SAVE_DATA',
        SAVE_DATA_ON_INVALID       type STRING value 'EXEC_SAVE_DATA_ON_INVALID_FILE',
        SET_STATUS_NO_AUTH         type STRING value 'EXEC_SET_STATUS_NO_AUTH',
        SET_STATUS_VALID_FILE      type STRING value 'EXEC_SET_STATUS_VALID_FILE',
        COPY_TO_CDM                type STRING value 'EXEC_COPY_TO_CDM',
        DELETE_FROM_UPL            type STRING value 'EXEC_DELETE_FROM_UPL',
        CANCEL                     type STRING value 'EXEC_CANCEL_STEP1',
        CANCEL_STEP2               type STRING value 'EXEC_CANCEL_STEP2',
        SUBMIT                     type STRING value 'EXEC_SUBMIT',
        UPDATE_STATUS              type STRING value 'EXEC_UPDATE_STATUS',
        DELETE                     type STRING value 'EXEC_DELETE_STEP1',    "Step (1)
        DELETE_STEP2               type STRING value 'EXEC_DELETE_STEP2',    "Step (2)
        TRIGGER_PCST               type STRING value 'EXEC_TRIGGER_PCST',    "Step (2)
      end of FUNCT,
    end of C_PARAM_SERVTP .
  constants:
    begin of C_PARAM_BATCH,
      NAME_DATA_CLUSTER            type RSPLF_PARNM value 'P_DATA_CLUSTER',
      NAME_BATCH_STATUS            type RSPLF_PARNM value 'P_BATCH_STATUS',
    end of C_PARAM_BATCH .
  constants:
    begin of C_ZXF_DSF,
      FILEUPLOAD type string value 'FILEUPLOAD',
      MANVALCORR type string value 'MANVALCORR',
    end of C_ZXF_DSF .
  constants:
    begin of C_UPDATE_MODE,
      SUBMIT type I value 1,
      DELETE type I value 2,
    end of   C_UPDATE_MODE .
  constants:
    begin of C_XUDCPFM,
      GER  type XUDCPFM value ' ',     "1.234.567,89
      US   type XUDCPFM value 'X',     "1,234,567.89
      GER2 type XUDCPFM value 'Y',     "1 234 567,89
    end   of C_XUDCPFM .
  class-data STH_HEAD type T_TH_HEAD .
  class-data STH_VALID_HEADER_FIELDS type T_TH_VALID_HEADER_FIELDS .
  class-data STH_MEAS_ID type Y0BW_XF_MEAS_ID_TH .
  class-data ST_MEAS_SET type Y0BW_XF_MEAS_SET_T .
  class-data STH_MEAS_DIS type Y0BW_XF_MEAS_DIS_TH .
  class-data STH_MEAS_CLUSTER type Y0XFU_T_TH_MEAS_CLUSTER .
  class-data ST_CDM_UPLOAD_CUBES type Y0XFU_T_T_MEAS_CLUSTER .
  class-data STH_AUTH_REL_CHAS type T_TH_AUTH_REL_CHAS .
  class-data STH_AUTH_REL_FILTERS type T_TH_AUTH_REL_FILTERS .
  class-data SS_USER_DEFAULTS type BAPIDEFAUL .
  class-data STH_MPCT_CURR type T_TH_MPCT_CURR .
  class-data:
    STH_CURX      type hashed table of TCURX
                                              with unique key CURRKEY .
  class-data _SS_FILEID type T_S_FILEID .
  class-data _SS_FILEID_REL type T_S_FILEID .
  data M_SERVTP type /BIC/OIZXFSERVTP .
  data M_R_UPLOAD type ref to ZCL_RSPLF_FILE_UPLOAD .
  data M_N_CHECK_DUPLICATES type CHAR1 .
  data MT_DATA_CHARSEL type RSPLF_T_CHARSEL .
  data MS_FILEID type T_S_FILEID .
  data MS_FILEID_REL type T_S_FILEID .
  data MSTR_FILE_TYPE_KF type STRING .
  data MN_RECNO type I .
  data MN_TOT type I .
  data MN_MSG type I .
  data MN_ERR type I .
  data MN_WAR type I .
  data MN_INF type I .
  data MN_MSG_RECNO type /BIC/OIZXF_RECNO .
  data MN_MSG_LINNO type /BIC/OIZXF_LINNO .
  data MN_MSG_LINNO_LAST_REC_0 type /BIC/OIZXF_LINNO .
  data MSTR_MSG type STRING .
  data MC_C240 type TEXT240 .
  data MB_MSG_RECERR type BOOLEAN .
  data MT_REC_MSG type T_T_REC_MSG .
  data MS_REC_MSG type T_S_REC_MSG .
  data MT_MAP_TO_CUBESTRUCT type T_T_MAP_TO_CUBESTRUCT .
  data MTH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM .
  data MTH_HEAD_TO_DIM_KYFS type T_TH_HEAD_TO_DIM .
  data MTH_MEASURE_ID type T_TH_MEASURE_ID .
  data MTH_MEID_DIM type T_TH_MEID_DIM .
  data MTS_MEID_FIS type Y0BW_XF_MEAS_FIS_TS .
  data MT_TREATMENT_CHAS type T_T_TREATMENT_CHAS .
  data MT_TREATMENT_KYFS type T_T_TREATMENT_KYFS .
  data MOREF_MD_VALIDATION type ref to Y0BW_CL_XF_UP_MD_VALIDATION .
  data MOREF_VLD_RULES type ref to Y0BW_CL_XF_VLD_GENERIC .
  data MN_TRANS_FILE_REC_ERR type I .

  methods _CONVERT_AMOUNT
    importing
      !I_S_TREATMENT_KYFS type T_S_TREATMENT_KYFS
      !I_KYF_NAME type /BI0/OITCTIOBJNM
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_SUBRC type SYSUBRC
    changing
      !C_S_DATA type ANY .
  methods EXEC_SAVE_DATA
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_LOG_ENTRY
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_NO_OPERATION
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods _CHECK_DUPLICATES_CREATE_DATA
    importing
      !I_T_IOBJNM type RSD_T_IOBJNM
    exporting
      !E_REF_WA_AGGR type ref to DATA
      !E_REF_T_AGGR type ref to DATA
      !E_REF_WA_DUPL_CHAS type ref to DATA
      !E_REF_T_DUPL_CHAS type ref to DATA
    exceptions
      INVALID_FIELD
      NO_FIELDS .
  methods _GET_FROM_REC_ZXF_MEAS
    importing
      !I_S_REC type ANY
      value(I_RECNO) type I default 0
      value(I_B_CDM) type BOOLEAN default 'X'
      value(I_VALID_MD) type BOOLEAN default 'X'
      value(I_LOG_MSG) type BOOLEAN default 'X'
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      !E_ZXF_MEAS type /BIC/OIZXF_MEAS
      !E_S_MEAS_ID type Y0BW_XF_MEAS_ID
      !E_SUBRC type SYSUBRC .
  methods _GET_FROM_REC_PHYS_KEY_FIGURE
    importing
      !I_S_REC type ANY
      value(I_RECNO) type I default 0
      !I_B_CDM type BOOLEAN
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      !E_PHYS_KEY_FIGURE type Y0XF_PHYS_KEY_FIGURE
      !E_SUBRC type SYSUBRC .
  methods CREATE_STATUS_RECORD
    importing
      !I_R_UPLOAD type ref to ZCL_RSPLF_FILE_UPLOAD
      !I_R_MSG type ref to IF_RSPLFA_MSG
      value(I_ZXF_STAT) type /BIC/OIZXF_STAT
    exporting
      !E_SUBRC type SYSUBRC
    changing
      !C_S_STATUS type ANY .
  class-methods _DCPFM
    importing
      !I_KYF type ANY
    exporting
      !E_KYF type ANY .
  methods STATUS_SET_FROM_FILEID
    importing
      !I_S_FILEID type T_S_FILEID
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_S_STATUS type ANY
      value(E_SUBRC) type SYSUBRC .
  methods STATUS_GET_INTO_FILEID
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
      !I_S_STATUS type ANY
    exporting
      !E_S_FILEID type T_S_FILEID
      value(E_SUBRC) type SYSUBRC .
  methods BUILD_AUTH_REL_CHAS
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
      !I_T_CDM_UPLOAD_CUBES type Y0XFU_T_T_MEAS_CLUSTER
    exporting
      !E_T_AUTH_REL_CHAS type T_T_AUTH_REL_CHAS
      value(E_SUBRC) type SYSUBRC .
  methods BUILD_COLUMN_TREATMENT_KYFS
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
      !I_T_CDM_UPLOAD_CUBES type Y0XFU_T_T_MEAS_CLUSTER
    exporting
      !E_T_TREATMENT_KYFS type T_T_TREATMENT_KYFS
      value(E_SUBRC) type SYSUBRC .
  methods BUILD_COLUMN_TREATMENT_CHAS
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_T_TREATMENT_CHAS type T_T_TREATMENT_CHAS
      value(E_SUBRC) type SYSUBRC
    changing
      !C_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM .
  methods BUILD_COLUMN_TREATMENT
    importing
      value(I_CONV_FIELDS) type ABAP_BOOL
      value(I_CONV_AMOUNTS) type ABAP_BOOL
      !I_T_CDM_UPLOAD_CUBES type Y0XFU_T_T_MEAS_CLUSTER
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_T_TREATMENT_CHAS type T_T_TREATMENT_CHAS
      !E_T_TREATMENT_KYFS type T_T_TREATMENT_KYFS
      value(E_SUBRC) type SYSUBRC
    changing
      !C_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM .
  methods CREATE_DATA_BY_TYPE
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      value(E_SUBRC) type SYSUBRC
    changing
      !C_S_TREATMENT_CHAS type T_S_TREATMENT_CHAS .
  methods ADD_RECORD_MESSAGES
    importing
      !I_S_FILEID type ANY
      !I_T_REC_MSG type T_T_REC_MSG
    changing
      !C_T_RECMSG type STANDARD TABLE .
  methods APPLY_CONVERSIONS_CHAS_KYFS
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
      !I_T_TREATMENT_CHAS type T_T_TREATMENT_CHAS
      !I_T_TREATMENT_KYFS type T_T_TREATMENT_KYFS
    exporting
      value(E_SUBRC) type SYSUBRC
    changing
      !C_T_DATA type STANDARD TABLE .
  methods VALIDATE_UPLOAD_DATA
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      value(E_NRECERR) type I
      value(E_ZXF_STAT) type /BIC/OIZXF_STAT
    changing
      value(I_S_STATUS) type ANY
      !C_T_REC_MSG type T_T_REC_MSG
      !C_T_DATA type STANDARD TABLE .
  methods CHECK_DUPLICATES_HASH
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_R_UPLOAD type ref to ZCL_RSPLF_FILE_UPLOAD
      value(I_S_STATUS) type ANY
    exporting
      value(E_NRECERR) type I
      value(E_ZXF_STAT) type /BIC/OIZXF_STAT
    changing
      !C_T_REC_MSG type T_T_REC_MSG
      !C_T_DATA type STANDARD TABLE .
  methods CHECK_DUPLICATES
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_R_UPLOAD type ref to ZCL_RSPLF_FILE_UPLOAD
      value(I_S_STATUS) type ANY
    exporting
      value(E_NRECERR) type I
      value(E_ZXF_STAT) type /BIC/OIZXF_STAT
    changing
      !C_T_REC_MSG type T_T_REC_MSG
      !C_T_DATA type STANDARD TABLE .
  methods VALIDATION_STEP3_CONTENT
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
    exporting
      !E_NRECERR type I
    changing
      !C_T_DATA type STANDARD TABLE
      !C_T_REC_MSG type T_T_REC_MSG .
  methods SAVE_AUTH_REL_FILTERS
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
      !I_TH_AUTH_REL_CHAS type T_TH_AUTH_REL_CHAS
      !I_S_FILEID type T_S_FILEID
      !I_T_DATA type STANDARD TABLE
    changing
      !C_T_REC_MSG type T_T_REC_MSG .
  methods CREATE_CDM_DATA_FOR_VALIDATION
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
      !I_T_DATA type STANDARD TABLE
    changing
      !C_T_CDM_CHAS type STANDARD TABLE .
  methods VALIDATION_STEP2_MASTER_DATA
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
    exporting
      !E_NRECERR type I
    changing
      !C_T_CDM_CHAS type STANDARD TABLE
      !C_T_DATA type STANDARD TABLE
      !C_T_REC_MSG type T_T_REC_MSG .
  methods VALIDATION_STEP5_CONV_CMD
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      !E_NRECERR type I
    changing
      !I_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
      !C_T_CDM_CHAS type STANDARD TABLE
      !C_T_DATA type STANDARD TABLE
      !C_T_REC_MSG type T_T_REC_MSG
      !C_S_STATUS type ANY .
  methods VALIDATION_STEP4_CHECK_RULES
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      !E_NRECERR type I
    changing
      !I_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
      !C_T_CDM_CHAS type STANDARD TABLE
      !C_T_DATA type STANDARD TABLE
      !C_T_REC_MSG type T_T_REC_MSG
      !C_S_STATUS type ANY .
  methods FILL_MEAS_CLUSTER
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_T_MEAS_SET type Y0BW_XF_MEAS_SET_T
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_T_MEAS_CLUSTER type Y0XFU_T_TH_MEAS_CLUSTER .
  methods FILL_FILTER_MEAS_FIS
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_TH_MEASURE_ID type T_TH_MEASURE_ID
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_TS_MEID_FIS type Y0BW_XF_MEAS_FIS_TS .
  methods FILL_BREAKDOWN_MEAS_DIS
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_T_MEAS_SET type Y0BW_XF_MEAS_SET_T
      !E_TH_MEAS_DIS type Y0BW_XF_MEAS_DIS_TH .
  class-methods FILL_HEAD__VALID_HEADER_FIELDS
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_TH_HEAD type T_TH_HEAD
      !E_TH_VALID_HEADER_FIELDS type T_TH_VALID_HEADER_FIELDS .
  methods COPY_FIELD_FROM_SRC_TO_DST
    importing
      !I_FLDNM_SRC type ANY
      !I_FLDNM_DST type ANY
      !I_S_SOURCE type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      !E_R_FLD_SRC type ref to DATA
      !E_R_FLD_DST type ref to DATA
      !E_S_TARGET type ANY
      value(E_SUBRC) type SYSUBRC .
  methods INIT_MAP_TO_CUBESTRUCT
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_T_MAP_TO_CUBESTRUCT type T_T_MAP_TO_CUBESTRUCT .
  methods RESTRUCTRE_RECORD
    importing
      !LS_DATA_SRC type ANY
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !LS_DATA_DST type ANY .
  methods VALIDATION_STEP1_HEADER
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_STR_FILE_TYPE_KF type STRING .
  methods VALIDATE_RECORD_CONTENT
    importing
      value(I_REC_NO) type I
      !I_S_RECORD type ANY
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_ERRONEOUS type BOOLEAN .
  methods VALIDATE_RECORD_CONTENT_BRKDWN
    importing
      value(I_REC_NO) type I
      !I_S_RECORD type ANY
      !I_R_MSG type ref to IF_RSPLFA_MSG .
  methods VALIDATE_RECORD_CONTENT_FILTER
    importing
      value(I_REC_NO) type I
      !I_S_RECORD type ANY
      !I_R_MSG type ref to IF_RSPLFA_MSG .
  methods VALIDATE_RECORD_CONTENT_UNITS
    importing
      value(I_REC_NO) type I
      !I_S_RECORD type ANY
      !I_R_MSG type ref to IF_RSPLFA_MSG .
  methods BUILD_BREAKDOWN_MEID_DIM
    importing
      value(I_S_FILE) type ANY
      !I_T_DATA type STANDARD TABLE
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_TH_MEASURE_ID type T_TH_MEASURE_ID
      !E_TH_MEAS_DIM type T_TH_MEID_DIM .
  methods BUILD_MAP_TO_CUBESTRUCT
    importing
      !I_R_MSG type ref to IF_RSPLFA_MSG
    changing
      !LS_FILE type ANY .
  methods BUILD_TRANSLATION_HEAD_TO_DIM
    importing
      !I_S_STATUS type ANY
      !I_R_MSG type ref to IF_RSPLFA_MSG
    exporting
      !E_SUBRC type SYSUBRC
      !E_TH_HEAD_TO_DIM_CHAS type T_TH_HEAD_TO_DIM
      !E_TH_HEAD_TO_DIM_KYFS type T_TH_HEAD_TO_DIM .
  methods EXEC_DELETE_STEP1
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_DELETE_STEP2
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods _EXEC_DELETE_BAK
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods UPDATE_STATUS_ANALYSE_RECORDS
    importing
      !I_T_STATUS type STANDARD TABLE
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_S_BLOCK_LINE type ANY
    exporting
      !E_UPDATE_MODE type I
      !E_R_STATUS type ref to DATA
      !E_R_STATUS_REL type ref to DATA
      !E_S_FILEID type T_S_FILEID
      !E_S_FILEID_REL type T_S_FILEID
      !E_SUBRC type SYSUBRC .
  methods EXEC_UPDATE_STATUS
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_COPY_TO_CDM
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_SUBMIT
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods SET_STATUS
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      value(I_STATUS_NEW) type /BIC/OIZXF_STAT
      value(I_STATUS_PRED) type /BIC/OIZXF_STAT optional
      value(I_B_CHECK_PRED) type BOOLEAN optional
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_SET_STATUS_VALID_FILE
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_SET_STATUS_NO_AUTH
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_SAVE_DATA_ON_INVALID_FILE
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_TRIGGER_PCST
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_DELETE_FROM_UPL
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_CANCEL_STEP2
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods EXEC_CANCEL_STEP1
    importing
      value(I_R_PARAM_SET) type ref to IF_RSPLFA_PARAM_SET
      value(I_S_BLOCK_LINE) type ANY
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    changing
      !C_TH_DATA type HASHED TABLE .
  methods COPY_TO_CDM_UPLOAD_CUBE
    importing
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
      !I_T_SOURCE type STANDARD TABLE
    exporting
      value(E_SUBRC) type SYSUBRC
      !E_T_TARGET type STANDARD TABLE .
  methods SEPARATE_SOURCE_TARGET_RECORDS
    importing
      !I_TH_DATA type HASHED TABLE
      value(I_R_MSG) type ref to IF_RSPLFA_MSG
    exporting
      !E_T_STATUS type STANDARD TABLE
      !E_T_SOURCE type STANDARD TABLE
      !E_T_TARGET type STANDARD TABLE
      !E_T_RECMSG type STANDARD TABLE
      !E_T_OTHERS type STANDARD TABLE
      !E_SUBRC type SYSUBRC .
ENDCLASS.



CLASS Y0BW_CL_XF_UP_GEN_FILE_UPLOAD IMPLEMENTATION.


method ADD_RECORD_MESSAGES.

  FIELD-SYMBOLS:
    <lwa_data>    type ANY,     "WORK AREA, for C_TH_DATA not a pointer !!
    <lf_src>      type ANY,
    <lf_dst>      type ANY,
    <ls_rec_msg>  type T_S_REC_MSG.

  DATA:
    ls_fileid type T_S_FILEID,
    lr_data   type REF TO DATA.   "dynamic data creation

* "Initialization"
  ls_fileid   = I_S_FILEID.

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lr_data like line of C_T_RECMSG.
  assign lr_data->* to <lwa_data>.

  clear <lwa_data>.

* ----------------------------------------------------------------------------
* - ( 1 ) Add the cube, File ID and Keyfigure to the Record - Messages
* ----------------------------------------------------------------------------
* Set the Target Infoprovider (RB Upload Framework - Status Administration)
  assign component '0INFOPROV'  of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = C_CUBE-MESSAGES.     unassign <lf_dst>. endif.
  assign component 'ZXF_UFID'   of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = ls_fileid-ZXF_UFID.  unassign <lf_dst>. endif.
  assign component '0TCTNUMREC' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = '1'.                 unassign <lf_dst>. endif.

* ----------------------------------------------------------------------------
* - ( 2 ) loop at the messages
* ----------------------------------------------------------------------------
  FIELD-SYMBOLS: <1stmsg>    type T_S_REC_MSG.
  DATA:          lt_rec_msg  type T_T_REC_MSG.

  loop at I_T_REC_MSG assigning <ls_rec_msg>.

    assign component 'ZXF_RECNO' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_RECNO. unassign <lf_dst>. endif.
    assign component 'ZXF_LINNO' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_LINNO. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGID' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGID. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGTY' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGTY. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGNO' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGNO. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGV1' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGV1. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGV2' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGV2. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGV3' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGV3. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGV4' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGV4. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGT1' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGT1. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGT2' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGT2. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGT3' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGT3. unassign <lf_dst>. endif.
    assign component 'ZXF_MSGT4' of structure <lwa_data> to <lf_dst>. if <lf_dst> is assigned. <lf_dst> = <ls_rec_msg>-ZXF_MSGT4. unassign <lf_dst>. endif.

*   check for duplicate messages in "Record Number" and "Line Number".
    read table lt_rec_msg
      assigning <1stmsg>
      with key ZXF_RECNO = <ls_rec_msg>-ZXF_RECNO
               ZXF_LINNO = <ls_rec_msg>-ZXF_LINNO.
    if sy-subrc = 0.
      break ATX-MHAHN.
      CONTINUE.   "skip message
    else.
      append <ls_rec_msg> to lt_rec_msg.
    endif.
    append <lwa_data> to C_T_RECMSG.
  endloop.

  free: <lwa_data>.

endmethod. "ADD_RECORD_MESSAGES


method APPLY_CONVERSIONS_CHAS_KYFS.
* ----------------------------------------------------------------------------
* - Apply CHAVL function and ToUpper, if appropriate
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <lf_field>            type ANY,
    <lf_chavl_int>        type ANY,
    <ls_data>             type ANY,             "the source record as a pointer into a table, not a work area
    <ls_treatment_chas>   type T_S_TREATMENT_CHAS,
    <ls_treatment_kyfs>   type T_S_TREATMENT_KYFS,
    <ls_head_to_dim>      type T_S_HEAD_TO_DIM.

  DATA:
    l_subrc          type SYSUBRC,
    l_chavl_ext      TYPE RSCHAVLEXT,
    l_chavl_int      TYPE RSCHAVL.

* ============================================================================
* = Loop at the file and apply the conversions
* ============================================================================
  if not I_T_TREATMENT_CHAS is initial and
     not I_T_TREATMENT_KYFS is initial.

    loop at C_T_DATA assigning <ls_data>.

*     ------------------------------------------------------------------------
*     - CONVERSION: CHARACTERISTICS
*     ------------------------------------------------------------------------
      loop at I_T_TREATMENT_CHAS assigning <ls_treatment_chas>.

*       assign component <ls_treatment_chas>-n_ColIdx
        assign component <ls_treatment_chas>-CHARACTERISTIC
            of structure <ls_data> to <lf_field>.
        if sy-subrc = 0.

*         Perfom the "chavl" and/or "to upper"
          if <ls_treatment_chas>-b_chavl = abap_true.

            call method Y0BI_UTILITIES=>CHECK_CHAVL

              exporting TO_UPPER     = <ls_treatment_chas>-b_toupper
                        REMOVE_SPACE = RS_C_TRUE
              changing  CHAVL        = <lf_field>.

          endif.

*         Apply the conversion exit
          if <ls_treatment_chas>-b_convexit = rs_c_true.

            clear l_chavl_int.
            l_chavl_ext = <lf_field>.
            if not l_chavl_ext is initial.                           "otherwiese: SPACE -> '#' ! "2012-01-20 (mh)

              CALL FUNCTION 'RRSV_EX_IN_CONVERT'
                EXPORTING
                  i_chavl_ext              = l_chavl_ext
                  i_convx                  = <ls_treatment_chas>-CONVEXIT
                  i_inttp                  = <ls_treatment_chas>-INTTP
                  i_intlen                 = <ls_treatment_chas>-INTLEN
                  i_outputlen              = <ls_treatment_chas>-OUTPUTLEN
                  i_iobjnm                 = <ls_treatment_chas>-IOBJNM
                IMPORTING
                  e_chavl_int              = l_chavl_int.

              <lf_field> = l_chavl_int.

            endif.
            clear: l_chavl_ext, l_chavl_int.
          endif.

*         Apply type conversion for numeric datatypes including time characteristics   "e.g. 0CALMONTH2: "1" -> "01"
          if <ls_treatment_chas>-b_typeconv = rs_c_true.

            assign <ls_treatment_chas>-REF_VAL_INT->* to <lf_chavl_int>.
            clear <lf_chavl_int>.
            <lf_chavl_int> = <lf_field>.

            clear <lf_field>.
            <lf_field> = <lf_chavl_int>.
            clear <lf_chavl_int>.
            unassign <lf_chavl_int>.

          endif.

        endif. "assign component <ls_treatment_chas>-IOBJNM

      endloop. "I_T_TREATMENT_CHAS
      if <ls_treatment_chas> is assigned. unassign <ls_treatment_chas>. endif.

*     ------------------------------------------------------------------------
*     - CONVERSION: KEYFIGURES
*     ------------------------------------------------------------------------
      DATA: l_Phys_Keyfigure type Y0XF_PHYS_KEY_FIGURE.
      clear l_subrc.
      CALL METHOD me->_GET_FROM_REC_PHYS_KEY_FIGURE
        EXPORTING
          I_S_REC           = <ls_data>     "ZXF_MEAID
          I_B_CDM           = rs_c_false    "Still: Upload Cube
*         I_RECNO           = 0
          I_R_MSG           = I_R_MSG
        IMPORTING
          E_PHYS_KEY_FIGURE = l_Phys_Keyfigure
          E_SUBRC           = l_subrc.

      if l_subrc = 0.

*       Check, if physical keyfigure (=> ZXF_MEAS) is scheduled for treatment
        read table I_T_TREATMENT_KYFS
          assigning <ls_treatment_kyfs>

          with key PHYS_KEY_FIGURE = l_Phys_Keyfigure.

        if sy-subrc = 0.

          if <ls_treatment_kyfs>-b_convamount = rs_c_true.

            loop at MTH_HEAD_TO_DIM_KYFS assigning <ls_head_to_dim>.

*             Apply amount conversion according to TCURX
              if <ls_treatment_kyfs>-IOBJTP = rsd_c_objtp-keyfigure and      "The Infoobject is a KEYFIGURE            KYF
                 <ls_treatment_kyfs>-KYFTP  = rsd_c_kyftp-amount    and      "The keyfigures represents an Amount      AMO
                 <ls_treatment_kyfs>-DATATP = rsd_c_datatp-amount.           "The datatype of an amount is "currency"  CURR

                clear l_subrc.
                call method _CONVERT_AMOUNT

                    exporting I_S_TREATMENT_KYFS = <ls_treatment_kyfs>
                              I_KYF_NAME         = <ls_head_to_dim>-FIELDNM_SRC
                              I_R_MSG            = I_R_MSG
                    importing E_SUBRC            = l_subrc
                    changing  C_S_DATA           = <ls_data>.
              endif.
            endloop. "MTH_HEAD_TO_DIM_KYFS
          endif. "<ls_treatment_kyfs>-b_convamount = rs_c_true.
        endif. "read table I_T_TREATMENT_KYFS
        if <ls_treatment_kyfs> is assigned. unassign <ls_treatment_kyfs>. endif.

      endif. "CALL METHOD me->_GET_FROM_REC_PHYS_KEY_FIGURE

    endloop. "C_T_DATA
    if <ls_data> is assigned. unassign <ls_data>. endif.

  endif. "not I_T_TREATMENT_CHAS is initial
         "not I_T_TREATMENT_KYFS is initial

endmethod. "APPLY_CONVERSIONS_CHAS_KYFS


method BUILD_AUTH_REL_CHAS.
* ----------------------------------------------------------------------------
* - Analyze the CDM upload Cube(s) and search for authorization relevant
* - characteristics.
* ----------------------------------------------------------------------------

FIELD-SYMBOLS:
  <ls_cdm_upload_cubes>  type Y0XFU_T_S_MEAS_CLUSTER.

DATA:
  ls_viobj     type RSD_S_VIOBJ,
  ls_iobj      type RSD_S_IOBJ,
  ls_cob_pro   type RSD_S_COB_PRO,

  ls_auth_rel_chas type T_S_AUTH_REL_CHAS,
  lt_auth_rel_chas type T_T_AUTH_REL_CHAS.


  E_SUBRC = 8.

  free: E_T_AUTH_REL_CHAS,
        lt_auth_rel_chas.

* ----------------------------------------------------------------------------
* - Collect authorization relevant characteristics
* ----------------------------------------------------------------------------
  FIELD-SYMBOLS: <ls_cube_iobj>  type RSD_S_CUBE_IOBJ.
  DATA:           lt_cube_iobj   type RSD_T_CUBE_IOBJ.

  loop at I_T_CDM_UPLOAD_CUBES assigning <ls_cdm_upload_cubes>.

    free: lt_cube_iobj.
    CALL FUNCTION 'RSD_CUBE_GET'
      EXPORTING
        I_INFOCUBE               = <ls_cdm_upload_cubes>-SOURCE
        I_OBJVERS                = RS_C_OBJVERS-ACTIVE
*       I_BYPASS_BUFFER          = RS_C_FALSE
*       I_WITH_ATR_NAV           = RS_C_FALSE
      IMPORTING
        E_T_CUBE_IOBJ            = lt_cube_iobj
      EXCEPTIONS
        INFOCUBE_NOT_FOUND       = 1
        ILLEGAL_INPUT            = 2
        OTHERS                   = 3.

    loop at lt_cube_iobj assigning <ls_cube_iobj>
      where IOBJTP = rsd_c_objtp-charact.

*     ----------------------------------------------------------------------------
*     - Get characteristic property "authorization relevant"
*     ----------------------------------------------------------------------------
      CALL FUNCTION 'RSD_IOBJ_GET'                            "was bin ich fuer einer ?
        EXPORTING
           I_IOBJNM               = <ls_cube_iobj>-IOBJNM
           I_OBJVERS              = RS_C_OBJVERS-ACTIVE
           I_BYPASS_BUFFER        = RS_C_FALSE
           I_IGNORE_BCTCOMP       = RS_C_FALSE
           I_WITH_DTEL            = RS_C_TRUE
        IMPORTING
           E_S_VIOBJ              = ls_viobj          "View of all properties of an InfoObject
           E_S_IOBJ               = ls_iobj           "View of InfoObjects and texts
           E_S_COB_PRO            = ls_cob_pro        "InfoObject Properties (in Context of InfoCube / ODS Object)
        EXCEPTIONS
          IOBJ_NOT_FOUND         = 1
          ILLEGAL_INPUT          = 2
          BCT_COMP_INVALID       = 3
          OTHERS                 = 4.

      if sy-subrc <> 0.
*       msg
        RETURN.
      endif.

      if ls_viobj-AUTHRELFL = rs_c_true.

        clear ls_auth_rel_chas.
        ls_auth_rel_chas-IOBJNM    = ls_viobj-IOBJNM.
        ls_auth_rel_chas-AUTHRELFL = ls_viobj-AUTHRELFL.
        collect ls_auth_rel_chas into lt_auth_rel_chas.
        clear ls_auth_rel_chas.

      endif.
    endloop. "at lt_cube_iobj
  endloop. "at I_T_CDM_UPLOAD_CUBES

  if <ls_cube_iobj>        is assigned. unassign <ls_cube_iobj>.        endif.
  if <ls_cdm_upload_cubes> is assigned. unassign <ls_cdm_upload_cubes>. endif.
  free: lt_cube_iobj.


  E_T_AUTH_REL_CHAS[] = lt_auth_rel_chas[].
  free: lt_auth_rel_chas.

  clear E_SUBRC.

endmethod. "BUILD_AUTH_REL_CHAS


method BUILD_BREAKDOWN_MEID_DIM.
**** ----------------------------------------------------------------------------
**** - For each Dimension supplied by the loadfile,
**** - enhance the "Dimension" by
**** -
**** -  the Fieldname of it's field in the source record
**** -  the Header, which is assigned to this characteristic (CAPITALIZED)
**** -  the Headername including lowecase letters
**** -
**** ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <ls_data>         type ANY,
    <ls_MEASURE_ID>   type T_S_MEASURE_ID,
    <ls_MEAS_DIS>     type Y0BW_XF_MEAS_DIS,
    <ls_meas_cluster> type Y0XFU_T_S_MEAS_CLUSTER,
    <ls_head_to_dim>  type T_S_HEAD_TO_DIM.

  DATA:
    l_subrc           type SYSUBRC,
    l_ZXF_MEAS        type /BIC/OIZXF_MEAS,
*   ls_meas_id        type Y0BW_XF_MEAS_ID.
    ls_MEASURE_ID     type T_S_MEASURE_ID,
    lt_MEASURE_ID     type T_T_MEASURE_ID,

    ls_MEID_DIM       type                   T_S_MEID_DIM,
    lt_MEID_DIM       type standard table of T_S_MEID_DIM.

  free:
    E_TH_MEASURE_ID[],
    E_TH_MEAS_DIM[].

  E_SUBRC = 8.


* ----------------------------------------------------------------------------
* - Loop at the file and build a list of Measure Id's ..
* ----------------------------------------------------------------------------
  free lt_MEASURE_ID.
  loop at I_T_DATA assigning <ls_data>.

*   Look up the Measure Id in the record
    clear: l_subrc, l_ZXF_MEAS.
    call method _GET_FROM_REC_ZXF_MEAS

        exporting I_S_REC     = <ls_data>
                  I_B_CDM     = rs_c_false      " 'X'=CDM Upload Cube Structure, ' ' = Upload Cube Structure
                  I_R_MSG     = I_R_MSG
                  I_VALID_MD  = rs_c_false      "just get the ZXF_MEASID
                  I_LOG_MSG   = rs_c_false
        importing E_ZXF_MEAS  = l_ZXF_MEAS
*                 E_S_MEAS_ID = ls_meas_id
                  E_SUBRC     = l_subrc.

    if l_subrc <> 0.
      RETURN.
    endif.

    if not l_ZXF_MEAS is initial.
      clear ls_MEASURE_ID.
      ls_MEASURE_ID-MEASID = l_ZXF_MEAS.
      collect ls_MEASURE_ID into lt_MEASURE_ID.
    endif.
    clear: l_ZXF_MEAS, ls_MEASURE_ID.

  endloop. "I_T_DATA
  if <ls_data> is assigned. unassign <ls_data>. endif.

* ----------------------------------------------------------------------------
* - .. and assign the Target depending on CUM/NCUM
* ----------------------------------------------------------------------------
* MEASID      TECHNICAL_TYPE   PHYS_KEY_FIGURE BASE_MEASURE
* SASG000042  B                ZXF_NUMB	
* SASG000082  R                ZXF_NCNUM        SASG000042
* ----------------------------------------------------------------------------
* assign the data target cum/ncum to the measure id
  clear l_ZXF_MEAS.
  loop at lt_MEASURE_ID assigning <ls_MEASURE_ID>.

*   access the data cluster for the given measure id
    read table STH_MEAS_CLUSTER
      assigning <ls_meas_cluster>
      with key  MEASID = <ls_MEASURE_ID>-MEASID.
    if sy-subrc = 0.

*     check if the measure id is a base measure in any other measure id
      loop at STH_MEAS_ID transporting no fields
        where BASE_MEASURE = <ls_MEASURE_ID>-MEASID.

        EXIT. "exit loop
      endloop.

*     Non cumulative keyfigure:
*     Measure Id is BASE_MEASURE for at least one other measure id
      if sy-subrc = 0.

        <ls_MEASURE_ID>-ZXF_IPROV = <ls_meas_cluster>-TARGET_NCUM.  "update measure id with target cum/ncum

*     Cumulative keyfigure:
*     Measure Id is not a BASE_MEASURE
      else.
        <ls_MEASURE_ID>-ZXF_IPROV = <ls_meas_cluster>-TARGET.       "update measure id with target cum/ncum
      endif.
    endif.
  endloop.


* ----------------------------------------------------------------------------
* - Loop at the assignment MeasureId <--> Dimension, which was read from the
* - KPI database (large set !) into the STATIC variable and check, if
* - the assigned dimension is beeing used by the current loadfile. If so, then
* - create an entry in the load-file-specific ! break-down structure MEID_DIM.
* ----------------------------------------------------------------------------

* ----------------------------------------------------------------------------
* - Loop at the Measure Id's in the current file.
* - Get the breakdown dimensions (mandatory/optional) and
* - enhance the "Dimension" by
* -
* -  the Fieldname of it's field in the source record
* -  the Header, which is assigned to this characteristic (CAPITALIZED)
* -  the Headername including lowecase letters
* ----------------------------------------------------------------------------
  loop at lt_MEASURE_ID assigning <ls_MEASURE_ID>.

    loop at STH_MEAS_DIS assigning <ls_MEAS_DIS>
      where MEASID = <ls_MEASURE_ID>-MEASID.

      clear ls_MEID_DIM.

      ls_MEID_DIM-MEASID         = <ls_MEAS_DIS>-MEASID.            "KEY from STH_MEAS_DIS
      ls_MEID_DIM-DIMNM          = <ls_MEAS_DIS>-DIMNM.             "KEY from STH_MEAS_DIS
      ls_MEID_DIM-OPTIONAL       = <ls_MEAS_DIS>-OPTIONAL.          "ATTR

      read table MTH_HEAD_TO_DIM_CHAS
        assigning <ls_head_to_dim>
        with key DIMNM = <ls_MEAS_DIS>-DIMNM.

      if sy-subrc <> 0.
        .                           "This dimension is not beeing used by the
                                    "current loadfile (not in the header!).
                                    "If Mandatory -> Message !
      else.

        ls_MEID_DIM-FIELDNM_SRC    = <ls_head_to_dim>-FIELDNM_SRC.    "Enhancement from MTH_HEAD_TO_DIM_CHAS
        ls_MEID_DIM-COL_HEADER     = <ls_head_to_dim>-COL_HEADER.     "Enhancement from MTH_HEAD_TO_DIM_CHAS
        ls_MEID_DIM-COL_HEAD_LOW   = <ls_head_to_dim>-COL_HEAD_LOW.   "Enhancement from MTH_HEAD_TO_DIM_CHAS

      endif. "MTH_HEAD_TO_DIM_CHAS

      insert ls_MEID_DIM
        into table MTH_MEID_DIM.   " <<<<<

      clear ls_MEID_DIM.
    endloop. "STH_MEAS_DIS
  endloop. "lt_MEASURE_ID

  clear E_SUBRC.
  E_TH_MEASURE_ID[] = lt_MEASURE_ID[].
* E_TH_MEAS_DIM                           "has been filled properly

  free: lt_MEASURE_ID.

endmethod. "BUILD_BREAKDOWN_MEID_DIM


method BUILD_COLUMN_TREATMENT.

DATA:
  l_subrc           type SYSUBRC,
  lt_treatment_chas type T_T_TREATMENT_CHAS,
  lt_treatment_kyfs type T_T_TREATMENT_KYFS.

  E_SUBRC = 8.

  free: E_T_TREATMENT_CHAS,
        E_T_TREATMENT_CHAS.

* ----------------------------------------------------------------------------
* - Create treatment for CHARACTERISTICS
* ----------------------------------------------------------------------------
  if I_CONV_FIELDS = rs_c_true.

    clear lt_treatment_chas.
    call method BUILD_COLUMN_TREATMENT_CHAS

        exporting I_R_MSG               = I_R_MSG
        importing E_T_TREATMENT_CHAS    = lt_treatment_chas
                  E_SUBRC               = l_subrc
        changing  C_TH_HEAD_TO_DIM_CHAS = C_TH_HEAD_TO_DIM_CHAS.

    if l_subrc <> 0.
      RETURN.
    endif.

  endif.

* ----------------------------------------------------------------------------
* - Create treatment for the PHYSICAL KEYFIGURES
* ----------------------------------------------------------------------------
  if I_CONV_AMOUNTS = rs_c_true.

    clear lt_treatment_kyfs.
    call method BUILD_COLUMN_TREATMENT_KYFS

        exporting I_R_MSG               = I_R_MSG
                  I_T_CDM_UPLOAD_CUBES  = I_T_CDM_UPLOAD_CUBES
        importing E_T_TREATMENT_KYFS    = lt_treatment_kyfs
                  E_SUBRC               = l_subrc.

    if l_subrc <> 0.
      RETURN.
    endif.

  endif.

* Return column treatment for characteristics and keyfigures
  E_T_TREATMENT_CHAS[] = lt_treatment_chas[].
  E_T_TREATMENT_KYFS[] = lt_treatment_kyfs[].

  free: lt_treatment_chas,
        lt_treatment_kyfs.

  clear E_SUBRC.

endmethod. "BUILD_COLUMN_TREATMENT


method BUILD_COLUMN_TREATMENT_CHAS.
* ----------------------------------------------------------------------------
* - Analyze the Characteristics in the file.
* - Schedule for CHAVL / TOUPPER / CONVERSION EXIT.
* ----------------------------------------------------------------------------

FIELD-SYMBOLS:
  <lf_field>             type ANY,
  <ls_record>            type ANY,
  <ls_treatment_chas>    type T_S_TREATMENT_CHAS,
  <ls_head_to_dim>       type T_S_HEAD_TO_DIM.

DATA:
  l_subrc      type SYSUBRC,
  ls_viobj     type RSD_S_VIOBJ,
  ls_iobj      type RSD_S_IOBJ,
  ls_cob_pro   type RSD_S_COB_PRO,
  ls_aruot     type RSAA_S_AROUT,
  ls_arout_txt type RSAA_S_AROUTT,
  ls_aabap     type RSAA_T_AABAP,

  ln_ColIdx    type SYTABIX,            "the given characteristic has this column index
                                        "in the file structure

  ls_treatment_chas type T_S_TREATMENT_CHAS,
  lt_treatment_chas type T_T_TREATMENT_CHAS.

  E_SUBRC = 8.
  free: E_T_TREATMENT_CHAS.

* ============================================================================
* = ( I ) Loop at the characteristics and determine the data type.
* =       "Schedule" characteristics with a character like data
* =       type for treatment
* =         ( A ) Y0BI_UTILITIES=>CHECK_CHAVL treatment and/or
* =         ( B ) conversion to upper case, if suitable for the given
* =               characteristic,
* =         ( C ) conversion exit
* ============================================================================

clear ln_ColIdx.
  loop at C_TH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>.

    CALL FUNCTION 'RSD_IOBJ_GET'                            "was bin ich fuer einer ?
      EXPORTING
         I_IOBJNM               = <ls_head_to_dim>-DIMNM
         I_OBJVERS              = RS_C_OBJVERS-ACTIVE
         I_BYPASS_BUFFER        = RS_C_FALSE
         I_IGNORE_BCTCOMP       = RS_C_FALSE
         I_WITH_DTEL            = RS_C_TRUE
      IMPORTING
         E_S_VIOBJ              = ls_viobj          "View of all properties of an InfoObject
         E_S_IOBJ               = ls_iobj           "View of InfoObjects and texts
         E_S_COB_PRO            = ls_cob_pro        "InfoObject Properties (in Context of InfoCube / ODS Object)
         E_S_AROUT              = ls_aruot          "ABAP routine - check table   Table: RSAROUT
         E_S_AROUTT             = ls_arout_txt      "ABAP routine - text table    Table: RSAROUTT
         E_T_AABAP              = ls_aabap          "ABAP routine - source code   Table: RSAABAP
      EXCEPTIONS
        IOBJ_NOT_FOUND         = 1
        ILLEGAL_INPUT          = 2
        BCT_COMP_INVALID       = 3
        OTHERS                 = 4.

    if sy-subrc <> 0.
*     msg
      RETURN.
    endif.

    clear ls_treatment_chas.
    ls_treatment_chas-n_ColIdx        = <ls_head_to_dim>-n_ColIdx.        "Column Index in the file [01..40]
    ls_treatment_chas-CHARACTERISTIC  = <ls_head_to_dim>-FIELDNM_SRC.     ">>KEY:  ZXF_CHA01: Name of characteristic or keyfigure in the source record
    ls_treatment_chas-IOBJNM          = ls_cob_pro-IOBJNM.
    ls_treatment_chas-IOBJTP          = ls_cob_pro-IOBJTP.
    ls_treatment_chas-DATATP          = ls_cob_pro-DATATP.
    ls_treatment_chas-INTLEN          = ls_cob_pro-INTLEN.
    ls_treatment_chas-OUTPUTLEN       = ls_cob_pro-OUTPUTLEN.
    ls_treatment_chas-CONVEXIT        = ls_cob_pro-CONVEXIT.
    ls_treatment_chas-LOWERCASE       = ls_cob_pro-LOWERCASE.
    ls_treatment_chas-INTTP           = ls_cob_pro-INTTP.
    ls_treatment_chas-DECIMALS        = ls_cob_pro-DECIMALS.
    ls_treatment_chas-DIGITS          = ls_cob_pro-DIGITS.

*   ls_treatment_chas-REF_VAL_INT
*   Allocate space for the internal value
    call method CREATE_DATA_BY_TYPE exporting I_R_MSG             = I_R_MSG
                                    importing E_SUBRC             = l_subrc
                                    changing  C_S_TREATMENT_CHAS  = ls_treatment_chas.
    if l_subrc <> 0.
*     319: BUILD_COLUMN_TREATMENT: Create data failed !
      ADD_REC_MSG     'E' '319' ' ' '' '' ''.
      RETURN.
    endif.

*   --------------------------------------------------------------------------
*   - The Infoobject is a CHARACTERISTIC (CHA)
*   --------------------------------------------------------------------------
    if ls_viobj-IOBJTP = rsd_c_objtp-charact.

*     The data type is CHARACTER (CHAR)
      if  ls_viobj-DATATP = rsd_c_datatp-charact.      "CHAR

*       ( A ) CHAVL
        ls_treatment_chas-b_chavl   =  rs_c_true.          "Remove characters according to "CHAVL"

*       ( B ) TOUPPER
        if ls_viobj-LOWERCASE = rs_c_false.           "No lowercase letters allowed,
          ls_treatment_chas-b_toupper =  abap_true.        "=> perform 'to upper' conversion
        endif.

*       ( C ) CONVERSION EXIT
        if not ls_viobj-CONVEXIT is initial.   "CONVERSION_EXIT_ALPHA_INPUT

          ls_treatment_chas-b_convexit = rs_c_true.
*         concatenate
*           'CONVERSION_EXIT_' ls_viobj-CONVEXIT '_INPUT'
*           into ls_treatment_chas-CONVEXIT_FUNC.

          ls_treatment_chas-CONVEXIT = ls_viobj-CONVEXIT.
        endif.

        if ls_treatment_chas-b_chavl        = rs_c_true or
           ls_treatment_chas-b_toupper      = rs_c_true or
           ls_treatment_chas-b_convexit     = rs_c_true.

          <ls_head_to_dim>-b_treatment       = rs_c_true.
          <ls_head_to_dim>-LS_TREATMENT_CHAS = ls_treatment_chas.         "Update hash table HEAD_TO_DIM
          append ls_treatment_chas to lt_treatment_chas.
        endif.

*     The data type is NUMERIC CHARACTER (NUMC)
      elseif ls_viobj-DATATP = rsd_c_datatp-numchar.      "NUMC

        ls_treatment_chas-b_typeconv = rs_c_true.

        <ls_head_to_dim>-b_treatment       = rs_c_true.
        <ls_head_to_dim>-LS_TREATMENT_CHAS = ls_treatment_chas.         "Update hash table HEAD_TO_DIM
        append ls_treatment_chas to lt_treatment_chas.

      endif. "CHARACTER LIKE data type

*   --------------------------------------------------------------------------
*   - The Infoobject is a TIME CHARACTERISTIC (TIM)
*   --------------------------------------------------------------------------
    elseif ls_viobj-IOBJTP = rsd_c_objtp-time.

*     The data type is NUMERIC CHARACTER (NUMC)
      if ls_viobj-DATATP = rsd_c_datatp-numchar.      "NUMC

        ls_treatment_chas-b_typeconv = rs_c_true.

        <ls_head_to_dim>-b_treatment       = rs_c_true.
        <ls_head_to_dim>-LS_TREATMENT_CHAS = ls_treatment_chas.         "Update hash table HEAD_TO_DIM
        append ls_treatment_chas to lt_treatment_chas.
      endif.

*   --------------------------------------------------------------------------
*   - The Infoobject is a UNIT or CURRENCY
*   --------------------------------------------------------------------------
    elseif ls_viobj-IOBJTP = rsd_c_objtp-unit.

*     The data type is either UNIT or CUKY
      if  ls_viobj-DATATP = rsd_c_datatp-currency     "CUKY
       or ls_viobj-DATATP = rsd_c_datatp-unit.        "UNIT

*       ( A ) CHAVL
        ls_treatment_chas-b_chavl   =  rs_c_true.          "Remove characters according to "CHAVL"

*       ( B ) TOUPPER
        if ls_viobj-LOWERCASE = rs_c_false.                "No lowercase letters allowed,
          ls_treatment_chas-b_toupper =  abap_true.        "=> perform 'to upper' conversion
        endif.

      endif.

      if ls_treatment_chas-b_chavl        = rs_c_true or
         ls_treatment_chas-b_toupper      = rs_c_true or
         ls_treatment_chas-b_convexit     = rs_c_true.

        <ls_head_to_dim>-b_treatment       = rs_c_true.
        <ls_head_to_dim>-LS_TREATMENT_CHAS = ls_treatment_chas.         "Update hash table HEAD_TO_DIM
        append ls_treatment_chas to lt_treatment_chas.
      endif.

    endif. "ls_viobj-IOBJTP = CHARACTERISTIC

  endloop. "I_R_UPLOAD->N_T_IOBJNM
  clear: ls_treatment_chas, ln_ColIdx.

  E_T_TREATMENT_CHAS[] = lt_treatment_chas[].
  free: lt_treatment_chas.

  clear E_SUBRC.

endmethod. "BUILD_COLUMN_TREATMENT_CHAS


method BUILD_COLUMN_TREATMENT_KYFS.
* ----------------------------------------------------------------------------
* - Analyze the physical keyfigures in the CDM upload Cube(s).
* - Scheule each amount for amount conversion according to TCURX.
* ----------------------------------------------------------------------------

FIELD-SYMBOLS:
  <lf_field>             type ANY,
  <ls_record>            type ANY,
  <ls_treatment_kyfs>    type T_S_TREATMENT_KYFS,
  <ls_cdm_upload_cubes>  type Y0XFU_T_S_MEAS_CLUSTER.

DATA:
  l_subrc      type SYSUBRC,
  ls_viobj     type RSD_S_VIOBJ,
  ls_iobj      type RSD_S_IOBJ,
  ls_cob_pro   type RSD_S_COB_PRO,
  ls_aruot     type RSAA_S_AROUT,
  ls_arout_txt type RSAA_S_AROUTT,
  ls_aabap     type RSAA_T_AABAP,

  ln_ColIdx    type SYTABIX,            "the given characteristic has this column index
                                        "in the file structure

  ls_treatment_kyfs type T_S_TREATMENT_KYFS,
  lt_treatment_kyfs type T_T_TREATMENT_KYFS.


  E_SUBRC = 8.

  free: E_T_TREATMENT_KYFS.

* ----------------------------------------------------------------------------
* - Collect the PHYSICAL KEYFIGURES
* ----------------------------------------------------------------------------
  FIELD-SYMBOLS: <ls_cube_iobj>  type RSD_S_CUBE_IOBJ.
  DATA:           lt_cube_iobj   type RSD_T_CUBE_IOBJ.

  loop at I_T_CDM_UPLOAD_CUBES assigning <ls_cdm_upload_cubes>.

    free: lt_cube_iobj.
    CALL FUNCTION 'RSD_CUBE_GET'
      EXPORTING
        I_INFOCUBE               = <ls_cdm_upload_cubes>-SOURCE
        I_OBJVERS                = RS_C_OBJVERS-ACTIVE
*       I_BYPASS_BUFFER          = RS_C_FALSE
*       I_WITH_ATR_NAV           = RS_C_FALSE
      IMPORTING
        E_T_CUBE_IOBJ            = lt_cube_iobj
      EXCEPTIONS
        INFOCUBE_NOT_FOUND       = 1
        ILLEGAL_INPUT            = 2
        OTHERS                   = 3.

    clear ls_treatment_kyfs.
    loop at lt_cube_iobj assigning <ls_cube_iobj>
      where IOBJTP = rsd_c_objtp-keyfigure.

      ls_treatment_kyfs-PHYS_KEY_FIGURE = <ls_cube_iobj>-IOBJNM.
      collect ls_treatment_kyfs into lt_treatment_kyfs.
    endloop.
  endloop.
  clear ls_treatment_kyfs.

* ----------------------------------------------------------------------------
* - Get keyfigure properties "keyfigure type" and "currency".
* - Update the treatment for keyfigures.
* ----------------------------------------------------------------------------
  loop at lt_treatment_kyfs assigning <ls_treatment_kyfs>.

    CALL FUNCTION 'RSD_IOBJ_GET'                            "was bin ich fuer einer ?
      EXPORTING
         I_IOBJNM               = <ls_treatment_kyfs>-PHYS_KEY_FIGURE
         I_OBJVERS              = RS_C_OBJVERS-ACTIVE
         I_BYPASS_BUFFER        = RS_C_FALSE
         I_IGNORE_BCTCOMP       = RS_C_FALSE
         I_WITH_DTEL            = RS_C_TRUE
      IMPORTING
         E_S_VIOBJ              = ls_viobj          "View of all properties of an InfoObject
         E_S_IOBJ               = ls_iobj           "View of InfoObjects and texts
         E_S_COB_PRO            = ls_cob_pro        "InfoObject Properties (in Context of InfoCube / ODS Object)
         E_S_AROUT              = ls_aruot          "ABAP routine - check table   Table: RSAROUT
         E_S_AROUTT             = ls_arout_txt      "ABAP routine - text table    Table: RSAROUTT
         E_T_AABAP              = ls_aabap          "ABAP routine - source code   Table: RSAABAP
      EXCEPTIONS
        IOBJ_NOT_FOUND         = 1
        ILLEGAL_INPUT          = 2
        BCT_COMP_INVALID       = 3
        OTHERS                 = 4.

    if sy-subrc <> 0.
*     msg
      RETURN.
    endif.

    <ls_treatment_kyfs>-IOBJNM       = ls_cob_pro-IOBJNM.
    <ls_treatment_kyfs>-IOBJTP       = ls_cob_pro-IOBJTP.
    <ls_treatment_kyfs>-DATATP       = ls_cob_pro-DATATP.
    <ls_treatment_kyfs>-INTLEN       = ls_cob_pro-INTLEN.
    <ls_treatment_kyfs>-OUTPUTLEN    = ls_cob_pro-OUTPUTLEN.
    <ls_treatment_kyfs>-CONVEXIT     = ls_cob_pro-CONVEXIT.
    <ls_treatment_kyfs>-LOWERCASE    = ls_cob_pro-LOWERCASE.
    <ls_treatment_kyfs>-INTTP        = ls_cob_pro-INTTP.
    <ls_treatment_kyfs>-DECIMALS     = ls_cob_pro-DECIMALS.
    <ls_treatment_kyfs>-DIGITS       = ls_cob_pro-DIGITS.

    <ls_treatment_kyfs>-KYFTP        = ls_cob_pro-KYFTP.       "Key figure type
    <ls_treatment_kyfs>-FIXCUKY      = ls_cob_pro-FIXCUKY.     "Fixed currency
    <ls_treatment_kyfs>-UNINM        = ls_cob_pro-UNINM.       "Unit InfoObject (currency/unit)
    <ls_treatment_kyfs>-TXTSH        = ls_cob_pro-TXTSH.       "Short description

    if ls_viobj-IOBJTP     = rsd_c_objtp-keyfigure.             "The Infoobject is a KEYFIGURE            KYF
      if ls_viobj-KYFTP    = rsd_c_kyftp-amount.                "The keyfigures represents an Amount      AMO
        if ls_viobj-DATATP = rsd_c_datatp-amount.               "The datatype of an amount is "currency"  CURR

          <ls_treatment_kyfs>-b_convamount = rs_c_true.              "Convert amounts according to decimal specification in TCURX

        endif. "ls_viobj-DATATP = rsd_c_datatp-currency
      endif.   "ls_viobj-KYFTP = rsd_c_kyftp-amount
    endif.     "ls_viobj-IOBJTP = rsd_c_objtp-keyfigure

  endloop. "lt_treatment_kyfs

  E_T_TREATMENT_KYFS[] = lt_treatment_kyfs[].
  free: lt_treatment_kyfs.

  clear E_SUBRC.

endmethod.


method BUILD_MAP_TO_CUBESTRUCT.

  FIELD-SYMBOLS:
    <lf_fieldname>           type ANY,
    <ls_valid_header_fields> type T_S_VALID_HEADER_FIELDS.

  DATA:
    ln_FilePos       type i,        "Current Position (Index) in File as delivered
    ln_IdxChar       type SYINDEX,  "Currrent Index for identified characteristic
    ln_IdxKyfs       type SYINDEX,  "Currrent Index for identified keyfigure
    ln_max_fields    type i,        "Maximum number of fields in the file
    lb_empty_header_found type RS_BOOL,

    ls_map_to_cubestruct type T_S_MAP_TO_CUBESTRUCT,

    lf_COL_HEAD_LOW type RSTXTLG,   "Column Header as delivered
                                                "(not translated to uppcer case)
                                                "for messages

    lstr_v1          type string,
    lstr_v2          type string,
    lstr_v3          type string,
    lstr_v4          type string.

  ln_IdxChar = 1.               "
  ln_IdxKyfs = CN_MAX_CHAS + 1. "Keyfigures start right behind the chars
                                "in the cube structure

  ln_FilePos = 1.               "Start with the first Field in the File
  ln_max_fields = CN_MAX_CHAS +
                  CN_MAX_KYFS.

  lb_empty_header_found = rs_c_false.
  while ln_FilePos <= ln_max_fields.

    clear lf_COL_HEAD_LOW.

*   get the next field of the file
    assign component ln_FilePos
      of structure ls_file to <lf_fieldname>.

    if sy-subrc <> 0.
*     308: Field at File Position '&' couldn't be assigned.
      move ln_FilePos to lstr_v1.
      ADD_MSG 'E' '308' lstr_v1 '' '' ''.
      RETURN.
    endif.

*   no more fields supplied
    if <lf_fieldname> is initial.

      lb_empty_header_found = rs_c_true.
*     EXIT.                                "exit loop

      ln_FilePos = ln_FilePos + 1.
      CONTINUE.                            "process all possible fields now !

*   further fields supplied
    else.
      if lb_empty_header_found = rs_c_true.
*       484: Header '&' after an empty column is not allowed.
        ADD_MSG 'W' '' <lf_fieldname> '' '' ''.
        EXIT.
      endif.
    endif.

*   translate the column header into uppercase before look-up
    lf_COL_HEAD_LOW = <lf_fieldname>.
    translate <lf_fieldname> to upper case.

*   check, if the fieldname is a valid column header
    read table STH_VALID_HEADER_FIELDS
      with key COL_HEADER = <lf_fieldname>
      assigning <ls_valid_header_fields>.

*   Header invalid
    if sy-subrc <> 0.

*     321: Header column '&' cannot be mapped to an existing dimension.
      ADD_MSG 'W' '321' <lf_fieldname> '' '' ''.           "( A ) Column header name must be valid

      clear ls_map_to_cubestruct.
      ls_map_to_cubestruct-nIdx            = ln_IDxChar.     " <<
      ls_map_to_cubestruct-nFilePos        = ln_FilePos.     " <<
      ls_map_to_cubestruct-COL_HEADER      = <lf_fieldname>.
      ls_map_to_cubestruct-HEADER_TYPE     = 'XXXX'.
      ls_map_to_cubestruct-COL_HEAD_LOW    = lf_COL_HEAD_LOW.

      modify MT_MAP_TO_CUBESTRUCT
          index ln_IdxChar
          from ls_map_to_cubestruct.
      ln_IdxChar = ln_IdxChar + 1.

*   Header valid
    else.

*     Characteristics
      if <ls_valid_header_fields>-HEADER_TYPE = C_Y0XF_HEADER_TYPE-CHAS.

        clear ls_map_to_cubestruct.
        ls_map_to_cubestruct-nIdx            = ln_IDxChar.     " <<
        ls_map_to_cubestruct-nFilePos        = ln_FilePos.     " <<
        ls_map_to_cubestruct-COL_HEADER      = <lf_fieldname>.
        ls_map_to_cubestruct-HEADER_TYPE     = <ls_valid_header_fields>-HEADER_TYPE.
        ls_map_to_cubestruct-HEADER_SUBTYPE  = <ls_valid_header_fields>-HEADER_SUBTYPE.
        ls_map_to_cubestruct-KFY_MONTH       = <ls_valid_header_fields>-KFY_MONTH.
        ls_map_to_cubestruct-COL_HEAD_LOW    = lf_COL_HEAD_LOW.

*       duplicate header column of type CHAR
        read table MT_MAP_TO_CUBESTRUCT
          with key COL_HEADER = ls_map_to_cubestruct-COL_HEADER
          transporting no fields.
        if sy-subrc = 0.
*         328: Column header '&' provided more than once.
          ADD_MSG 'W' '328' lf_COL_HEAD_LOW '' '' ''.
        endif.

        modify MT_MAP_TO_CUBESTRUCT
            index ln_IdxChar
            from ls_map_to_cubestruct.
        ln_IdxChar = ln_IdxChar + 1.

*     Keyfigures
      elseif <ls_valid_header_fields>-HEADER_TYPE = C_Y0XF_HEADER_TYPE-KYFS.

        clear ls_map_to_cubestruct.
        ls_map_to_cubestruct-nIdx             = ln_IdxKyfs.  " <<
        ls_map_to_cubestruct-nFilePos         = ln_FilePos.  " <<
        ls_map_to_cubestruct-COL_HEADER      = <lf_fieldname>.
        ls_map_to_cubestruct-HEADER_TYPE     = <ls_valid_header_fields>-HEADER_TYPE.
        ls_map_to_cubestruct-HEADER_SUBTYPE  = <ls_valid_header_fields>-HEADER_SUBTYPE.
        ls_map_to_cubestruct-KFY_MONTH       = <ls_valid_header_fields>-KFY_MONTH.
        ls_map_to_cubestruct-COL_HEAD_LOW    = lf_COL_HEAD_LOW.

*       duplicate header column of type CHAR
        read table MT_MAP_TO_CUBESTRUCT
          with key COL_HEADER = ls_map_to_cubestruct-COL_HEADER
          transporting no fields.
        if sy-subrc = 0.
*         328: Column header '&' provided more than once.
          ADD_MSG 'W' '328' lf_COL_HEAD_LOW '' '' ''.      " ( B ) Each column name must be provided only once
        endif.

        modify MT_MAP_TO_CUBESTRUCT
            index ln_IdxKyfs
            from ls_map_to_cubestruct.
        ln_IdxKyfs = ln_IdxKyfs + 1.

*     Unknown Dimension type
      else.
*       306: Column header '&' has unnown dimension type '&'.
        ADD_MSG 'W' '306' lf_COL_HEAD_LOW                  " ( C ) Column header has unnown dimension type
              <ls_valid_header_fields>-HEADER_TYPE '' ''.
      endif.

    endif.
    if <ls_valid_header_fields> is assigned. unassign <ls_valid_header_fields>. endif.
    unassign <lf_fieldname>.
    ln_FilePos = ln_FilePos + 1.
  endwhile.
  clear: ln_FilePos, lf_COL_HEAD_LOW.

endmethod.


method BUILD_TRANSLATION_HEAD_TO_DIM.

  FIELD-SYMBOLS:
    <lf_header>      type ANY,
    <ls_head>        type T_S_HEAD.

  DATA:
    ln_cnt(2)          type n,
    ls_head_to_dim     type T_S_HEAD_TO_DIM.

* --------------------------------------------------------------------------
* - C H A R A C T E R I S T I C S
* - Build Translation Table "Column header to Dimensions"
* --------------------------------------------------------------------------
  DATA:
    lstr_fieldname(C_FIELDNAME_LEN)  type c.

  free: E_TH_HEAD_TO_DIM_CHAS[].
  ln_cnt = 1.                                       "charnames start with '01'
  lstr_fieldname =  C_FIELDNAME_PREAFIX-CHAS.       "'ZXF_CHA__' [01..40] !
  while ln_cnt <= CN_MAX_CHAS.

*   create the fieldname of characteristic #ln_cnt and read the "Header name" stored in this fied of the status record
    lstr_fieldname+C_FIELDNAME_PREAFIX-LEN(2) = ln_cnt.
    assign component lstr_fieldname of structure I_S_STATUS to <lf_header>. if sy-subrc <> 0. return. endif. "msg

*   look up the dimension assigned to the header
    read table STH_HEAD with key HEADER_TYPE = C_Y0XF_HEADER_TYPE-CHAS
                                 COL_HEADER  = <lf_header>
      assigning <ls_head>.

    if sy-subrc <> 0.   "Not all characteristics will be used
      EXIT.             "Characteristics are filled in ascending order
    endif.              "No columns are left blank !

    clear ls_head_to_dim.

*   Mapping from Source: Fieldname to Destination: Dimension
    ls_head_to_dim-FIELDNM_SRC     = lstr_fieldname.           "characteristic name in the source record
    ls_head_to_dim-FIELDNM_DST     = <ls_head>-DIMNM.          "This is the dimension for characteristics, not for keyfigures

*   Attributes
    ls_head_to_dim-n_ColIdx        = ln_cnt.
    ls_head_to_dim-DIMNM           = <ls_head>-DIMNM.          "Dimension (Characteristic)
    ls_head_to_dim-COL_HEADER      = <lf_header>.              "Column Header for Upload
    ls_head_to_dim-HEADER_TYPE     = <ls_head>-HEADER_TYPE.    "Header Type {CHA, KYF}
    ls_head_to_dim-HEADER_SUBTYPE  = <ls_head>-HEADER_SUBTYPE.
    ls_head_to_dim-KFY_MONTH       = <ls_head>-KFY_MONTH.
    ls_head_to_dim-COL_HEAD_LOW    = <ls_head>-COL_HEAD_LOW.   "Column Header as delivered
    insert ls_head_to_dim into table E_TH_HEAD_TO_DIM_CHAS.

    clear:    ls_head_to_dim.
    unassign: <lf_header>, <ls_head>.

    ln_cnt = ln_cnt + 1.

  endwhile. "ln_cnt <= CN_MAX_CHAS
  clear: ln_cnt, lstr_fieldname.

* --------------------------------------------------------------------------
* - K E Y F I G U R E S
* - Build Translation Table "Column header to Dimensions"
* --------------------------------------------------------------------------
*        1          2          3          4          5
* Status ZXF_CHA41  ZXF_CHA42  ZXF_CHA43  ZXF_CHA44  ZXF_CHA45   lstr_kfydescr
*             APR        JAN        DEC        JUN        AUG
*
* SRC    ZXF_KYF01  ZXF_KYF02  ZXF_KYF03  ZXF_KYF04  ZXF_KYF05   lstr_kyfsrc
* DST    ZXF_KYF04  ZXF_KYF01  ZXF_KYF12  ZXF_KYF06  ZXF_KYF08   lstr_kyfdst
* --------------------------------------------------------------------------
  DATA:
    ln_Offset(2)                     type n,
    lstr_kfydescr(C_FIELDNAME_LEN)   type c,
    lstr_kfysrc(C_FIELDNAME_LEN)     type c,
    lstr_kfydst(C_FIELDNAME_LEN)     type c.

  free: E_TH_HEAD_TO_DIM_KYFS[].
  ln_cnt = 1.
  lstr_kfydescr = C_FIELDNAME_PREAFIX-CHAS.                       "SRC: ZXF_CHA41 (APR)
  lstr_kfysrc   = C_FIELDNAME_PREAFIX-KYFS.                       "ZXF: ZXF_KYF01
  lstr_kfydst   = C_FIELDNAME_PREAFIX-KYFS.                       "ZXF: ZXF_KYF04
  while ln_cnt <= CN_MAX_KYFS.

*   "ZXF_CHA41"                                                    "CHARACTERISTIC DESCRIBING THE KEYFIGURE
    ln_Offset = ln_cnt + CN_MAX_CHAS.                              "41, 42, ..
    lstr_kfydescr+C_FIELDNAME_PREAFIX-LEN(2) =  ln_Offset.
    clear ln_Offset.

*   create the fieldname of keyfigure ln_cnt and read the "Header name" stored in this fied of the status record
    assign component lstr_kfydescr of structure I_S_STATUS to <lf_header>. if sy-subrc <> 0. return. endif. "msg

*   look up the dimension assigned to the header
    read table STH_HEAD with key HEADER_TYPE = C_Y0XF_HEADER_TYPE-KYFS
                                 COL_HEADER  = <lf_header>        "APR, VALUE
      assigning <ls_head>.

    if sy-subrc = 0.    "Not all characteristics will be used
                        "Characteristics are filled in ascending order
                        "No columns are left blank !

      case <ls_head>-HEADER_SUBTYPE.
        when C_Y0XF_HEADER_SUBTYPE-KFYVAL.    ln_Offset = '01'.
        when C_Y0XF_HEADER_SUBTYPE-KFYMON.    ln_offset = <ls_head>-KFY_MONTH.
        when others.
*         msg
      endcase.

      lstr_kfysrc+C_FIELDNAME_PREAFIX-LEN(2) = ln_cnt.
      lstr_kfydst+C_FIELDNAME_PREAFIX-LEN(2) = ln_Offset.

      clear ls_head_to_dim.
      ls_head_to_dim-FIELDNM_SRC     = lstr_kfysrc.       "Keyfigure name in the source record
      ls_head_to_dim-FIELDNM_DST     = lstr_kfydst.       "Keyfigure name in the target record

*     Attributes
      ls_head_to_dim-n_ColIdx        = ln_cnt.                   "Column Index into data records  for Index access rather than access by name
      ls_head_to_dim-n_ColIdxStatKyf = ln_cnt + CN_MAX_CHAS.     "Column Index into status record for Index access rather than access by name
*     ls_head_to_dim-DIMNM           = <ls_head>-DIMNM.          "Dimension (Characteristic)                       "2011-01-06 (mh) empty
      ls_head_to_dim-DIMNM           = lstr_kfysrc.              "Keyfigure name                                   "2011-01-06 (mh)
      ls_head_to_dim-COL_HEADER      = <lf_header>.              "Column Header for Upload
      ls_head_to_dim-HEADER_TYPE     = <ls_head>-HEADER_TYPE.    "Header Type {CHA, KYF}
      ls_head_to_dim-HEADER_SUBTYPE  = <ls_head>-HEADER_SUBTYPE.
      ls_head_to_dim-KFY_MONTH       = <ls_head>-KFY_MONTH.
      ls_head_to_dim-COL_HEAD_LOW    = <ls_head>-COL_HEAD_LOW.   "Column Header as delivered
      insert ls_head_to_dim into table E_TH_HEAD_TO_DIM_KYFS.

      clear:    ls_head_to_dim.
      unassign: <lf_header>, <ls_head>.

    endif.  "read table STH_HEAD
    ln_cnt = ln_cnt + 1.

  endwhile. "ln_cnt < CN_MAX_KYFS

endmethod. "BUILD_TRANSLATION_HEAD_TO_DIM


METHOD CHECK_DUPLICATES.

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,
    <ls_data>        type ANY.             "the source record as a pointer into a table, not a work area

  DATA:
    l_subrc          type SYSUBRC,

    lref_wa_dupl_chas type REF TO DATA,           "dynamic data creation
    lref_t_dupl_chas  type REF TO DATA,           "dynamic data creation
    lref_wa_aggr      type REF TO DATA,           "dynamic data creation
    lref_t_aggr       type REF TO DATA,           "dynamic data creation

    ln_NoMessages     type I,
    ln_RecNo          type I,
    lb_erroneous      type RS_BOOL,

    ls_iobjnm         type RSD_S_IOBJNM,
    lt_iobjnm         type RSD_T_IOBJNM.           "Characteristics (CDM) in the file


  FIELD-SYMBOLS:

    <SRC>             type ANY,
    <DST>             type ANY,
    <ls_head_to_dim>  type T_S_HEAD_TO_DIM,

    <ls_dupl_chas>    type ANY,                   "Pointer into table ..
    <lt_dupl_chas>    type STANDARD TABLE,        "  .. with only characteristics (duplicate rows)
    <lwa_dupl_chas>   type ANY,                   "corresponding WORK AREA, dynamically created !!!

    <ls_aggr>         type ANY,                   "pointer into table ..
    <lt_aggr>         type STANDARD TABLE,        "  .. with numeric data types for keyfigures P/IF/ instead of CHAR 30
    <lwa_aggr>        type ANY.                   "corresponding WORK AREA, dynamically created !!!

*    <ls_resultfile>   type ANY,                   "pointer into table ..
*    <lt_resultfile>   type STANDARD TABLE,        "  .. file keyfigures of type char30
*    <lwa_resultfile>  type ANY.                   "WORK AREA for target record, dynamically created !!!



* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

  free: lt_iobjnm.
  clear ls_iobjnm.
  loop at MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>.

    ls_iobjnm-IOBJNM = <ls_head_to_dim>-DIMNM.
    append ls_iobjnm to lt_iobjnm.
  endloop.

* ----------------------------------------------------------------------------
* - Create structure(s) and table(s) for identifying duplicates and agregation
* ----------------------------------------------------------------------------
  clear: lref_wa_aggr, lref_wa_dupl_chas,
         lref_t_aggr,  lref_t_dupl_chas.

  call method _CHECK_DUPLICATES_CREATE_DATA

      exporting  I_T_IOBJNM         = lt_iobjnm               "CDM Charcteristcs
*                                     I_R_UPLOAD->N_T_IOBJNM  "CHAR 60
      importing  E_REF_WA_AGGR      = lref_wa_aggr         "work area for record with numeric keyfigures for aggregation
                 E_REF_T_AGGR       = lref_t_aggr          "Table for aggregation
                 E_REF_WA_DUPL_CHAS = lref_wa_dupl_chas    "work area for record with only characteristics
                 E_REF_T_DUPL_CHAS  = lref_t_dupl_chas     "Table for checking duplicates (only characteristics)
      exceptions INVALID_FIELD      = 1
                 NO_FIELDS          = 2
                 others             = 3.

  if sy-subrc <> 0.
    RETURN.
  endif.

  if not lref_wa_aggr      is initial. assign lref_wa_aggr->*      to <lwa_aggr>.      endif. clear lref_wa_aggr.
  if not lref_t_aggr       is initial. assign lref_t_aggr->*       to  <lt_aggr>.      endif. clear lref_t_aggr.

  if not lref_wa_dupl_chas is initial. assign lref_wa_dupl_chas->* to <lwa_dupl_chas>. endif. clear lref_wa_dupl_chas.
  if not lref_t_dupl_chas  is initial. assign lref_t_dupl_chas->*  to <lt_dupl_chas>.  endif. clear lref_t_dupl_chas.

  free: lt_iobjnm. clear ls_iobjnm.

* --------------------------------------------------------------------------
* - Initialize return parameters
* --------------------------------------------------------------------------
  clear: E_NRECERR.
  E_ZXF_STAT = C_ZXF_STAT-INVALID_FILE.                                        " <<<< S T A T U S

* Check for duplicate records AFTER conversions have been applied
  free: <lt_dupl_chas>.
  loop at C_T_DATA assigning <ls_data>.

*   Get the Record Number from the Record
    clear ln_RecNo.
    assign component 'ZXF_RECNO' of structure <ls_data> to <LF_FIELD>.
    if sy-subrc = 0.
      ln_RecNo = <LF_FIELD>.
    endif.
    if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

    clear lb_erroneous.
    clear <lwa_dupl_chas>.
*   move-corresponding <ls_data> to <lwa_dupl_chas>.              "move characteristics  CHAR 60
    loop at MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>.      "move characteristics  CDM
      assign component <ls_head_to_dim>-FIELDNM_SRC of structure <ls_data> to <SRC>.
      if sy-subrc = 0.
        assign component <ls_head_to_dim>-FIELDNM_DST of structure <lwa_dupl_chas> to <DST>.
        if sy-subrc = 0.
          <DST> = <SRC>.
        endif.
      endif.
    endloop.

*   Look up the record comparing all available characteristics
    read table <lt_dupl_chas>
        from <lwa_dupl_chas>
        transporting no fields.

*   NEW record: Store characteristics of the new record
    if sy-subrc <> 0.

      insert <lwa_dupl_chas> into table <lt_dupl_chas>.

*   Duplicate Record:
    else.

*     362: Record '&' Duplicate Record.
      case M_N_CHECK_DUPLICATES.
        when I_R_UPLOAD->n_c_duplicates_add.    "aggregate and remain silent ...
        when I_R_UPLOAD->n_c_duplicates_warn.   ADD_REC_MSG 'I' '362' ln_RecNo '' '' ''.
        when I_R_UPLOAD->n_c_duplicates_error.  lb_erroneous = rs_c_true.
                                                ADD_REC_MSG 'W' '362' ln_RecNo '' '' ''.   "E/W -> "MSG"
      endcase.
    endif.

*   Record is erroneous
    if lb_erroneous = rs_c_true.

      E_NRECERR = E_NRECERR + 1.
      assign component 'ZXF_FERR'   of structure <ls_data> to <lf_field>. <lf_field> = 'X'. "Mark record as erroneous
      assign component '0TCTRECERR' of structure <ls_data> to <lf_field>. <lf_field> =  1.  "Count erroneous records

    endif.
    if <lf_field> is assigned. unassign <lf_field>. endif.

    clear: lb_erroneous.

    if MN_TOT > CN_MAX_TOT.
      EXIT.   "exit loop !
    endif.

  endloop. "C_T_DATA assigning <ls_data>
  if  <ls_data> is assigned. unassign  <ls_data>.  endif.

* --------------------------------------------------------------------------
* - Set Status
* --------------------------------------------------------------------------
  if E_NRECERR = 0.
    E_ZXF_STAT = C_ZXF_STAT-VALID_FILE.                                             " <<<< S T A T U S
  endif.

* ----------------------------------------------------------------------------
* - Return Errors and Messages
* ----------------------------------------------------------------------------
* E_NRECERR     = ln_RecErr.       "Has been set properly above
* E_ZXF_STAT    = C_ZXF_STAT- ...  "Has been set properly above
  C_T_REC_MSG[] = MT_REC_MSG[].    "The soubroutines used ADD_REC_MSG which uses the MT_REC_MSG.

  free:
    MT_REC_MSG,
    <lwa_aggr>, <lwa_dupl_chas>,   "WORK AREA
     <lt_aggr>,  <lt_dupl_chas>.    "Tables

* <lwa_resultfile>,
* <lt_resultfile>

ENDMETHOD.  "CHECK_DUPLICATES


METHOD CHECK_DUPLICATES_HASH.

  TYPES:
    BEGIN OF ty_hash_value,
      component  TYPE abap_compname,
      value      TYPE rschavl_maxlen,
    END OF ty_hash_value,

    begin of T_S_HASH_KEY,
      HASH_KEY type HASH160,
    end of T_S_HASH_KEY,

    T_TH_HASH_KEY type hashed table of T_S_HASH_KEY with unique key HASH_KEY.

  FIELD-SYMBOLS:
    <LF_SRC>          type ANY,
    <LF_DST>          type ANY,
    <LF_FIELD>        type ANY,
    <ls_data>         type ANY,             "the source record as a pointer into a table, not a work area
    <ls_head_to_dim>  type T_S_HEAD_TO_DIM.

  DATA:
    l_subrc          type SYSUBRC,
    lstring_value    TYPE string,
    l_hash_value     TYPE hash160,
    ls_dupl_chas     type  T_S_HASH_KEY,
    lt_dupl_chas     type T_TH_HASH_KEY,



    ln_NoMessages     type I,
    ln_RecNo          type I,
    lb_erroneous      type RS_BOOL,

    lt_hash_value  TYPE STANDARD TABLE OF ty_hash_value,
    ls_hash_value  TYPE ty_hash_value.



* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================


* --------------------------------------------------------------------------
* - Initialize return parameters
* --------------------------------------------------------------------------
  clear: E_NRECERR.
  E_ZXF_STAT = C_ZXF_STAT-INVALID_FILE.                                        " <<<< S T A T U S


* ----------------------------------------------------------------------------
* - Check for duplicate records AFTER conversions have been applied
* ----------------------------------------------------------------------------
  free: lt_dupl_chas.
  loop at C_T_DATA assigning <ls_data>.

*   Get the Record Number from the Record
    clear ln_RecNo.
    assign component 'ZXF_RECNO' of structure <ls_data> to <LF_FIELD>.
    if sy-subrc = 0.
      ln_RecNo = <LF_FIELD>.
    endif.
    if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

    clear lb_erroneous.
    free: lt_hash_value.
    loop at MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>.      "move characteristics  CDM

      assign component <ls_head_to_dim>-FIELDNM_SRC of structure <ls_data> to <LF_SRC>.
      if sy-subrc = 0.

*       Create entry in CTAB
        clear ls_hash_value.
        ls_hash_value-component = '/BIC/OIZXF_CHA01'.
        ls_hash_value-value     = <LF_SRC>.
        append ls_hash_value to lt_hash_value.
        clear ls_hash_value.

      endif.
    endloop. "MTH_HEAD_TO_DIM_CHAS

    clear lstring_value.
    call function 'COPY_CTAB_TO_STRING' importing DATA_OUT = lstring_value
                                        tables    DATA_IN  = lt_hash_value.
    free: lt_hash_value.

*   Compute hash value for char-string
    clear l_hash_value.
    CALL FUNCTION 'CALCULATE_HASH_FOR_CHAR'
      EXPORTING
*       ALG                  = 'SHA1'
        data                 = lstring_value
*       LENGTH               = 0
      IMPORTING
        hash                 = l_hash_value
*       HASHLEN              =
*       HASHX                =
*       HASHXLEN             =
        EXCEPTIONS
        unknown_alg          = 1
        param_error          = 2
        internal_error       = 3
        OTHERS               = 4.

*   Look up the record comparing all available characteristics
    read table lt_dupl_chas with key HASH_KEY = l_hash_value
        transporting no fields.

*   NEW record: Store characteristics of the new record
    if sy-subrc <> 0.

      clear ls_dupl_chas.
      ls_dupl_chas-HASH_KEY = l_hash_value.
      insert ls_dupl_chas into table lt_dupl_chas.

      clear: ls_dupl_chas, l_hash_value.

*   Duplicate Record:
    else.

*     362: Record '&' Duplicate Record.
      lb_erroneous = rs_c_true.
      ADD_REC_MSG 'W' '362' ln_RecNo '' '' ''.   "E/W -> "MSG"
    endif.

*   Record is erroneous
    if lb_erroneous = rs_c_true.

      E_NRECERR = E_NRECERR + 1.
      assign component 'ZXF_FERR'   of structure <ls_data> to <lf_field>. <lf_field> = 'X'. "Mark record as erroneous
      assign component '0TCTRECERR' of structure <ls_data> to <lf_field>. <lf_field> =  1.  "Count erroneous records

    endif.
    if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

    clear: lb_erroneous.

    if MN_TOT > CN_MAX_TOT.
      EXIT.   "exit loop !
    endif.

  endloop. "C_T_DATA assigning <ls_data>
  free: lt_dupl_chas.
  if  <ls_data> is assigned. unassign  <ls_data>.  endif.

* --------------------------------------------------------------------------
* - Set Status
* --------------------------------------------------------------------------
  if E_NRECERR = 0.
    E_ZXF_STAT = C_ZXF_STAT-VALID_FILE.                                             " <<<< S T A T U S
  endif.

* ----------------------------------------------------------------------------
* - Return Errors and Messages
* ----------------------------------------------------------------------------
* E_NRECERR     = ln_RecErr.       "Has been set properly above
* E_ZXF_STAT    = C_ZXF_STAT- ...  "Has been set properly above
  C_T_REC_MSG[] = MT_REC_MSG[].    "The soubroutines used ADD_REC_MSG which uses the MT_REC_MSG.

  free:
    MT_REC_MSG, lt_dupl_chas.    "Tables


ENDMETHOD.  "CHECK_DUPLICATES_HASH


METHOD constructor.

  FIELD-SYMBOLS:
   <any> TYPE ANY.

  DATA:
    l_oref_msg  TYPE REF TO cl_rsplfu_msg,
    l_subrc TYPE sysubrc.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* --------------------------------------------------------------------------
* - When Used ..
* --------------------------------------------------------------------------
  CALL FUNCTION 'Y0BC_WHEN_USED'.

* --------------------------------------------------------------------------
* - Initialize Member Variables used by ADD_MSG and ADD_REC_MSG
* --------------------------------------------------------------------------
  INIT_MESSAGE_VARIABLES.

  CREATE OBJECT l_oref_msg.

* ----------------------------------------------------------------------------
* Read User Default Values
* ----------------------------------------------------------------------------
  IF ss_user_defaults IS INITIAL.

    DATA:
      ls_bapi_ret      TYPE                   bapiret2,
      lt_bapi_ret      TYPE STANDARD TABLE OF bapiret2.

    REFRESH lt_bapi_ret.
    CALL FUNCTION 'BAPI_USER_GET_DETAIL'
      EXPORTING
        username = sy-uname
      IMPORTING
        defaults = ss_user_defaults
      TABLES
        return   = lt_bapi_ret.
*    IF NOT lt_bapi_ret IS INITIAL.
*      LOOP AT lt_bapi_ret INTO ls_bapi_ret.
*
*        message ID     ls_bapi_ret-ID
*                TYPE   ls_bapi_ret-TYPE
*                NUMBER ls_bapi_ret-NUMBER
*                WITH   ls_bapi_ret-MESSAGE_V1 ls_bapi_ret-MESSAGE_V2
*                       ls_bapi_ret-MESSAGE_V3 ls_bapi_ret-MESSAGE_V4.
*       RETURN.
*      ENDLOOP.
*    ENDIF.

  ENDIF.

* ----------------------------------------------------------------------------
* - Initialize the mapping structure with one row per
* - p o s s i b l e  (!) upload structure's field
* ----------------------------------------------------------------------------
  CLEAR l_subrc.
  FREE: mt_map_to_cubestruct[].

  CALL METHOD init_map_to_cubestruct      "create CN_MAX_CHAS + CN_MAX_KYFS lines

    IMPORTING e_subrc               = l_subrc
              e_t_map_to_cubestruct = mt_map_to_cubestruct.

* ----------------------------------------------------------------------------
* - Read table Y0BW_XF_UPHEADER, "XF UP: Column Header"
* ----------------------------------------------------------------------------
  CLEAR l_subrc.
  IF sth_head IS INITIAL OR
     sth_valid_header_fields IS INITIAL.

    CALL METHOD fill_head__valid_header_fields
      IMPORTING
        e_subrc                  = l_subrc
        e_th_head                = sth_head
        e_th_valid_header_fields = sth_valid_header_fields.

  ENDIF.

* ----------------------------------------------------------------------------
* - Read KPI database and fill the STH_MEAS_ID
* ----------------------------------------------------------------------------
  IF sth_meas_id IS INITIAL.

    DATA:
      lt_range_meid TYPE rsrcc_t_range,
      lt_result     TYPE y0bw_xf_meas_id_t.

    CLEAR l_subrc.
    FREE: lt_range_meid.
    CALL METHOD y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_id

      EXPORTING i_t_range_measid = lt_range_meid
*               I_OBJVERS        = RS_C_OBJVERS-ACTIVE
      IMPORTING e_subrc          = l_subrc
                e_t_result       = lt_result.

    IF l_subrc = 0.

      sth_meas_id[] = lt_result[].
      FREE: lt_result.
    ENDIF.
  ENDIF.

* ----------------------------------------------------------------------------
* - Read KPI database and fill the breakdown strcuture STH_MEAS_DIS
* ----------------------------------------------------------------------------
  IF sth_meas_dis IS INITIAL.

    CALL METHOD fill_breakdown_meas_dis
      EXPORTING
        i_r_msg       = l_oref_msg
      IMPORTING
        e_subrc       = l_subrc
        e_t_meas_set  = st_meas_set    "Measure with either set UPL or GEN.
        e_th_meas_dis = sth_meas_dis.  "Measure with breakdown-dimensions. The set has been eliminated.
    IF l_subrc = 0.
    ENDIF.

  ENDIF.

* ----------------------------------------------------------------------------
* - Assign each measure to it's data cluster
* ----------------------------------------------------------------------------
  IF sth_meas_cluster IS INITIAL.

    CALL METHOD fill_meas_cluster
      EXPORTING
        i_r_msg          = l_oref_msg
        i_t_meas_set     = st_meas_set       "List of relevant measures with the relevant set UPL or GEN !
      IMPORTING
        e_subrc          = l_subrc
        e_t_meas_cluster = sth_meas_cluster. "Measure / Data Cluster

  ENDIF.

* ----------------------------------------------------------------------------
* - Create table of CDM Upload Cubes, based on STH_MEAS_CLUSTER
* ----------------------------------------------------------------------------
  IF st_cdm_upload_cubes IS INITIAL.

    FIELD-SYMBOLS:
      <ls_meas_cluster> TYPE y0xfu_t_s_meas_cluster.

    DATA:
      ls_meas_cluster     TYPE y0xfu_t_s_meas_cluster,
      lt_cdm_upload_cubes TYPE y0xfu_t_t_meas_cluster.

    CLEAR ls_meas_cluster.
    FREE: lt_cdm_upload_cubes.
    LOOP AT sth_meas_cluster ASSIGNING <ls_meas_cluster>.

      ls_meas_cluster-source = <ls_meas_cluster>-source.  "=CDM Upload Cube
      COLLECT ls_meas_cluster INTO lt_cdm_upload_cubes.
    ENDLOOP.

    st_cdm_upload_cubes[] = lt_cdm_upload_cubes[].

    FREE: lt_cdm_upload_cubes.
  ENDIF.

* ----------------------------------------------------------------------------
* - Create list of authorization relevant characteristics used in ANY of the
* - CDM Upload Cubes.
* ----------------------------------------------------------------------------
  IF sth_auth_rel_chas IS INITIAL.

    DATA:
      lt_auth_rel_chas TYPE t_t_auth_rel_chas.

    CLEAR lt_auth_rel_chas.
    CALL METHOD build_auth_rel_chas
      EXPORTING
        i_r_msg              = l_oref_msg
        i_t_cdm_upload_cubes = st_cdm_upload_cubes
      IMPORTING
        e_t_auth_rel_chas    = lt_auth_rel_chas
        e_subrc              = l_subrc.

    IF l_subrc <> 0.
      RETURN.
    ENDIF.

*   Return column treatment for characteristics and keyfigures
    sth_auth_rel_chas[] = lt_auth_rel_chas[].

    FREE: lt_auth_rel_chas.
  ENDIF.


* ----------------------------------------------------------------------------
* - Fill buffer Management Profitcenter / Currency
* ----------------------------------------------------------------------------
  IF sth_mpct_curr IS INITIAL.

    CALL METHOD y0bw_cl_xf_utilities=>get_currency_by_mpct
      IMPORTING
        e_th_mpct_curr = sth_mpct_curr.
  ENDIF.

* ----------------------------------------------------------------------------
* - Read TCURX for Currency conversion
* ----------------------------------------------------------------------------
  SELECT * FROM tcurx INTO TABLE sth_curx.
  IF sy-subrc <> 0.
*   303: Database table '&' couldn't be read or is empty.
*   ADD_MSG 'E' '303' 'TCURX' '' '' ''.
  ENDIF.


  FREE l_oref_msg.
  CLEAR l_oref_msg.


ENDMETHOD. "CONSTRUCTOR


method COPY_FIELD_FROM_SRC_TO_DST.

  FIELD-SYMBOLS:
    <LF_SRC> type ANY,
    <LF_DST> type ANY.

  E_SUBRC = 8.

  assign component I_FLDNM_SRC of structure I_S_SOURCE to <LF_SRC>.
  assign component I_FLDNM_DST of structure E_S_TARGET to <LF_DST>.


*                                  305: Field Symbol '&' couldn't be assigned.
  if     not <LF_SRC> is assigned. ADD_MSG 'E' '305' I_FLDNM_SRC '' '' ''. RETURN.
  elseif not <LF_DST> is assigned. ADD_MSG 'E' '305' I_FLDNM_DST '' '' ''. RETURN.
  else.

*   Copy source field to destination field
    <LF_DST> = <LF_SRC>.

    get reference of <LF_SRC> into E_R_FLD_SRC.
    get reference of <LF_DST> into E_R_FLD_DST.

    unassign: <LF_SRC>, <LF_DST>.
  endif.

  clear E_SUBRC.

endmethod. "COPY_FIELD_FROM_SRC_TO_DST


METHOD COPY_TO_CDM_UPLOAD_CUBE.

  FIELD-SYMBOLS:
    <0INFOPROV>      type ANY,
    <ZRBASSIGN>      type ANY,

    <LF_SRC>         type ANY,
    <LF_DST>         type ANY,
    <LF_FIELD>       type ANY,

    <ls_source>      type ANY,             "the source record as a pointer into a table, not a work area
    <wa_target>      type ANY,             "the target record dynamically created >>work area<< !!

    <ls_head_to_dim_chas> type T_S_HEAD_TO_DIM,
    <ls_head_to_dim_kyfs> type T_S_HEAD_TO_DIM.

  DATA:
    lref_data         type REF TO DATA,
    lref_src          type REF TO DATA,     "Reference to the source field
    lref_dst          type REF TO DATA,     "Reference to the destination filed
    l_subrc           type SYSUBRC.

  E_SUBRC = 8.


* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================


* ----------------------------------------------------------------------------
* - Create a work area for the new record
* ----------------------------------------------------------------------------
  create data lref_data like line of I_T_SOURCE.
  assign lref_data->* to <wa_target>.
  clear lref_data.

* Delete target records (recreate from source records)         "keep the target records in case of "delete from reporting" !
  FREE: E_T_TARGET[].

**   475: Copy to CDM Upload Cube ..
*    ADD_MSG 'I' '475' '' '' '' ''.

* ----------------------------------------------------------------------------
* - Loop at the source records and create the target records
* ----------------------------------------------------------------------------
* -   o Map Column header to characteristic
* -   o Deal with keyfigures if periods are used
* ----------------------------------------------------------------------------
  DATA: l_ZXF_MEAS        type /BIC/OIZXF_MEAS,      " 'Measure ID'
        lstr_PhysKeyfig   type Y0XF_PHYS_KEY_FIGURE, " Name of the physical keyfigure
        l_ZXF_CURRT       type /BIC/OIZXF_CURT.

  loop at I_T_SOURCE assigning <ls_source>.

    clear: l_ZXF_MEAS, lstr_PhysKeyfig, <wa_target>.

*   --------------------------------------------------------------------------
*   - ( 1 ) Add the C H A R A C T E R I S T I C S
*   --------------------------------------------------------------------------
*   - Iterate the Column headers of type "(C)haracteristic and copy
*   - the field's value to the corresponding dimension
*   --------------------------------------------------------------------------
    loop at MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim_chas>.

*     copy and apply conversion routine
      call method COPY_FIELD_FROM_SRC_TO_DST                       "including year and period

        exporting I_FLDNM_SRC = <ls_head_to_dim_chas>-FIELDNM_SRC  "<<<<
                  I_FLDNM_DST = <ls_head_to_dim_chas>-FIELDNM_DST  "<<<<
                  I_S_SOURCE  = <ls_source>
                  I_R_MSG     = I_R_MSG
        importing E_R_FLD_SRC = lref_src
                  E_R_FLD_DST = lref_dst
                  E_S_TARGET  = <wa_target>
                  E_SUBRC     = l_subrc.

      if l_subrc <> 0.
        RETURN.
      endif.

*     Identify the Measure Id
      if <ls_head_to_dim_chas>-FIELDNM_DST = 'ZXF_MEAS'.

        assign component <ls_head_to_dim_chas>-FIELDNM_SRC
          of structure <ls_source> to <LF_FIELD>.             "ZXF_MEAS

        if sy-subrc = 0.
          l_ZXF_MEAS = <LF_FIELD>.
          unassign <LF_FIELD>.
        endif.
      endif.

      clear: lref_src, lref_dst.

    endloop. "MTH_HEAD_TO_DIM_CHAS
    if <ls_head_to_dim_chas> is assigned. unassign <ls_head_to_dim_chas>.  endif.

*   Ensure, the Measure Id is known
    if l_ZXF_MEAS is initial.

*     351: Record '&' has no Measure ID.
      ADD_MSG 'W' '351' '' '' '' ''.

*     307: ERRORS OCCURRED. PROCESSING TERMINATED.
      ADD_MSG 'W' '307' '' '' '' ''.
      RETURN.
    endif.

*   ------------------------------------------------------------------------
*   - ( 2 ) Add the target Infoprovider for the planning area (IP),
*   -           the techn. target InfoProvider as Sel. criteria in DTP
*   -           the 'Unique File ID' and 'DSF'
*   -       and the keyfigure 'Row counter'
*   ------------------------------------------------------------------------
    FIELD-SYMBOLS:
      <ls_MEASURE_ID>   type T_S_MEASURE_ID,
      <ls_meas_cluster> type Y0XFU_T_S_MEAS_CLUSTER.

    read table STH_MEAS_CLUSTER
      assigning <ls_meas_cluster>
      with key MEASID  = l_ZXF_MEAS.

    if sy-subrc <> 0.
*     381: Measure ID '&': Assignment not maintained in 'Y0BW_XF_UPL_MEAS'.
      ADD_MSG 'E' '381' l_ZXF_MEAS '' '' ''.
      RETURN.
    endif.

*   382: Measure Id '&'. Parameter '&' not maintained in 'Y0BW_XF_DATA_CLS'.
    if <ls_meas_cluster>-SOURCE is initial.
      ADD_MSG 'E' '382' l_ZXF_MEAS 'Source CDM Upload Cube'   '' ''.
      RETURN.
    endif.


*   382: Measure Id '&'. Parameter '&' not maintained in 'Y0BW_XF_DATA_CLS'.
    if <ls_meas_cluster>-DATA_CLUSTER  is initial. ADD_MSG 'E' '382' l_ZXF_MEAS 'Data Cluster'                   '' ''. RETURN. endif.
    if <ls_meas_cluster>-SRC_VIRT_PROV is initial. ADD_MSG 'E' '382' l_ZXF_MEAS 'Virtual Provider'               '' ''. RETURN. endif.
    if <ls_meas_cluster>-SOURCE        is initial. ADD_MSG 'E' '382' l_ZXF_MEAS 'Source CDM Upload Cube'         '' ''. RETURN. endif.
    if <ls_meas_cluster>-TARGET        is initial. ADD_MSG 'E' '382' l_ZXF_MEAS 'Target (cumulative values)'     '' ''. RETURN. endif.
    if <ls_meas_cluster>-TARGET_NCUM   is initial. ADD_MSG 'E' '382' l_ZXF_MEAS 'Target (non cumulative values)' '' ''. RETURN. endif.
    if <ls_meas_cluster>-PROCESS_CHAIN is initial. ADD_MSG 'E' '382' l_ZXF_MEAS 'Process Chain ID'               '' ''. RETURN. endif.

*   look up the target data provider cum/ncum fro the giben measure id
    read table MTH_MEASURE_ID assigning <ls_MEASURE_ID>
      with key MEASID = l_ZXF_MEAS.
*   465: COPY_TO_CDM_UPLOAD_CUBE Look up for Measure Id '&' failed.
    if sy-subrc <> 0.
      ADD_MSG 'E' '465' l_ZXF_MEAS '' '' ''.
      RETURN.
    endif.
*   466: COPY_TO_CDM_UPLOAD_CUBE The infoprovider CUM/NCUM cannot be determin
    if <ls_MEASURE_ID>-ZXF_IPROV       is initial. ADD_MSG 'E' '466' l_ZXF_MEAS '' '' ''. RETURN. endif.


    assign component '0INFOPROV' of structure <wa_target> to <LF_DST>. if sy-subrc = 0. <LF_DST> = <ls_meas_cluster>-SOURCE.  unassign <LF_DST>. else. ADD_REC_MSG 'E' '305' '0INFOPROV' '' '' ''. endif.
    assign component 'ZXF_IPROV' of structure <wa_target> to <LF_DST>. if sy-subrc = 0. <LF_DST> = <ls_MEASURE_ID>-ZXF_IPROV. unassign <LF_DST>. else. ADD_REC_MSG 'E' '305' 'ZXF_IPROV' '' '' ''. endif.
    assign component 'ZXF_DSF'   of structure <wa_target> to <LF_DST>. if sy-subrc = 0. <LF_DST> = C_ZXF_DSF-FILEUPLOAD.      unassign <LF_DST>. else. ADD_REC_MSG 'E' '305' 'ZXF_DSF'   '' '' ''. endif.
    assign component 'ZXF_RCNT'  of structure <wa_target> to <LF_DST>. if sy-subrc = 0. <LF_DST> = 1.                         unassign <LF_DST>. else. ADD_REC_MSG 'E' '305' 'ZXF_RCNT'  '' '' ''. endif.
    call method COPY_FIELD_FROM_SRC_TO_DST

      exporting I_FLDNM_SRC = 'ZXF_UFID'  "<<<<
                I_FLDNM_DST = 'ZXF_UFID'  "<<<<
                I_S_SOURCE  = <ls_source>
                I_R_MSG     = I_R_MSG
      importing E_R_FLD_SRC = lref_src
                E_R_FLD_DST = lref_dst
                E_S_TARGET  = <wa_target>
                E_SUBRC     = l_subrc.


*   ------------------------------------------------------------------------
*   - ( 3 ) Add the K E Y F I G U R E S and the 'Currency Type'
*   ------------------------------------------------------------------------
    FIELD-SYMBOLS: <ls_meas_id> type Y0BW_XF_MEAS_ID.
    clear: lref_src, lref_dst, lstr_PhysKeyfig, l_ZXF_CURRT, l_subrc.
    unassign: <ls_head_to_dim_kyfs>.

*   Identify the physical keyfigure per Measure Id
    read table STH_MEAS_ID assigning <ls_meas_id> with key MEASID  = l_ZXF_MEAS
                                                           OBJVERS = RS_C_OBJVERS-ACTIVE.

    if sy-subrc <> 0.                                          "mustn't pass validation !

*     341: Invalid master data '&' for characteristic '&'.
      ADD_REC_MSG 'W' '341' '0' 'Measure Id' '' ''.

*     307: ERRORS OCCURRED. PROCESSING TERMINATED.
      ADD_MSG 'W' '307' '' '' '' ''.
      RETURN.
    endif.

*   Each Measure Id must have assigned a Keyfigure
    if <ls_meas_id>-PHYS_KEY_FIGURE is initial.
      check 1 = 0.   "rs_c_false.
    endif.

    lstr_PhysKeyfig = <ls_meas_id>-PHYS_KEY_FIGURE.
    unassign <ls_meas_id>.

*   Derive the Currency Type associated with the physical keyfigure
    call method Y0BW_CL_XF_UTILITIES=>GET_ZXF_CURT_FROM_PHYS_KEY_FIG

      exporting I_PHYS_KEY_FIGURE = lstr_PhysKeyfig
      importing E_ZXF_CURRT       = l_ZXF_CURRT
                E_SUBRC           = l_subrc.

    if sy-subrc <> 0.
*     359: Record '&' Currency Type couldn't be derived from keyfigure '&'.
      ADD_REC_MSG 'W' '359' '0' lstr_PhysKeyfig '' ''.
      RETURN.
    endif.

*   Add the Currency type
    assign component 'ZXF_CURT' of structure <wa_target> to <LF_DST>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.    endif.
      ADD_REC_MSG 'E' '305' 'ZXF_CURT' '' '' ''.
      RETURN.
    endif.
    <LF_DST> = l_ZXF_CURRT.
    clear l_ZXF_CURRT.
    if <LF_DST> is assigned. unassign <LF_DST>. endif.

*   Either add the VALUE FIELD or the PERIODIC KEYFIGURES
    loop at MTH_HEAD_TO_DIM_KYFS
      assigning <ls_head_to_dim_kyfs>.

*     ------------------------------------------------------------------------
*     - Value field:
*     - 0CALMONTH2 must be in the charcteristics (!!!)
*     ------------------------------------------------------------------------
      if <ls_head_to_dim_kyfs>-HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-KFYVAL.

        call method me->COPY_FIELD_FROM_SRC_TO_DST

          exporting I_FLDNM_SRC = <ls_head_to_dim_kyfs>-FIELDNM_SRC  "<<<<
                    I_FLDNM_DST = lstr_PhysKeyfig                    "<<<<
                    I_S_SOURCE  = <ls_source>
                    I_R_MSG     = I_R_MSG
          importing E_R_FLD_SRC = lref_src
                    E_R_FLD_DST = lref_dst
                    E_S_TARGET  = <wa_target>
                    E_SUBRC     = l_subrc.
        if l_subrc <> 0.
          RETURN.
        endif.

        clear: lref_src, lref_dst.

*     ------------------------------------------------------------------------
*     - Periodic value field
*     - Copy the Scaling factor along with the keyfigure
*     - Enhance the record by the period information. The source record should NOT have 0CALMONTH2 !
*     ------------------------------------------------------------------------
      elseif <ls_head_to_dim_kyfs>-HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-KFYMON.

        call method me->COPY_FIELD_FROM_SRC_TO_DST

          exporting I_FLDNM_SRC = <ls_head_to_dim_kyfs>-FIELDNM_SRC  "<<<<
                    I_FLDNM_DST = lstr_PhysKeyfig                    "<<<<
                    I_S_SOURCE  = <ls_source>
                    I_R_MSG     = I_R_MSG
          importing E_R_FLD_SRC = lref_src
                    E_R_FLD_DST = lref_dst
                    E_S_TARGET  = <wa_target>
                    E_SUBRC     = l_subrc.
        if l_subrc <> 0.
          RETURN.
        endif.

        clear: lref_src, lref_dst.

        assign component '0CALMONTH2' of structure <wa_target>  to <LF_DST>.
        if sy-subrc <> 0.
*         msg
      check 1 = 0.   "rs_c_false.
        endif.
        <LF_DST> = <ls_head_to_dim_kyfs>-KFY_MONTH.    "Period information equals "Dimension"

        unassign: <LF_DST>.

      endif. "HEADER_SUBTYPE

      append <wa_target> to E_T_TARGET.

    endloop. "MTH_HEAD_TO_DIM_KYFS
    if <ls_head_to_dim_kyfs> is assigned. unassign <ls_head_to_dim_kyfs>. endif.

  endloop. "E_T_SOURCE
  if  <ls_source> is assigned. unassign  <ls_source>.  endif.
  clear <wa_target>.

  free:
    <wa_target>.                                                       "must not forget !

  clear E_SUBRC.

ENDMETHOD. "EXEC_MOVE_TO_CDM_UPLOAD


method create_cdm_data_for_validation.

  field-symbols:
    <lf_field>       type any,
    <ls_source>      type any,             "the source record as a pointer into a table, not a work area
    <wa_target>      type any,             "a record dynamically created >>work area<< !!

<lf_dst>         type any,
    <ls_head_to_dim_chas> type t_s_head_to_dim,
    <ls_head_to_dim_kyfs> type t_s_head_to_dim.

  data:
    lref_data        type ref to data,
    lref_src         type ref to data,     "Reference to the source field
    lref_dst         type ref to data,     "Reference to the destination filed

    lstr_physkeyfig   type y0xf_phys_key_figure,
    l_subrc          type sysubrc.

  field-symbols: <ls_meas_id> type y0bw_xf_meas_id.
  data: l_zxf_meas            type /bic/oizxf_meas.      " 'Measure ID'

* ----------------------------------------------------------------------------
* - Create a table for the records with chars beeing moved to CDM chars
* ----------------------------------------------------------------------------
** create data lref_data like standard table of <wa_target>.
*
*  DATA: lf_RSVIEW2 type RSVIEWTIOBJNM2.         "View: InfoObjects + Nav.Attr. with InfoObject field names(2)
*  call function 'RSD_TNAMES_GET_FOR_CUBE'
*
*      exporting I_INFOCUBE           = 'ZXF_M301'
*      importing E_VIEWTIOBJNM2       = lf_RSVIEW2.
*
*  create data lref_data type standard table of (lf_RSVIEW2).
*  assign lr_data->* to <LT_CDM_CHAS>.
*  clear: lref_data, lf_RSVIEW2.

* ----------------------------------------------------------------------------
* - Create a work area for the new record(s)
* ----------------------------------------------------------------------------
  create data lref_data like line of c_t_cdm_chas.
  assign lref_data->* to <wa_target>.
  clear lref_data.

** ----------------------------------------------------------------------------
** - Create a work area as a sample record
** ----------------------------------------------------------------------------
*  create data lref_data like line of I_T_DATA.
*  assign lref_data->* to <wa_target>.
*  clear lref_data.

  free: c_t_cdm_chas.

* ----------------------------------------------------------------------------
* - Loop at the source records (upload chars) and
* - create the "target" records (CDM chars !) for validation.
* ----------------------------------------------------------------------------
  loop at i_t_data assigning <ls_source>.

*   --------------------------------------------------------------------------
*   - Add the C H A R A C T E R I S T I C S
*   --------------------------------------------------------------------------
*   - Iterate the Column headers of type "(C)haracteristic and copy
*   - the field's value to the corresponding dimension
*   --------------------------------------------------------------------------
    clear: <wa_target>.
    loop at i_th_head_to_dim_chas assigning <ls_head_to_dim_chas>.

*     copy characteristics from upload characteristics to CDM characteristics
      call method copy_field_from_src_to_dst                       "including year and period

        exporting i_fldnm_src = <ls_head_to_dim_chas>-fieldnm_src  "<<<<
                  i_fldnm_dst = <ls_head_to_dim_chas>-fieldnm_dst  "<<<<
                  i_s_source  = <ls_source>
                  i_r_msg     = i_r_msg
        importing e_r_fld_src = lref_src
                  e_r_fld_dst = lref_dst
                  e_s_target  = <wa_target>
                  e_subrc     = l_subrc.

      if l_subrc <> 0.
        return.
      endif.
*     Identify the Measure Id
      if <ls_head_to_dim_chas>-fieldnm_dst = 'ZXF_MEAS'.

        assign component <ls_head_to_dim_chas>-fieldnm_src
          of structure <ls_source> to <lf_field>.             "ZXF_MEAS

        if sy-subrc = 0.
          l_zxf_meas = <lf_field>.
          unassign <lf_field>.
        endif.
      endif.
    endloop. "I_TH_HEAD_TO_DIM_CHAS

*   --------------------------------------------------------------------------
*   - copy the record number for the messages
*   --------------------------------------------------------------------------
    call method copy_field_from_src_to_dst                       "including year and period

      exporting i_fldnm_src = 'ZXF_RECNO'  "<<<<
                i_fldnm_dst = 'ZXF_RECNO'  "<<<<
                i_s_source  = <ls_source>
                i_r_msg     = i_r_msg
      importing e_r_fld_src = lref_src
                e_r_fld_dst = lref_dst
                e_s_target  = <wa_target>
                e_subrc     = l_subrc.

    if l_subrc <> 0.
      return.
    endif.

*    append <wa_target> to C_T_CDM_CHAS.
*    clear: <wa_target>.
    if <ls_head_to_dim_chas> is assigned. unassign <ls_head_to_dim_chas>. endif.


*  if <ls_source> is assigned. unassign <ls_source>. endif.

*  free: <wa_target>. "MUST NOT FORGET ...

*   Identify the physical keyfigure per Measure Id
    read table sth_meas_id assigning <ls_meas_id> with key measid  = l_zxf_meas
                                                           objvers = rs_c_objvers-active.

    if sy-subrc <> 0.                                          "mustn't pass validation !

*     341: Invalid master data '&' for characteristic '&'.
      add_rec_msg 'W' '341' '0' 'Measure Id' '' ''.

*     307: ERRORS OCCURRED. PROCESSING TERMINATED.
      add_msg 'W' '307' '' '' '' ''.
      return.
    endif.

*   Each Measure Id must have assigned a Keyfigure
    if <ls_meas_id>-phys_key_figure is initial.
      check 1 = 0.   "rs_c_false.
    endif.

    lstr_physkeyfig = <ls_meas_id>-phys_key_figure.
    unassign <ls_meas_id>.

*   Either add the VALUE FIELD or the PERIODIC KEYFIGURES
    loop at mth_head_to_dim_kyfs
      assigning <ls_head_to_dim_kyfs>.

*     ------------------------------------------------------------------------
*     - Value field:
*     - 0CALMONTH2 must be in the charcteristics (!!!)
*     ------------------------------------------------------------------------
      if <ls_head_to_dim_kyfs>-header_subtype = c_y0xf_header_subtype-kfyval.

        call method me->copy_field_from_src_to_dst
          exporting
            i_fldnm_src = <ls_head_to_dim_kyfs>-fieldnm_src  "<<<<
            i_fldnm_dst = lstr_physkeyfig                    "<<<<
            i_s_source  = <ls_source>
            i_r_msg     = i_r_msg
          importing
            e_r_fld_src = lref_src
            e_r_fld_dst = lref_dst
            e_s_target  = <wa_target>
            e_subrc     = l_subrc.
        if l_subrc <> 0.
          return.
        endif.

        clear: lref_src, lref_dst.

*     ------------------------------------------------------------------------
*     - Periodic value field
*     - Copy the Scaling factor along with the keyfigure
*     - Enhance the record by the period information. The source record should NOT have 0CALMONTH2 !
*     ------------------------------------------------------------------------
      elseif <ls_head_to_dim_kyfs>-header_subtype = c_y0xf_header_subtype-kfymon.

        call method me->copy_field_from_src_to_dst
          exporting
            i_fldnm_src = <ls_head_to_dim_kyfs>-fieldnm_src  "<<<<
            i_fldnm_dst = lstr_physkeyfig                    "<<<<
            i_s_source  = <ls_source>
            i_r_msg     = i_r_msg
          importing
            e_r_fld_src = lref_src
            e_r_fld_dst = lref_dst
            e_s_target  = <wa_target>
            e_subrc     = l_subrc.
        if l_subrc <> 0.
          return.
        endif.

        clear: lref_src, lref_dst.

        assign component '0CALMONTH2' of structure <wa_target>  to <lf_dst>.
        if sy-subrc <> 0.
*         msg
          check 1 = 0.   "rs_c_false.
        endif.
        <lf_dst> = <ls_head_to_dim_kyfs>-kfy_month.    "Period information equals "Dimension"

        unassign: <lf_dst>.

      endif. "HEADER_SUBTYPE


      field-symbols: <kf> type any.
      assign component <ls_head_to_dim_kyfs>-fieldnm_src of structure <ls_source> to <kf>.

      if <kf> is assigned.
        if <kf> is not initial or <kf> ne 0.
          append <wa_target> to c_t_cdm_chas.
        endif.
      endif.


    endloop. "MTH_HEAD_TO_DIM_KYFS
    if <ls_head_to_dim_kyfs> is assigned. unassign <ls_head_to_dim_kyfs>. endif.

  endloop. "E_T_SOURCE
  if  <ls_source> is assigned. unassign  <ls_source>.  endif.
  clear <wa_target>.

  free:
    <wa_target>.                                                       "must not forget !

endmethod.  "CREATE_CDM_DATA_FOR_VALIDATION


method CREATE_DATA_BY_TYPE.
* ----------------------------------------------------------------------------
* - Creates a work area according to the type description
* ----------------------------------------------------------------------------

  E_SUBRC = 8.

  translate C_S_TREATMENT_CHAS-DATATP to upper case.
  translate C_S_TREATMENT_CHAS-INTTP  to upper case.

  case C_S_TREATMENT_CHAS-INTTP.

    when 'D' OR 'F' OR 'I' OR
         'STRING'   OR 'T' OR
         'XSTRING'.

      create data     C_S_TREATMENT_CHAS-REF_VAL_INT
            type     (C_S_TREATMENT_CHAS-INTTP).

    when 'C' OR 'N' OR 'X'.

      create data     C_S_TREATMENT_CHAS-REF_VAL_INT
            type     (C_S_TREATMENT_CHAS-INTTP)
            length    C_S_TREATMENT_CHAS-INTLEN.

*   when 'P'.

*     create data     C_S_TREATMENT-REF_VAL_INT
*            type    (C_S_TREATMENT-INTTP)
*            length   C_S_TREATMENT-INTLEN.
*            decimals C_S_TREATMENT-DECIMALS.

    WHEN OTHERS.
      RETURN.

  ENDCASE.
  clear E_SUBRC.

endmethod. "CREATE_DATA_BY_TYPE


method CREATE_STATUS_RECORD.

  FIELD-SYMBOLS:
    <lf_objnm>              type RSD_S_IOBJNM,
    <lf_field>              type ANY,
    <ls_map_to_cubestruct>  type T_S_MAP_TO_CUBESTRUCT,
    <ls_charsel>            type RSPLF_S_CHARSEL.

  DATA:
    l_subrc  type SYSUBRC,
    ln_Idx   type SY-INDEX.

  E_SUBRC = 8.

* ----------------------------------------------------------------------------
* - Set the Filtervalues (SIGN = 'I'; OPT = 'EQ') for the Unique File Id
* ----------------------------------------------------------------------------
  DATA: l_ZXF_UFID  type /BIC/OIZXF_UFID,
        l_ZXF_LABEL type /BIC/OIZXF_LABEL.

  clear: l_ZXF_UFID, l_ZXF_LABEL.
  loop at I_R_UPLOAD->N_T_CHARSEL assigning <ls_charsel>.

    case <ls_charsel>-IOBJNM.

      when 'ZXF_UFID'.         l_ZXF_UFID    = <ls_charsel>-LOW.     "XF Unique File ID

      when 'ZXF_LABEL'.        if not <ls_charsel>-LOW is initial.
                                 l_ZXF_LABEL = <ls_charsel>-LOW.  "XF User defined Label for UFID
                               endif.
    endcase.
  endloop.

* The record for the Status Administration Cube
  clear C_S_STATUS.

* ----------------------------------------------------------------------------
* - Add the Constants associated with the Unique File ID to the Status Record.
* ----------------------------------------------------------------------------
  clear MS_FILEID.
  MS_FILEID-ZXF_UFID   = l_ZXF_UFID.
  MS_FILEID-ZXF_LABEL  = l_ZXF_LABEL.
  MS_FILEID-ZXF_STAT   = I_ZXF_STAT.                  "Will be changed by validation
  MS_FILEID-ZXF_DSF    = C_ZXF_DSF-FILEUPLOAD.
  MS_FILEID-0TCTSYSID  = C_0TCTSYSID_RBD777.   "BW System "RBD777" for all Systems !!!

  MS_FILEID-ZXF_UPLBY  = MS_FILEID-ZXF_LEDBY = SY-UNAME.
  MS_FILEID-ZXF_UPLD   = MS_FILEID-ZXF_LEDD  = SY-DATUM.
  MS_FILEID-ZXF_UPLT   = MS_FILEID-ZXF_LEDT  = SY-UZEIT.

  MS_FILEID-ZXF_NFILE  = 1.
  MS_FILEID-0TCTNUMREC = MN_RECNO.

  clear l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = C_S_STATUS
                                                E_SUBRC     = l_subrc.

  if l_subrc <> 0.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Add the infoprovider and statistic values to the status record
* ----------------------------------------------------------------------------
* - Set the Target Infoprovider (RB Upload Framework - Status Administration)
* - Set the status
* - Keyfigure: Number Files in the view (for reporting, value = 1)
* - Keyfigure: Number records in the file
* ----------------------------------------------------------------------------
  assign component '0INFOPROV'  of structure C_S_STATUS to <lf_field>.
  if sy-subrc = 0.
    <lf_field> = C_CUBE-STATUS_ADMIN.
    unassign <lf_field>.
  endif.

* ----------------------------------------------------------------------------
* - Add the descriptive information for characteristics  a n d  keyfigures
*   to the Status Record
* ----------------------------------------------------------------------------
* - Loop at the characteristics and keyfigures, which are Parameters in the
* - Planning function and look up these characteristics and keyfigures in the
* - record. Then add the description for these characteristics and keyfigures.
* ----------------------------------------------------------------------------
  DATA:
    ln_Offset(2) type N,
    lstr_kfydescr(C_FIELDNAME_LEN) type c.

  ln_Idx = 1.
  loop at I_R_UPLOAD->N_T_IOBJNM assigning <lf_objnm>.

    read table MT_MAP_TO_CUBESTRUCT
      index ln_IDx
      assigning <ls_map_to_cubestruct>.

    if sy-subrc <> 0.                                                 "The structure contains all characteristics
*    "msg                                                             "and all keyfigures !
      RETURN.
    endif.

*   C H A R A C T E R I S T I C
    if <ls_map_to_cubestruct>-HEADER_TYPE = C_Y0XF_HEADER_TYPE-CHAS or
       <ls_map_to_cubestruct>-HEADER_TYPE = C_Y0XF_HEADER_TYPE-XXXX.   "store invalid header

      assign component <lf_objnm> of structure C_S_STATUS to <lf_field>. if sy-subrc <> 0. return. endif. "msg

      <lf_field> = <ls_map_to_cubestruct>-COL_HEADER.

*   K E Y F I G U R E
    elseif <ls_map_to_cubestruct>-HEADER_TYPE = C_Y0XF_HEADER_TYPE-KYFS.

*     ZXF_KYF01 => ZXF_CHA41                                         "MAP KEYFIGURE TO CHARACTERISTIC
*                                                                    "DESCRIBING THE KEYFIGURE
      lstr_kfydescr = C_FIELDNAME_PREAFIX-CHAS.
      ln_Offset = <lf_objnm>+C_FIELDNAME_PREAFIX-LEN(2) + CN_MAX_CHAS.
      lstr_kfydescr+C_FIELDNAME_PREAFIX-LEN(2) =  ln_Offset.

      assign component lstr_kfydescr of structure C_S_STATUS to <lf_field>. if sy-subrc <> 0. return. endif. "msg
      <lf_field> = <ls_map_to_cubestruct>-COL_HEADER.



*   U N U S E D  C H A R A C T E R I S T I C  O R  K E Y F I G U R E
    else.                                                          "Most likeley not all characteristics (40)
                                                                   "and probably not all keyfigures (12+1) will be used,
                                                                   "so that the look up into the mapping structure will
                                                                   "fail for the unused characteristics and keyfigures
      .
    endif.
    unassign: <ls_map_to_cubestruct>, <lf_field>.

    ln_Idx = ln_Idx + 1.
  endloop.  "I_R_UPLOAD->N_T_IOBJNM

  clear E_SUBRC.

endmethod. "CREATE_STATUS_RECORD


METHOD EXEC_CANCEL_STEP1.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube, must either be
* - "VALID FILE" or "INVALID FILE".
* - Deletes the Records in either the Generic Upload Cube or the CDM Upload Cube.
* - Updates the Status to "CANCELLED".
* ----------------------------------------------------------------------------
* - STEP 1 Delete Content of CDM Upload Cube                        ZXF_A301
* - STEP 2 Delete Content of Generic Update Cube and update Status  ZXF_A303
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,
    <LF_FIEL2>       type ANY,

    <ls_char_sel>    type RSPLF_S_CHARSEL,

*   <lwa_data>       type ANY,             "WORK AREA, not a pointer
*                                          "pointer into C_TH_DATA !!
    <lwa_status>     type ANY,             "WORK AREA, not a pointer
                                           "pointer into C_TH_DATA !!
*   <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area
    <ls_source>      type ANY,             "the source record as a pointer into a table, not a work area
    <ls_target>      type ANY,             "the source record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    l_ZXF_UFID       type /BIC/OIZXF_UFID,
    lref_data        type REF TO DATA.


* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
* create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.   clear lref_data.  "Status record
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_status>. clear lref_data.  "Status record

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike    "<<<<< ONLY !!!!
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Read the unique File Id from the filter
* ----------------------------------------------------------------------------
  clear l_ZXF_UFID.
  loop at MT_DATA_CHARSEL
    assigning <ls_char_sel>
    where IOBJNM = 'ZXF_UFID'.

*   --------------------------------------------------------------------------
*   - Read the status record from the status cube by Unique File Id
*   --------------------------------------------------------------------------
    clear: l_subrc, <lwa_status>.
    l_ZXF_UFID = <ls_char_sel>-LOW.
    call function 'Y0BW_XF_UP_READ_STATUS_CUBE'

        exporting I_ZXF_UFID       = l_ZXF_UFID
        importing E_S_STATUS       = <lwa_status>
                  E_SUBRC          = l_subrc.

    if <lwa_status> is initial.          "l_subrc <> 0.
      CONTINUE.
    endif.

    EXIT.   "exit loop.

  endloop.
  if sy-subrc <> 0.
*   468: EXEC_CANCEL: The Unique File Id could not be read from Filter.
    ADD_MSG 'E' '468' '' '' '' ''.
    RETURN.
  endif.

  if l_ZXF_UFID is initial.
*   468: EXEC_CANCEL: The Unique File Id could not be read from Filter.
    ADD_MSG 'E' '468' '' '' '' ''.
    RETURN.
  endif.

  if <lwa_status> is initial.
*   468: EXEC_CANCEL: The Unique File Id could not be read from Filter.
    ADD_MSG 'E' '468' '' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill FILE ID from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <lwa_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status "VALID FILE, INVALID FILE"
* --------------------------------------------------------------------------
  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE   and
     MS_FILEID-ZXF_STAT <> C_ZXF_STAT-INVALID_FILE.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Valid File / Invalid File' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Return an error message in case no source records (Generic Upload Cube)
* - and no target records (CDM Upload Cube) have been provided in order to
* - prevent the planning sequence from executing subsequent steps.
* ----------------------------------------------------------------------------
***  it can no longer be assumed, that data is provided !!!
***  read table <LT_SOURCE> index 1 transporting no fields.
***  if sy-subrc <> 0.
***    read table <LT_TARGET> index 1 transporting no fields.
***    if sy-subrc <> 0.
****     421: No records provided by either Generic/CDM Upload Cube. STOP CANCEL.
***      ADD_MSG 'E' '421' '' '' '' ''.
***      RETURN.
***    endif.
***  endif.

* ----------------------------------------------------------------------------
* - Delete Records in CDM Upload Cube (s) (VALID FILE)
* ----------------------------------------------------------------------------
  loop at <LT_TARGET> assigning <ls_target>.
    assign component 'ZXF_UFID' of structure <ls_target> to <LF_FIELD>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.
      ADD_MSG 'E' '305' 'ZXF_UFID' '' '' ''.
      RETURN.
    endif.
    if <LF_FIELD> <> MS_FILEID-ZXF_UFID.
      assign component '0INFOPROV' of structure <ls_target> to <LF_FIEL2>.
      if sy-subrc <> 0.
*       305: Field Symbol '&' couldn't be assigned.
        ADD_MSG 'E' '305' '0INFOPROV' '' '' ''.
        RETURN.
      endif.
*     422: Unique File ID '&' different from Status Record '&'.
      ADD_MSG 'E' '422' <LF_FIELD>
                        MS_FILEID-ZXF_UFID <LF_FIEL2> ''.
      RETURN.
    endif.
  endloop.
  if <ls_target> is assigned. unassign <ls_target>. endif.

  free: <LT_TARGET>.    " <<<<< ONLY EFEFCT OF EXEC_CANCEL_STEP1 !

**** ----------------------------------------------------------------------------
**** - Update FILE ID
**** ----------------------------------------------------------------------------
**** Status
***  MS_FILEID-ZXF_STAT      = C_ZXF_STAT-CANCELLED.            "Generic File Upload Status
***  MS_FILEID-ZXF_CANBY     = MS_FILEID-ZXF_LEDBY = SY-UNAME.  "Cancelled by
***  MS_FILEID-ZXF_CAND      = MS_FILEID-ZXF_LEDD  = SY-DATUM.  "Cancelled Date
***  MS_FILEID-ZXF_CANT      = MS_FILEID-ZXF_LEDT  = SY-UZEIT.  "Cancelled Time
***
**** ----------------------------------------------------------------------------
**** - Update Status Record
**** ----------------------------------------------------------------------------
***  clear <lwa_data>.
***  <lwa_data> = <ls_status>.
***
***  clear: l_subrc.
***  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
***                                                I_R_MSG     = I_R_MSG
***                                      importing E_S_STATUS  = <lwa_data>
***                                                E_SUBRC     = l_subrc.
***  if l_subrc <> 0.
****   389: Internal error: '&'.
***    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
***    RETURN.
***  endif.

*** unassign <ls_status>.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

* insert          <lwa_status>  into table C_TH_DATA. " Status record will be updated in Step 2
  insert lines of <LT_SOURCE>   into table C_TH_DATA.
  insert lines of <LT_TARGET>   into table C_TH_DATA.  " <<<<<
  insert lines of <LT_RECMSG>   into table C_TH_DATA.
  insert lines of <LT_OTHERS>   into table C_TH_DATA.

  free:
    <lwa_status>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.

ENDMETHOD. "EXEC_CANCEL


METHOD EXEC_CANCEL_STEP2.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube, must either be
* - "VALID FILE" or "INVALID FILE".
* - Deletes the Records in either the Generic Upload Cube or the CDM Upload Cube.
* - Updates the Status to "CANCELLED".
* ----------------------------------------------------------------------------
* - STEP 1 Delete Content of CDM Upload Cube                        ZXF_A301
* - STEP 2 Delete Content of Generic Update Cube and update Status  ZXF_A303
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,
    <LF_FIEL2>       type ANY,

    <lwa_data>       type ANY,             "WORK AREA, not a pointer
                                           "pointer into C_TH_DATA !!
    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area
    <ls_source>      type ANY,             "the source record as a pointer into a table, not a work area
    <ls_target>      type ANY,             "the source record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA.


* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.  clear lref_data.  "Status record

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike   " empty !!!
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status>.
  if sy-subrc <> 0.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Valid File / Invalid File' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the FILE ID from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status "VALID FILE, INVALID FILE"
* --------------------------------------------------------------------------
  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE   and
     MS_FILEID-ZXF_STAT <> C_ZXF_STAT-INVALID_FILE.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Valid File / Invalid File' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Return an error message in case no source records (Generic Upload Cube)
* - and no target records (CDM Upload Cube) have been provided in order to
* - prevent the planning sequence from executing subsequent steps.
* ----------------------------------------------------------------------------
***  it can no longer be assumed, that data is provided !!!
***  read table <LT_SOURCE> index 1 transporting no fields.
***  if sy-subrc <> 0.
***    read table <LT_TARGET> index 1 transporting no fields.
***    if sy-subrc <> 0.
****     421: No records provided by either Generic/CDM Upload Cube. STOP CANCEL.
***      ADD_MSG 'E' '421' '' '' '' ''.
***      RETURN.
***    endif.
***  endif.


* ----------------------------------------------------------------------------
* - Delete Records in Gerneric Upload Cube (INVALID FILE)
* ----------------------------------------------------------------------------
  loop at <LT_SOURCE> assigning <ls_source>.
    assign component 'ZXF_UFID' of structure <ls_source> to <LF_FIELD>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.
      ADD_MSG 'E' '305' 'ZXF_UFID' '' '' ''.
      RETURN.
    endif.
    if <LF_FIELD> <> MS_FILEID-ZXF_UFID.
      assign component '0INFOPROV'   of structure <ls_source> to <LF_FIEL2>.
      if sy-subrc <> 0.
*       305: Field Symbol '&' couldn't be assigned.
        ADD_MSG 'E' '305' '0INFOPROV' '' '' ''.
        RETURN.
      endif.
*     422: Unique File ID '&' different from Status Record '&'.
      ADD_MSG 'E' '422' <LF_FIELD>
                        MS_FILEID-ZXF_UFID <LF_FIEL2> ''.
      RETURN.
    endif.
  endloop.
  if <ls_source> is assigned. unassign <ls_source>. endif.

  free: <LT_SOURCE>.    " <<<<< delete generic upload cube

**** ----------------------------------------------------------------------------
**** - Delete Records in CDM Upload Cube (s) (VALID FILE)
**** ----------------------------------------------------------------------------
***  loop at <LT_TARGET> assigning <ls_target>.
***    assign component 'ZXF_UFID' of structure <ls_target> to <LF_FIELD>.
***    if sy-subrc <> 0.
****     305: Field Symbol '&' couldn't be assigned.
***      ADD_MSG 'E' '305' 'ZXF_UFID' '' '' ''.
***      RETURN.
***    endif.
***    if <LF_FIELD> <> MS_FILEID-ZXF_UFID.
***      assign component '0INFOPROV' of structure <ls_target> to <LF_FIEL2>.
***      if sy-subrc <> 0.
****       305: Field Symbol '&' couldn't be assigned.
***        ADD_MSG 'E' '305' '0INFOPROV' '' '' ''.
***        RETURN.
***      endif.
****     422: Unique File ID '&' different from Status Record '&'.
***      ADD_MSG 'E' '422' <LF_FIELD>
***                        MS_FILEID-ZXF_UFID <LF_FIEL2> ''.
***      RETURN.
***    endif.
***  endloop.
***  if <ls_target> is assigned. unassign <ls_target>. endif.
***
***  free: <LT_TARGET>.

* ----------------------------------------------------------------------------
* - Update FILE ID
* ----------------------------------------------------------------------------
* Status
  MS_FILEID-ZXF_STAT      = C_ZXF_STAT-CANCELLED.            "Generic File Upload Status
  MS_FILEID-ZXF_CANBY     = MS_FILEID-ZXF_LEDBY = SY-UNAME.  "Cancelled by
  MS_FILEID-ZXF_CAND      = MS_FILEID-ZXF_LEDD  = SY-DATUM.  "Cancelled Date
  MS_FILEID-ZXF_CANT      = MS_FILEID-ZXF_LEDT  = SY-UZEIT.  "Cancelled Time

* ----------------------------------------------------------------------------
* - Update Status Record
* ----------------------------------------------------------------------------
  clear <lwa_data>.
  <lwa_data> = <ls_status>.

  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data>
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

  unassign <ls_status>.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert          <lwa_data>  into table C_TH_DATA.
  insert lines of <LT_SOURCE> into table C_TH_DATA.
  insert lines of <LT_TARGET> into table C_TH_DATA.
  insert lines of <LT_RECMSG> into table C_TH_DATA.
  insert lines of <LT_OTHERS> into table C_TH_DATA.

  free:
    <lwa_data>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.

ENDMETHOD. "EXEC_CANCEL


METHOD EXEC_COPY_TO_CDM.
* ----------------------------------------------------------------------------
* - Read the unique File Id from the filter.
* - Read the status record from the status cube by Unique File Id (VALID_FILE)
* - Read the file's content from the Upload Cube per API call
*   RSDRI_INFOPROV_READ and provide it in <LT_SOURCE>.
* - Creates each record from the Upload Cube to the CDM Upload cube(s)
* -
* - N O T E:
* - A new status NO_AUTHORIZATION has been introduced. The status is set
* - b e v o r e  the copy function is called. Therefore the expected status
* - is "NO_AUTHORIZATION" instead of "VALID_FILE", although "VALID_FILE"
* - would be sufficient for further processing !
* - The status will be reset to "VALID_FILE" after the copy  function.
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,
    <lwa_status>     type ANY,             "The status record. Work area dynamically created !!!
    <lwa_source>     type ANY,             "A   source record. Work area dynamically created !!!

    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,    "Record related messages

    <ls_char_sel>    type RSPLF_S_CHARSEL.

  DATA:
    l_subrc          type SYSUBRC,
    l_ZXF_UFID       type /BIC/OIZXF_UFID,
    lref_data        type REF TO DATA.


* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* ----------------------------------------------------------------------------
* - Create a work area for the status record, source and target tables
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_status>.  clear lref_data.  "Status record
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_source>.  clear lref_data.  "Source record

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>.   clear lref_data.

* check ( C_TH_DATA is initial ).




* ----------------------------------------------------------------------------
* - Read the unique File Id from the filter
* ----------------------------------------------------------------------------

  clear l_ZXF_UFID.
  read table MT_DATA_CHARSEL
    with key IOBJNM = 'ZXF_UFID'
    assigning <ls_char_sel>.
  if sy-subrc <> 0.
*   459: EXEC_MOVE_TO_CDM: The Unique File Id could not be read from Filter.
    ADD_MSG 'E' '459' '' '' '' ''.
    RETURN.
  endif.
  l_ZXF_UFID = <ls_char_sel>-LOW.

  if l_ZXF_UFID is initial.
*   459: EXEC_MOVE_TO_CDM: The Unique File Id could not be read from Filter.
    ADD_MSG 'E' '459' '' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Read the status record from the status cube by Unique File Id (VALID_FILE)
* ----------------------------------------------------------------------------
  clear l_subrc.
  call function 'Y0BW_XF_UP_READ_STATUS_CUBE'

      exporting I_ZXF_UFID       = l_ZXF_UFID
      importing E_S_STATUS       = <lwa_status>
                E_SUBRC          = l_subrc.

  if l_subrc <> 0.
*   460: EXEC_MOVE_TO_CDM: The Status Cube could not be read for File Id '&'.
    ADD_MSG 'E' '460' l_ZXF_UFID '' '' ''.
  endif.

* ----------------------------------------------------------------------------
* - Fill the file id from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <lwa_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status "04 VALIDFILE" or "NO_AUTHORIZATION"
* --------------------------------------------------------------------------
  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE and                           "<<<< OLD !!!!
     MS_FILEID-ZXF_STAT <> C_ZXF_STAT-NO_AUTHORIZATION.                        "<<<< NEW

*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' 'Valid File/No Auth' '' '' ''.
    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
    RETURN.
  endif.




****   ----------------------------------------------------------------------------
****   - Copy Record related messages from validation
****   - into transaction data format with infoprovider information
****   - for update into the messages cube.
****   ----------------------------------------------------------------------------
***    free: MT_REC_MSG[].                                                           "Muss per API gemacht werden, da der Filter
****   475: Copy to CDM Upload Cube ..                                               "fuer die Berechtigungspruefung passend
***    ADD_MSG 'I' '475' '' '' '' ''.                                                "zu den Dateiinhalten dynamisch gesetzt wird ..
***    call method ADD_RECORD_MESSAGES                                               "Dazu passen dann die Meldungen nicht ..
***      exporting  I_S_FILEID  = MS_FILEID
***                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
***      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
***    free: MT_REC_MSG[].





* ============================================================================
* = ( B ) Build the translation tables
* ============================================================================

* --------------------------------------------------------------------------
* - Build the translation tables of type "Column header to Dimensions" for
* - C H A R A C T E R I S T I C S  and  K E Y F I G U R E S, based on the
* - status record.
* --------------------------------------------------------------------------
  clear l_subrc.
  free: MTH_HEAD_TO_DIM_CHAS,
        MTH_HEAD_TO_DIM_KYFS.

  call method BUILD_TRANSLATION_HEAD_TO_DIM

    exporting I_S_STATUS           = <lwa_status>               " <<<
              I_R_MSG              = I_R_MSG
    importing E_TH_HEAD_TO_DIM_CHAS = MTH_HEAD_TO_DIM_CHAS
              E_TH_HEAD_TO_DIM_KYFS = MTH_HEAD_TO_DIM_KYFS
              E_SUBRC              = l_subrc.

  if l_subrc <> 0.
  endif.

* ----------------------------------------------------------------------------
* - Read the file's content from the Upload Cube and provide it in <LT_SOURCE>
* ----------------------------------------------------------------------------
  clear l_subrc.
  call function 'Y0BW_XF_UP_READ_UPLOAD_CUBE'

    exporting  I_ZXF_UFID             = l_ZXF_UFID
               I_TH_HEAD_TO_DIM_CHAS  = MTH_HEAD_TO_DIM_CHAS
               I_TH_HEAD_TO_DIM_KYFS  = MTH_HEAD_TO_DIM_KYFS
    importing  E_SUBRC                = l_subrc
    tables     E_T_SOURCE             = <LT_SOURCE>
    changing   C_S_SOURCE             = <lwa_source>.

  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Mandatory Breakdown Dimensions by KPI Id -> List of Meas. Id w. Target
* --------------------------------------------------------------------------
  free:
    MTH_MEASURE_ID,
    MTH_MEID_DIM.
  clear l_subrc.
  call method me->BUILD_BREAKDOWN_MEID_DIM

    exporting I_S_FILE        = <lwa_status>    "depends on chars in file, cannot
                                                "be done during construction / initialization !
              I_T_DATA        = <LT_SOURCE>     "create list of measure id's from the file
              I_R_MSG         = I_R_MSG
    importing E_SUBRC         = l_subrc         "
              E_TH_MEASURE_ID = MTH_MEASURE_ID  "List of Measure Id's in the current File with target CUM/NCUM
              E_TH_MEAS_DIM   = MTH_MEID_DIM.   "Break-Down Characteristics (w. OPTIONAL) by Measure Id

  if l_subrc <> 0.
    RETURN.
  endif.
* ============================================================================
* = ( F ) Copy from Generic Upload Cube into CDM Upload Cube
* ============================================================================
  if MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE or                             "<<<< OLD
     MS_FILEID-ZXF_STAT = C_ZXF_STAT-NO_AUTHORIZATION.                         "<<<< NEW

    free: MT_REC_MSG.

*   Copy records from Upload Cube to CDM Upload Cube(s)
    call method COPY_TO_CDM_UPLOAD_CUBE

      exporting  I_R_MSG        = I_R_MSG
                 I_T_SOURCE     = <LT_SOURCE>
      importing  E_T_TARGET     = <LT_TARGET>.

*   ----------------------------------------------------------------------------
*   - Copy Record related messages from validation
*   - into transaction data format with infoprovider information
*   - for update into the messages cube.
*   ----------------------------------------------------------------------------
    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: MT_REC_MSG[].

  endif. "MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert lines of <LT_TARGET>    into table C_TH_DATA.
  insert lines of <LT_RECMSG>    into table C_TH_DATA.

  free: <LT_TARGET>, <LT_RECMSG>, <lwa_status>, <lwa_source>.


ENDMETHOD. "EXEC_COPY_TO_CDM







****** ----------------------------------------------------------------------------
****** - Loop at C_TH_DATA and separate status from source records
****** ----------------------------------------------------------------------------
*****  call method me->SEPARATE_SOURCE_TARGET_RECORDS
*****
*****    exporting I_TH_DATA  = C_TH_DATA
*****              I_R_MSG    = I_R_MSG
*****    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
*****              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
*****              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
*****              E_T_OTHERS = <LT_OTHERS>
*****              E_T_RECMSG = <LT_RECMSG>
*****              E_SUBRC    = l_subrc.
*****  if l_subrc <> 0.
*****    RETURN.
*****  endif.

*****
****** --------------------------------------------------------------------------
****** - Read the status record
****** --------------------------------------------------------------------------
*****  DATA ln_Lines type i.
*****  describe table <LT_STATUS> lines ln_Lines.
*****  if ln_Lines > 1.
******   302: More than one status record read.
*****    ADD_MSG 'E' '302' '' '' '' ''.
*****    RETURN.
*****  endif.
*****
*****  read table <LT_STATUS> index 1 assigning <ls_status>.
*****  if sy-subrc <> 0.
*****
******   312: No status record with appropriate status '&' could be read.
******   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
*****    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
*****    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
*****    RETURN.
*****  endif.
*****
****** ----------------------------------------------------------------------------
****** - Fill the file id from the current status record
****** ----------------------------------------------------------------------------
*****  clear: MS_FILEID, l_subrc.
*****  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
*****                                                I_R_MSG     = I_R_MSG
*****                                      importing E_S_FILEID  = MS_FILEID
*****                                                E_SUBRC     = l_subrc.
*****  if l_subrc <> 0.
*****    RETURN.
*****  endif.
*****
****** --------------------------------------------------------------------------
****** - Check the status "04 VALIDFILE"
****** --------------------------------------------------------------------------
*****  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE.
******   312: No status record with appropriate status '&' could be read.
******   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
*****    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
*****    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
*****    RETURN.
*****  endif.
*****
****** ----------------------------------------------------------------------------
****** - Return an error message in case no source records have been provided
****** - in order to prevent the planning sequence from executing subsequent steps.
****** ----------------------------------------------------------------------------
*****  read table <LT_SOURCE> index 1 transporting no fields.
*****  if sy-subrc <> 0.
******   311: No source records provided for copy! STOP subsequent steps.
*****    ADD_MSG 'E' '311' '' '' '' ''.
*****    RETURN.
*****  endif.
*****
*****



*****  ADD_MSG 'I' '999' 'Import Unique File Id' I_S_FILEID-ZXF_UFID '' ''.
*****
*****  call method ADD_RECORD_MESSAGES
*****    exporting  I_S_FILEID  = MS_FILEID
*****               I_T_REC_MSG = lt_rec_msg    "Messages from Validation
*****    changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
*****  free: lt_rec_msg[], MT_REC_MSG[].


METHOD EXEC_DELETE_FROM_UPL.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube -> UFID
* - Deletes the records from the generic upload cube, which have been copied
* - to the CDM Upload Cube bevore (in case the status equals VALID_FILE).
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
*   <LF_FIELD>       type ANY,

    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* Read current message context from preceeding process steps
  IMPORT MN_RECNO                = MN_RECNO                 "Current record number
         MN_TOT                  = MN_TOT                   "Total Number of Messages E / W / I
         MN_MSG                  = MN_MSG                   "Number of Errors/Warnings -> FlowControl !
         MN_ERR                  = MN_ERR                   "Number of Errors
         MN_WAR                  = MN_WAR                   "Number of Warnings
         MN_INF                  = MN_INF                   "Number of Informations
         MN_MSG_RECNO            = MN_MSG_RECNO             "Messages: Current Record Number
         MN_MSG_LINNO            = MN_MSG_LINNO             "Messages: Line Number for current record
         MN_MSG_LINNO_LAST_REC_0 = MN_MSG_LINNO_LAST_REC_0  "Messages: Last Line Number for record number "0" !

      FROM MEMORY "see below for import
      ID 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.


* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status>.
  if sy-subrc <> 0.

*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the file id from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status "04 VALIDFILE"
* --------------------------------------------------------------------------
  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'I' '312' 'Valid File' '' '' ''.
    RETURN.
  endif.

*   ----------------------------------------------------------------------------
*   - Copy Record related messages from validation
*   - into transaction data format with infoprovider information
*   - for update into the messages cube.
*   ----------------------------------------------------------------------------
    free: MT_REC_MSG[].
*   476: Delete from Generic Upload Cube ..
    ADD_MSG 'I' '476' '' '' '' ''.
    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: MT_REC_MSG[].


* --------------------------------------------------------------------------
* - Delete the records from the generic upload cube
* --------------------------------------------------------------------------
  if MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.

    FREE: <LT_SOURCE>.
  endif.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert lines of <LT_STATUS> into table C_TH_DATA.
  insert lines of <LT_SOURCE> into table C_TH_DATA.
  insert lines of <LT_TARGET> into table C_TH_DATA.
  insert lines of <LT_RECMSG> into table C_TH_DATA.
  insert lines of <LT_OTHERS> into table C_TH_DATA.

  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.


  delete from memory id 'ZRB_XFUFID_XFX340_CXSMN'.  "The file upload crates the new File Id,
                                                    "Copy to CDM upload Cube uses it
                                                    "Delete from Gen. Upload Cube uses it and releases it

* Provide current message context for subsequent process steps
  EXPORT MN_RECNO                = MN_RECNO                 "Current record number
         MN_TOT                  = MN_TOT                   "Total Number of Messages E / W / I
         MN_MSG                  = MN_MSG                   "Number of Errors/Warnings -> FlowControl !
         MN_ERR                  = MN_ERR                   "Number of Errors
         MN_WAR                  = MN_WAR                   "Number of Warnings
         MN_INF                  = MN_INF                   "Number of Informations
         MN_MSG_RECNO            = MN_MSG_RECNO             "Messages: Current Record Number
         MN_MSG_LINNO            = MN_MSG_LINNO             "Messages: Line Number for current record
         MN_MSG_LINNO_LAST_REC_0 = MN_MSG_LINNO_LAST_REC_0  "Messages: Last Line Number for record number "0" !

      TO MEMORY "see below for import
      ID 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.

ENDMETHOD. "EXEC_DELETE_FROM_UPL


method exec_delete_step1.
* ----------------------------------------------------------------------------
* - Identifies both File ID's, original File Id and new File Id, by comparing
* - the restrictions on the File ID provided by the filter (original and
*  - new File Id) against the selected status record (original file Id).
* - Reads the content of the given (original) File ID from the CDM Upload
* - Cubes and creates a new File Id and assigns all neccessary characteristic
* - combinations described by the status record (old File Id) to the records
* - of the new File ID with all keyfigures set to Zero, except for the technical
* - keyfigure "Number of Records".
* - The new File ID is requested for update into the reporting layer.
* - The final status will be "Submitted".
* - The status of the original File Id changes to "Deleted".
* - In order to identify the File ID deleting the original File ID, the
* - Flag "Delete" is set to "X" for the deleting File Id. Additionaly,
* - the original File ID, which was deleted by the current Fild Id is
* - registered in the Field "Related File ID".
* - The status record of the origonal File Id, which was deleted is also
* - enriched by the deleting File Id, us-ing the same Field "Related File Id".
* -
*  - ----------------+------------+----------------------------+-----------------
*  - Unique File ID  |  Delte     | Generic File Upload Status | Related File ID
*  - ZXF_UFID        |  ZXF_FDEL  | ZXF_STAT                   | ZXF_RUFID
*  - ----------------+------------+----------------------------+-----------------
*  - 4711            |  #         | DELETED                    | 4753              "MS_FILEID_REL  <ls_status_rel>
*  - 4753            |  X         | SUBMITTED                  | 4711              "MS_FILEID      <ls_status>
* ----------------------------------------------------------------------------

  field-symbols:
    <lf_field>        type any,

    <lwa_data>       type any,             "WORK AREA, not a pointer     Status record for given File Id
                                           "pointer into C_TH_DATA !!

    <lwa_data_rel>   type any,             "WORK AREA, not a pointer     Status record for related File Id (to be deleted!)
                                           "pointer into C_TH_DATA !!

*   <ls_status>      type ANY,             "the status record  as a pointer into a table, not a work area (given File Id)
    <ls_status_rel>  type any,             "the status record  as a pointer into a table, not a work area (related File Id -to be deleted!))
    <ls_target>      type any,             "the target records as a pointer into a table, not a work area

    <lt_status>      type standard table,
    <lt_source>      type standard table,
    <lt_target>      type standard table,
    <lt_recmsg>      type standard table,
    <lt_others>      type standard table,

    <lt_deleting>    type standard table,  "Records 'deleting' <LT_TARGET>; Copy of <LT_TARGET> with all keyfigures set to zero except for the <>

    <ls_char_sel>    type rsplf_s_charsel.

  data:
    l_subrc          type sysubrc,
    l_zxf_ufid       type /bic/oizxf_ufid,
    lref_data        type ref to data,
    ls_btc_header    type /bic/azxf_e30100,
    lt_btc_targets   type y0bw_xf_up_batch_targets_t.


* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record (s)
* ----------------------------------------------------------------------------
  create data lref_data like                   i_s_block_line.
  assign lref_data->* to <lwa_data_rel>.  clear lref_data.  "Status record -> DELETED
  create data lref_data like                   i_s_block_line.
  assign lref_data->* to <lwa_data>.      clear lref_data.  "Status record -> SUBMITTED

  create data lref_data like standard table of i_s_block_line.
  assign lref_data->* to <lt_status>.   clear lref_data.
  create data lref_data like standard table of i_s_block_line.
  assign lref_data->* to <lt_source>.   clear lref_data.
  create data lref_data like standard table of i_s_block_line.
  assign lref_data->* to <lt_target>.   clear lref_data.
  create data lref_data like standard table of i_s_block_line.
  assign lref_data->* to <lt_others>.   clear lref_data.
  create data lref_data like standard table of i_s_block_line.
  assign lref_data->* to <lt_recmsg>.   clear lref_data.

  create data lref_data like standard table of i_s_block_line.
  assign lref_data->* to <lt_deleting>. clear lref_data.


* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->separate_source_target_records
    exporting
      i_th_data  = c_th_data
      i_r_msg    = i_r_msg
    importing
      e_t_status = <lt_status>     "XF UP 301 Status Cube                 "Empty -> read by RSDRI_INFO_PROV_READ
      e_t_source = <lt_source>     "XF UP 302 Generic Upload Cube         "Empty -> not used
      e_t_target = <lt_target>     "XF UP 304 CDM Upload Cube, and alike
      e_t_others = <lt_others>
      e_t_recmsg = <lt_recmsg>
      e_subrc    = l_subrc.
  if l_subrc <> 0.
    return.
  endif.

* ----------------------------------------------------------------------------
* - Read the unique File Id from the filter
* ----------------------------------------------------------------------------
  clear l_zxf_ufid.
  loop at mt_data_charsel
    assigning <ls_char_sel>
    where iobjnm = 'ZXF_UFID'.

*   --------------------------------------------------------------------------
*   - Read the status record from the status cube by Unique File Id
*   --------------------------------------------------------------------------
    clear: l_subrc, <lwa_data_rel>.
    l_zxf_ufid = <ls_char_sel>-low.
    call function 'Y0BW_XF_UP_READ_STATUS_CUBE'    "File Id to be deleted

        exporting i_zxf_ufid       = l_zxf_ufid
        importing e_s_status       = <lwa_data_rel>
                  e_subrc          = l_subrc.

    if <lwa_data_rel> is initial.          "l_subrc <> 0.
      continue.
    endif.

    exit.   "exit loop.

  endloop.
  if sy-subrc <> 0.
*   462: EXEC_DELETE: The Unique File Id could not be read from Filter.
    add_msg 'E' '462' '' '' '' ''.
    return.
  endif.

  if l_zxf_ufid is initial.
*   462: EXEC_DELETE: The Unique File Id could not be read from Filter.
    add_msg 'E' '462' '' '' '' ''.
    return.
  endif.

  if <lwa_data_rel> is initial.
*   462: EXEC_DELETE: The Unique File Id could not be read from Filter.
    add_msg 'E' '462' '' '' '' ''.
    return.
  endif.

* ----------------------------------------------------------------------------
* - Fill the RELATED FILE ID from the current status record
* ----------------------------------------------------------------------------
  clear: ms_fileid_rel, l_subrc.
  call method status_get_into_fileid
    exporting
      i_s_status = <lwa_data_rel>
      i_r_msg    = i_r_msg
    importing
      e_s_fileid = ms_fileid_rel
      e_subrc    = l_subrc.
  if l_subrc <> 0.
    return.
  endif.

* --------------------------------------------------------------------------
* - Check the status "SUBMITTED"
* --------------------------------------------------------------------------
  if ms_fileid_rel-zxf_stat <> c_zxf_stat-submitted.
*   312: No status record with appropriate status '&' could be read.
    add_msg 'E' '312' 'Submitted' '' '' ''.
    return.
  endif.

* --------------------------------------------------------------------------
* - Check Flag: "Deleting Request"
* --------------------------------------------------------------------------
  if ms_fileid_rel-zxf_fdel = rs_c_true.
*   404: The File Id '&' has deleted File Id '&'. "Delete" not possible.
    add_msg 'E' '404' ms_fileid_rel-zxf_ufid
                      ms_fileid_rel-zxf_rufid '' ''.
    return.
  endif.

* ----------------------------------------------------------------------------
* - Read the FILE ID for the deleting request from the filter
* ----------------------------------------------------------------------------
  field-symbols: <ls_data_charsel> type rsplf_s_charsel.
  loop at mt_data_charsel assigning <ls_data_charsel>
    where iobjnm = 'ZXF_UFID'.

*   Skip the File Id, that shall be deleted!
    if <ls_data_charsel>-low = ms_fileid_rel-zxf_ufid.
      continue.
    endif.

*   Read the File Id for the deleting request insetad
    exit.
  endloop.

  if <ls_data_charsel>-low is initial.
*   403: The File Id for the deleting request could not be read from Filter.
    add_msg 'E' '403' '' '' '' ''.
    return.
  endif.

* ----------------------------------------------------------------------------
* - Initialize the FILE ID from the RELATED FILE ID
* ----------------------------------------------------------------------------
  clear ms_fileid.

* Unique File ID
  ms_fileid-zxf_ufid      = <ls_data_charsel>-low.         "XF Unique File ID
  ms_fileid-zxf_label     = ms_fileid_rel-zxf_label.       "XF User defined Label for UFID
  ms_fileid-zxf_ferr      = ms_fileid_rel-zxf_ferr.        "Flag: Record erroneous
  ms_fileid-zxf_fdel      = rs_c_true.                     "Flag: Delete Request
  ms_fileid-zxf_rufid     = ms_fileid_rel-zxf_ufid.

* Status
  ms_fileid-zxf_stat      = c_zxf_stat-submitreq.          "Generic File Upload Status

* Source Flag
  ms_fileid-zxf_dsf       = ms_fileid_rel-zxf_dsf.

* Statistics
  ms_fileid-0tctsysid     = ms_fileid_rel-0tctsysid.       "BW System
  ms_fileid-zxf_uplby     = sy-uname.                      "Loaded by
  ms_fileid-zxf_upld      = sy-datum.                      "Loaded Date
  ms_fileid-zxf_uplt      = sy-uzeit.                      "Loaded Time
  ms_fileid-zxf_subby     = ms_fileid-zxf_ledby = ms_fileid-zxf_uplby.  "Submitted by  / Request for Uodate into Reporting
  ms_fileid-zxf_reqd      = ms_fileid-zxf_ledd  = ms_fileid-zxf_upld.   "Requested Date
  ms_fileid-zxf_reqt      = ms_fileid-zxf_ledt  = ms_fileid-zxf_uplt.   "Requested Time
* MS_FILEID-ZXF_SUBD                                       "Submitted Date   << Batch Update Status
* MS_FILEID-ZXF_SUBT                                       "Submitted Time   << Batch Update Status
* MS_FILEID-ZXF_CANBY                                      "Cancelled by
* MS_FILEID-ZXF_CAND                                       "Cancelled Date
* MS_FILEID-ZXF_CANT                                       "Cancelled Time
* MS_FILEID-ZXF_DELBY                                      "Deleted by
* MS_FILEID-ZXF_DELD                                       "Deleted Date
* MS_FILEID-ZXF_DELT                                       "Deleted Time

* Keyfigures
  ms_fileid-zxf_nfile     = ms_fileid_rel-zxf_nfile.       "Number of Files (Counter =1)
  ms_fileid-0tctnumrec    = ms_fileid_rel-0tctnumrec.      "Number of Records
  ms_fileid-0tctrecerr    = ms_fileid_rel-0tctrecerr.      "Number of Erroneous Records

  if <ls_data_charsel> is assigned. unassign <ls_data_charsel>. endif.

* ----------------------------------------------------------------------------
* - Return an error message in case no source records have been provided
* - in order to prevent the planning sequence from executing subsequent steps.
* ----------------------------------------------------------------------------
  read table <lt_target> index 1 transporting no fields.
  if sy-subrc <> 0.
*   402: No source records provided for deletion! STOP subsequent steps.
    add_msg 'E' '402' '' '' '' ''.
    return.
  endif.

* ----------------------------------------------------------------------------
* - Loop at the file, which is to be deleted and create a list of data targets
* - depending on the Measure ID's in the file and create the deleting "Zero"
* - records with the new File ID read from the filter.
* ----------------------------------------------------------------------------
  data:
    ls_targets type y0xfu_t_s_meas_cluster,
    lt_targets type y0xfu_t_t_meas_cluster.

  free: <lt_deleting>.

  data: lcl_validations type ref to y0bw_cl_xf_vld_generic,
        lcl_msg         type ref to if_rsplfa_msg,
        lv_success      type boolean,
        lv_data         type ref to data.
  field-symbols: <lth_target> type hashed table.

  lcl_validations = y0bw_cl_xf_vld_generic=>get_instance( ).
lcl_validations->validate_datapak(
  exporting
    rbmodule = 'UP'
    i_proc_only_lockings = abap_true
    importing
    success = lv_success
      changing
      i_r_msg = i_r_msg
      c_th_data = c_th_data ).

  if lv_success <> abap_true.
    add_msg 'E' '305' 'Data is locked' '' '' ''.
    return.
  endif.


* loop at the records and create a comprehensive list of data clusters
  loop at <lt_target> assigning <ls_target>.

    assign component 'ZXF_UFID' of structure <ls_target> to <lf_field>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.
      add_msg 'E' '305' 'ZXF_UFID' '' '' ''.
      return.
    endif.

    if <lf_field> <> ms_fileid_rel-zxf_ufid.
*     382: More than one Unique File Id: '&', '&'.
      add_msg 'E' '382' ms_fileid-zxf_ufid <lf_field> '' ''.
      return.
    endif.

    assign component 'ZXF_MEAS' of structure <ls_target> to <lf_field>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.
      add_msg 'E' '305' 'ZXF_MEAS' '' '' ''.
      return.
    endif.

    clear ls_targets.
    read table sth_meas_cluster
      into ls_targets
      with key measid  = <lf_field>.

    if sy-subrc <> 0.
*     381: Measure ID '&': Assignment to data cluster not maintained.
      add_msg 'E' '381' <lf_field> '' '' ''.
      return.
    endif.

*   382: Parameter '&': '' not maintained in 'Y0BW_XF_DATA_CLS'.
    if ls_targets-data_cluster  is initial. add_msg 'E' '382' <lf_field> 'Data Cluster'           '' ''. return. endif.
    if ls_targets-src_virt_prov is initial. add_msg 'E' '382' <lf_field> 'Virtual Source Cube'    '' ''. return. endif.
    if ls_targets-source        is initial. add_msg 'E' '382' <lf_field> 'Source CDM Upload Cube' '' ''. return. endif.
    if ls_targets-target        is initial. add_msg 'E' '382' <lf_field> 'Target Changelog DSO'   '' ''. return. endif.
    if ls_targets-process_chain is initial. add_msg 'E' '382' <lf_field> 'Process Chain ID'       '' ''. return. endif.

    clear ls_targets-measid.
    collect ls_targets into lt_targets.

*   Create a copy of the record and change the File Id
    clear <lwa_data>.
    <lwa_data> = <ls_target>.

    assign component 'ZXF_UFID' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned.
      <lf_field> = ms_fileid-zxf_ufid.
      unassign <lf_field>.
    endif.
    assign component 'ZXF_AMNT' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned. clear <lf_field>. unassign <lf_field>. endif.
    assign component 'ZXF_NUMB' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned. clear <lf_field>. unassign <lf_field>. endif.
    assign component 'ZXF_QUAN' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned. clear <lf_field>. unassign <lf_field>. endif.
    assign component 'ZXF_AMNF' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned. clear <lf_field>. unassign <lf_field>. endif.
    assign component 'ZXF_NUMF' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned. clear <lf_field>. unassign <lf_field>. endif.
    assign component 'ZXF_QUAF' of structure <lwa_data> to <lf_field>.
    if <lf_field> is assigned. clear <lf_field>. unassign <lf_field>. endif.
*   assign component 'ZXF_RCNT' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.  "ZRBZERO !
*   assign component 'ZXF_FCTR' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
*   assign component 'ZXF_INTE' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.  "deleted
*   assign component 'ZXF_FLTP' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.  "deleted

    append <lwa_data> to <lt_deleting>.
  endloop.

  append lines of <lt_deleting> to <lt_target>.
  free: <lt_deleting>.
  clear <lwa_data>.

  if <ls_target> is assigned. unassign <ls_target>. endif.
  if <lf_field>  is assigned. unassign <lf_field>.  endif.
  clear: ls_targets.

* ----------------------------------------------------------------------------
* - Update RELATED FILE ID
* ----------------------------------------------------------------------------
  ms_fileid_rel-zxf_stat  = c_zxf_stat-deletereq."Delete Requested
  ms_fileid_rel-zxf_rufid = ms_fileid-zxf_ufid.
  ms_fileid_rel-zxf_delby = ms_fileid_rel-zxf_ledby = ms_fileid-zxf_subby.           "Submitted/Requested for Update by
  ms_fileid_rel-zxf_drqd  = ms_fileid_rel-zxf_ledd  = ms_fileid-zxf_reqd.            "Date and Time: Request for Update
  ms_fileid_rel-zxf_drqt  = ms_fileid_rel-zxf_ledt  = ms_fileid-zxf_reqt.
* MS_FILEID_REL-ZXF_DELD  = MS_FILEID-ZXF_REQD.            "Batch Update Status
* MS_FILEID_REL-ZXF_DELT  = MS_FILEID-ZXF_REQT.

* ----------------------------------------------------------------------------
* - Create a new request for update into the reporting layer (Deleting Req.)
* ----------------------------------------------------------------------------
  clear ls_btc_header.
  ls_btc_header-/bic/zxf_ufid   = ms_fileid-zxf_ufid.
  ls_btc_header-/bic/zxf_label  = ms_fileid-zxf_label.
  ls_btc_header-/bic/zxf_dsf    = ms_fileid-zxf_dsf.
  ls_btc_header-/bic/zxf_reqby  = ms_fileid-zxf_subby.
  ls_btc_header-/bic/zxf_reqd   = ms_fileid-zxf_reqd.
  ls_btc_header-/bic/zxf_reqt   = ms_fileid-zxf_reqt.
  ls_btc_header-/bic/zxf_rufid  = ms_fileid-zxf_rufid.
  ls_btc_header-/bic/zxf_fdel   = ms_fileid-zxf_fdel.

  clear l_subrc.
  free: lt_btc_targets.

* call method l_oref_batch->CREATE_NEW_REQUEST
  call method y0bw_cl_xf_up_batch_ctrl=>create_new_request
    exporting
      i_t_data_cluster         = lt_targets                "XF UP: Data Cluster (Source/Target/Process Chain)
    importing
      e_t_btc_targets          = lt_btc_targets
    changing
      c_s_btc_header           = ls_btc_header             "XF UP D301 Batch Control Table, Header ( Direct Update )
    exceptions
      parameter_empty          = 1
      enqueue_failed           = 2
      ufid_already_in_use      = 3
      dso_insert_header_failed = 4
      dso_insert_dclust_failed = 5
      others                   = 6.

* 388: Request for Update into Rep. Layer failed: '&'.
  case sy-subrc.
    when 0. .
    when 1. add_msg 'E' '388' 'PARAMETER_EMPTY'          '' '' ''. return.
    when 2. add_msg 'E' '388' 'ENQUEUE_FAILED'           '' '' ''. return.
    when 3. add_msg 'E' '388' 'UFID_ALREADY_IN_USE'      '' '' ''. return.
    when 4. add_msg 'E' '388' 'DSO_INSERT_HEADER_FAILED' '' '' ''. return.
    when 5. add_msg 'E' '388' 'DSO_INSERT_DCLUST_FAILED' '' '' ''. return.
    when 6. add_msg 'E' '388' 'OTHERS'                   '' '' ''. return.
  endcase.

  clear ls_btc_header.
  free: lt_targets, lt_btc_targets.

* ----------------------------------------------------------------------------
* - "Update Related Status Record" and
* - "Create Status Record from Related Status Record"
* - have been moved to "Step 2"
* ----------------------------------------------------------------------------


* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: c_th_data[].


  insert lines of <lt_status>     into table c_th_data. "Empty !
  insert lines of <lt_source>     into table c_th_data. "Empty !
  insert lines of <lt_target>     into table c_th_data.
  insert lines of <lt_recmsg>     into table c_th_data.
  insert lines of <lt_others>     into table c_th_data.

  free:
    <lwa_data>, <lwa_data_rel>.
  free:
    <lt_status>, <lt_source>, <lt_target>, <lt_recmsg>, <lt_others>, <lt_deleting>.


  export zrb_xfufid_xfx340_cxsmn = ms_fileid-zxf_ufid
      to memory id 'ZRB_XFUFID_XFX340_CXSMN'.
  if sy-subrc = 0.
  endif.

  _ss_fileid     = ms_fileid.
  _ss_fileid_rel = ms_fileid_rel.



endmethod. "EXEC_DELETE


METHOD EXEC_DELETE_STEP2.
* ----------------------------------------------------------------------------
* - Identifies both File ID's, original File Id and new File Id, by comparing
* - the restrictions on the File ID provided by the filter (original and
*  - new File Id) against the selected status record (original file Id).
* - Reads the content of the given (original) File ID from the CDM Upload
* - Cubes and creates a new File Id and assigns all neccessary characteristic
* - combinations described by the status record (old File Id) to the records
* - of the new File ID with all keyfigures set to Zero, except for the technical
* - keyfigure "Number of Records".
* - The new File ID is requested for update into the reporting layer.
* - The final status will be "Submitted".
* - The status of the original File Id changes to "Deleted".
* - In order to identify the File ID deleting the original File ID, the
* - Flag "Delete" is set to "X" for the deleting File Id. Additionaly,
* - the original File ID, which was deleted by the current Fild Id is
* - registered in the Field "Related File ID".
* - The status record of the origonal File Id, which was deleted is also
* - enriched by the deleting File Id, us-ing the same Field "Related File Id".
* -
*  - ----------------+------------+----------------------------+-----------------
*  - Unique File ID  |  Delte     | Generic File Upload Status | Related File ID
*  - ZXF_UFID        |  ZXF_FDEL  | ZXF_STAT                   | ZXF_RUFID
*  - ----------------+------------+----------------------------+-----------------
*  - 4711            |  #         | DELETED                    | 4753              "MS_FILEID_REL  <ls_status_rel>
*  - 4753            |  X         | SUBMITTED                  | 4711              "MS_FILEID      <ls_status>
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>        type ANY,

    <lwa_data>       type ANY,             "WORK AREA, not a pointer     Status record for given File Id
                                           "pointer into C_TH_DATA !!

    <lwa_data_rel>   type ANY,             "WORK AREA, not a pointer     Status record for related File Id (to be deleted!)
                                           "pointer into C_TH_DATA !!

*   <ls_status>      type ANY,             "the status record  as a pointer into a table, not a work area (given File Id)
    <ls_status_rel>  type ANY,             "the status record  as a pointer into a table, not a work area (related File Id -to be deleted!))
    <ls_target>      type ANY,             "the target records as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE,

    <LT_DELETING>    type STANDARD TABLE,  "Records 'deleting' <LT_TARGET>; Copy of <LT_TARGET> with all keyfigures set to zero except for the <>

    <ls_char_sel>    type RSPLF_S_CHARSEL.

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA,
    ls_btc_header    type /BIC/AZXF_E30100,
    lt_btc_targets   type Y0BW_XF_UP_BATCH_TARGETS_T.


* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================


* ----------------------------------------------------------------------------
* - Create a work area for the resulting record (s)
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data_rel>.  clear lref_data.  "Status record -> DELETED
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.      clear lref_data.  "Status record -> SUBMITTED

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>.   clear lref_data.

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_DELETING>. clear lref_data.


  MS_FILEID     = _SS_FILEID.     clear _SS_FILEID.       "Deleting File Id (File with all Keyfigures set to Zero)
  MS_FILEID_REL = _SS_FILEID_REL. clear _SS_FILEID_REL.   "To be deleted

  delete from memory id 'ZRB_XFUFID_XFX340_CXSMN'.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  clear <lwa_data_rel>.
  read table <LT_STATUS> index 1 into <lwa_data_rel>.
  if sy-subrc <> 0.

*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
    RETURN.
  endif.

  assign component 'ZXF_UFID' of structure <lwa_data_rel> to <LF_FIELD>.
  if SY-SUBRC = 0.

    if MS_FILEID_REL-ZXF_UFID <> <LF_FIELD>.

*     464: File Id '&' from Status Record does not match File Id '&' passed.
      ADD_MSG 'E' '404' MS_FILEID_REL-ZXF_UFID <LF_FIELD>'' ''.
    endif.
  endif.
  if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

** --------------------------------------------------------------------------
** - Check the status "SUBMITTED"
** --------------------------------------------------------------------------
*  if MS_FILEID_REL-ZXF_STAT <> C_ZXF_STAT-SUBMITTED.
**   312: No status record with appropriate status '&' could be read.
*    ADD_MSG 'E' '312' 'Submitted' '' '' ''.
*    RETURN.
*  endif.

  assign component 'ZXF_STAT' of structure <lwa_data_rel> to <LF_FIELD>.
  if SY-SUBRC = 0.

    if <LF_FIELD> <> C_ZXF_STAT-SUBMITTED.
*     312: No status record with appropriate status '&' could be read.
      ADD_MSG 'E' '312' 'Submitted' '' '' ''.
      RETURN.
    endif.
  endif.
  if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

* --------------------------------------------------------------------------
* - Check Flag: "Deleting Request"
* --------------------------------------------------------------------------
  if MS_FILEID_REL-ZXF_FDEL = rs_c_true.
*   404: The File Id '&' has deleted File Id '&'. "Delete" not possible.
    ADD_MSG 'E' '404' MS_FILEID_REL-ZXF_UFID
                      MS_FILEID_REL-ZXF_RUFID '' ''.
    RETURN.
  endif.


* ----------------------------------------------------------------------------
* - Update Related Status Record
* ----------------------------------------------------------------------------
  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID_REL
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data_rel>
                                                E_SUBRC     = l_subrc.

  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Create Status Record from Related Status Record
* ----------------------------------------------------------------------------
  clear <lwa_data>.
  <lwa_data> = <lwa_data_rel>.

  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data>
                                                E_SUBRC     = l_subrc.

  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert          <lwa_data>      into table C_TH_DATA.
  insert          <lwa_data_rel>  into table C_TH_DATA.
  insert lines of <LT_SOURCE>     into table C_TH_DATA.  "Empty
  insert lines of <LT_TARGET>     into table C_TH_DATA.  "Empty
  insert lines of <LT_RECMSG>     into table C_TH_DATA.  "Empty
  insert lines of <LT_OTHERS>     into table C_TH_DATA.  "Empty

  free:
    <lwa_data>, <lwa_data_rel>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>, <LT_DELETING>.

* ----------------------------------------------------------------------------
* - Start Job
* ----------------------------------------------------------------------------
*  DATA: lf_logid type RSPC_LOGID.
*  CALL FUNCTION 'RSPC_API_CHAIN_START'
*    EXPORTING
*      I_CHAIN             = 'ZXF_WW_A_00_TD00'
*      I_DONT_WAIT         = rs_c_true
*    IMPORTING
*     E_LOGID             = lf_logid
*     EXCEPTIONS
*       FAILED              = 1
*       OTHERS              = 2.

* ----------------------------------------------------------------------------
* - Start Job ( 4 ) FuBa (wird vom Programm benutzt)
* ----------------------------------------------------------------------------
  DATA:
    l_ZXF_UFID         type  /BIC/OIZXF_UFID,
    l_ZXF_RUND         type  /BIC/OIZXF_RUND,
    l_ZXF_RUNT         type  /BIC/OIZXF_RUNT,
    ls_BATCH_HEADER    type  /BIC/AZXF_E30100,
    lt_BATCH_TARGETS   type  Y0BW_XF_UP_BATCH_TARGETS_T.

* Start Job
  clear: l_ZXF_UFID, ls_BATCH_HEADER.
  free: lt_BATCH_TARGETS.

* Start Job
  CALL FUNCTION 'Y0BW_XF_UP_START_JOB'
    IMPORTING
      E_ZXF_UFID                     = l_ZXF_UFID
      E_ZXF_RUND                     = l_ZXF_RUND
      E_ZXF_RUNT                     = l_ZXF_RUNT
      E_S_BATCH_HEADER               = ls_BATCH_HEADER
      E_T_BATCH_TARGETS              = lt_BATCH_TARGETS
    EXCEPTIONS
*     JOB_STARTED                    = 0     "OK
      ENQUEUE_FAILED                 = 1     "Failed to start a job due to lock issues !!!!!
      STILL_ACTIVE                   = 2     "OK
      NO_MORE_REQUESTS               = 3     "OK (a terminated job started the job once again)
      NO_DATA_CLUSTER                = 4     "Failed to start a job for Update into Reporting !!!!!
      DSO_UPDATE_HEADER_FAILED       = 5     "Failed to start a job for Update into Reporting !!!!!
      DSO_UPDATE_DCLUST_FAILED       = 6     "Failed to start a job for Update into Reporting !!!!!
      START_CHAIN_FAILED             = 7     "Failed to Start Process Chain
      OTHERS                         = 8.

* l_ZXF_UFID = MS_FILEID-ZXF_UFID ?

  case sy-subrc.

*   395: Job Started for Update into Reporting.
    when 0.                                                          "JOB_STARTED
      ADD_MSG 'I' '395' '' '' '' ''.

*   396: Job for Update into Reporting still active. Wait.
    when 2.                                                          "STILL_ACTIVE
      ADD_MSG 'I' '396' '' '' '' ''.

*   397: Job for Update into Reporting already processed.
    when 3.                                                          "NO_MORE_REQUESTS
      ADD_MSG 'I' '397' '' '' '' ''.

*   398: Failed to start a job for Update into Reporting '&'.
    WHEN 1. ADD_MSG 'W' '398' 'ENQUEUE_FAILED'           '' '' ''.
    WHEN 4. ADD_MSG 'W' '398' 'NO_DATA_CLUSTER'          '' '' ''.
    WHEN 5. ADD_MSG 'W' '398' 'DSO_UPDATE_HEADER_FAILED' '' '' ''.
    WHEN 6. ADD_MSG 'W' '398' 'DSO_UPDATE_DCLUST_FAILED' '' '' ''.

*   399: Start Chain FAILED for Update into Reporting.
    WHEN 7.
      ADD_MSG 'W' '399' '' '' '' ''.

  endcase.


ENDMETHOD. "EXEC_DELETE_STEP2


METHOD EXEC_LOG_ENTRY.

  FIELD-SYMBOLS:
    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    lf_batch_status  type /BIC/OIZXF_BTCS,   "Parameter fuer die Meldungsausgabe ..
    lref_data        type REF TO DATA,
    lref_param       type REF TO IF_RSPLFA_PARAM_ELEM VALUE IS INITIAL.

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike    "<<<<< ONLY !!!!
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status>.
  if sy-subrc <> 0.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Valid File / Invalid File' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the FILE ID from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.


* Read current message context from preceeding process steps
  IMPORT MN_RECNO                = MN_RECNO                 "Current record number
         MN_TOT                  = MN_TOT                   "Total Number of Messages E / W / I
         MN_MSG                  = MN_MSG                   "Number of Errors/Warnings -> FlowControl !
         MN_ERR                  = MN_ERR                   "Number of Errors
         MN_WAR                  = MN_WAR                   "Number of Warnings
         MN_INF                  = MN_INF                   "Number of Informations
         MN_MSG_RECNO            = MN_MSG_RECNO             "Messages: Current Record Number
         MN_MSG_LINNO            = MN_MSG_LINNO             "Messages: Line Number for current record
         MN_MSG_LINNO_LAST_REC_0 = MN_MSG_LINNO_LAST_REC_0  "Messages: Last Line Number for record number "0" !

      FROM MEMORY "see below for import
      ID 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.


* ----------------------------------------------------------------------------
* - Get parameter: P_STATUS
* ----------------------------------------------------------------------------
  lref_param = I_R_PARAM_SET->GET_PARAM_ELEM( C_PARAM_BATCH-NAME_BATCH_STATUS ).
  if lref_param is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_BATCH-NAME_BATCH_STATUS '' '' ''.
    RETURN.
  endif.

  clear lf_batch_status.
  CALL METHOD lref_param->GET_VALUE IMPORTING E_VALUE = lf_batch_status.
  if lf_batch_status is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_BATCH-NAME_BATCH_STATUS '' '' ''.
    RETURN.
  endif.



  free: MT_REC_MSG[].

* LOG ENTRY

  case lf_batch_status.

*   475: Copy to CDM Upload Cube
    when Y0BW_CL_XF_UP_BATCH_CTRL=>C_ZXF_BTCS-REQUESTED. ADD_MSG 'I' '475' '' '' '' ''.

*   481: File Upload terminated successfully.
    when Y0BW_CL_XF_UP_BATCH_CTRL=>C_ZXF_BTCS-SUCCESS.   ADD_MSG 'I' '481' '' '' '' ''.

  endcase.

* ----------------------------------------------------------------------------
* - Copy Record related messages from validation
* - into transaction data format with infoprovider information
* - for update into the messages cube.
* ----------------------------------------------------------------------------
  call method ADD_RECORD_MESSAGES
    exporting  I_S_FILEID  = MS_FILEID
               I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
    changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
  free: MT_REC_MSG[].

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert lines of <LT_STATUS>   into table C_TH_DATA.  "<<<<<
  insert lines of <LT_SOURCE>   into table C_TH_DATA.
  insert lines of <LT_TARGET>   into table C_TH_DATA.
  insert lines of <LT_OTHERS>   into table C_TH_DATA.
  insert lines of <LT_RECMSG>   into table C_TH_DATA.  "<<<<<

  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.


* Provide current message context for subsequent process steps
  EXPORT MN_RECNO                = MN_RECNO                 "Current record number
         MN_TOT                  = MN_TOT                   "Total Number of Messages E / W / I
         MN_MSG                  = MN_MSG                   "Number of Errors/Warnings -> FlowControl !
         MN_ERR                  = MN_ERR                   "Number of Errors
         MN_WAR                  = MN_WAR                   "Number of Warnings
         MN_INF                  = MN_INF                   "Number of Informations
         MN_MSG_RECNO            = MN_MSG_RECNO             "Messages: Current Record Number
         MN_MSG_LINNO            = MN_MSG_LINNO             "Messages: Line Number for current record
         MN_MSG_LINNO_LAST_REC_0 = MN_MSG_LINNO_LAST_REC_0  "Messages: Last Line Number for record number "0" !

      TO MEMORY "see below for import
      ID 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.



ENDMETHOD. "EXEC_LOG_ENTRY


METHOD EXEC_NO_OPERATION.

* We don't make ANY assumtions on the conditions we were executed to.
* We don't read or change any data.
  RETURN.

ENDMETHOD. "EXEC_NO_OPERATION


METHOD EXEC_SAVE_DATA.

  DATA:
    lr_application TYPE REF TO cl_rsbolap_application,
    lr_data_area   TYPE REF TO if_rsbolap_data_area.


* ----------------------------------------------------------------------------
* - SAVE BUFFER
* ----------------------------------------------------------------------------
* Initialize BI-IP application
  lr_application = cl_rspls_plan_application=>get( ).
  lr_data_area   = lr_application->get_data_area( ).

* Save data
  lr_data_area->save( ).                               "<<<<<

ENDMETHOD. "EXECUTE_SAVE_DATA


METHOD EXEC_SAVE_DATA_ON_INVALID_FILE.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube -> UFID
* - Raise "Save Buffer" in case the status is INVALID_FILE.
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
*   <LF_FIELD>       type ANY,

    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.


* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status>.
  if sy-subrc <> 0.

*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' 'Valid File / Invalid File' '' '' ''.
    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the file id from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status
* --------------------------------------------------------------------------
  case MS_FILEID-ZXF_STAT.

*   On Invalid File:
    when C_ZXF_STAT-FILE_NOT_READABLE
      or C_ZXF_STAT-INVALID_FILE.

*         Save buffer
          call method EXEC_SAVE_DATA exporting I_R_PARAM_SET  = I_R_PARAM_SET
                                               I_S_BLOCK_LINE = I_S_BLOCK_LINE
                                               I_R_MSG        = I_R_MSG
                                     changing  C_TH_DATA      = C_TH_DATA.

*         313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
          ADD_MSG 'E' '313' '' '' '' ''.                      "Stop Planning sequence from execution.
          RETURN.

*   On Valid File:
    when C_ZXF_STAT-VALID_FILE
      or C_ZXF_STAT-NO_AUTHORIZATION.

*         Do nothing.
*         Planning Sequence goes on
          .

*   Unexpected Status
    when others.

*         312: No status record with appropriate status '&' could be read.
          ADD_MSG 'E' '312' 'File not readable/Invalid File/Valid File/' '' '' ''.
*         313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
          ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
          RETURN.

  endcase.


* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert lines of <LT_STATUS> into table C_TH_DATA.
  insert lines of <LT_SOURCE> into table C_TH_DATA.
  insert lines of <LT_TARGET> into table C_TH_DATA.
  insert lines of <LT_RECMSG> into table C_TH_DATA.
  insert lines of <LT_OTHERS> into table C_TH_DATA.

  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.


ENDMETHOD. "EXEC_SAVE_DATA_ON_INVALID_FILE


METHOD EXEC_SET_STATUS_NO_AUTH.
* ----------------------------------------------------------------------------
* -
* ----------------------------------------------------------------------------


  call method SET_STATUS exporting  I_R_PARAM_SET  = I_R_PARAM_SET
                                    I_S_BLOCK_LINE = I_S_BLOCK_LINE
                                    I_R_MSG        = I_R_MSG
                                    I_STATUS_NEW   = C_ZXF_STAT-NO_AUTHORIZATION  " <<<<<
                                    I_STATUS_PRED  = C_ZXF_STAT-VALID_FILE        " <<<<<
                                    I_B_CHECK_PRED = rs_c_true                    " <<<<<

                         changing   C_TH_DATA      = C_TH_DATA.

ENDMETHOD. "EXEC_SET_STATUS_NO_AUTH


METHOD EXEC_SET_STATUS_VALID_FILE.
* ----------------------------------------------------------------------------
* -
* ----------------------------------------------------------------------------


  call method SET_STATUS exporting  I_R_PARAM_SET  = I_R_PARAM_SET
                                    I_S_BLOCK_LINE = I_S_BLOCK_LINE
                                    I_R_MSG        = I_R_MSG
                                    I_STATUS_NEW   = C_ZXF_STAT-VALID_FILE        " <<<<<
                                    I_STATUS_PRED  = C_ZXF_STAT-NO_AUTHORIZATION  " <<<<<
                                    I_B_CHECK_PRED = rs_c_true                    " <<<<<

                         changing   C_TH_DATA      = C_TH_DATA.

ENDMETHOD. "EXEC_SET_STATUS_NO_AUTH


METHOD EXEC_SUBMIT.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube -> UFID
* - Reads the "VALID FILE" from the CDM Upload Cube
* - Creates a list of data targets depending on the Measure ID's in the file.
* - Creates a new entry
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,

    <lwa_data>       type ANY,             "WORK AREA, not a pointer
                                           "pointer into C_TH_DATA !!
    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area
    <ls_target>      type ANY,             "the source record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA,
    ls_btc_header    type /BIC/AZXF_E30100,
    lt_btc_targets   type Y0BW_XF_UP_BATCH_TARGETS_T.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.  clear lref_data.  "Status record

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status>.
  if sy-subrc <> 0.

*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the file id from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status "04 VALIDFILE"
* --------------------------------------------------------------------------
  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE.
*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Return an error message in case no source records have been provided
* - in order to prevent the planning sequence from executing subsequent steps.
* ----------------------------------------------------------------------------
**  read table <LT_TARGET> index 1 transporting no fields.
**  if sy-subrc <> 0.
***   311: No source records provided for copy! STOP subsequent steps.
**    ADD_MSG 'E' '311' '' '' '' ''.
**    RETURN.
**  endif.

* ----------------------------------------------------------------------------
* - Create a list of data targets depending on the Measure ID's in the file
* ----------------------------------------------------------------------------
  DATA:
    ls_auth_filter type                   /BIC/AZXF_E30400,
    lt_auth_filter type standard table of /BIC/AZXF_E30400,

    ls_targets type Y0XFU_T_S_MEAS_CLUSTER,
    lt_targets type Y0XFU_T_T_MEAS_CLUSTER.

  select * from /BIC/AZXF_E30400
    into table lt_auth_filter
    where /BIC/ZXF_UFID = MS_FILEID-ZXF_UFID
      and TCTIOBJNM     = 'ZXF_MEAS'.
  if sy-subrc <> 0.
*   467: Filter for File Id '&' could'nt be read.
    ADD_MSG 'E' '467' MS_FILEID-ZXF_UFID '' '' ''.
    RETURN.
  endif.


** loop at the records and create a comprehensive list of data clusters
*  loop at <LT_TARGET> assigning <ls_target>.
*
*    assign component 'ZXF_UFID' of structure <ls_target> to <LF_FIELD>.
*    if sy-subrc <> 0.
**     305: Field Symbol '&' couldn't be assigned.
*      ADD_MSG 'E' '305' 'ZXF_UFID' '' '' ''.
*      RETURN.
*    endif.
*
*    if <LF_FIELD> <> MS_FILEID-ZXF_UFID.
**     383: More than one Unique File Id: '&', '&'.
*      ADD_MSG 'E' '383' MS_FILEID-ZXF_UFID <LF_FIELD> '' ''.
*      RETURN.
*    endif.
*
*    assign component 'ZXF_MEAS' of structure <ls_target> to <LF_FIELD>.
*    if sy-subrc <> 0.
**     305: Field Symbol '&' couldn't be assigned.
*      ADD_MSG 'E' '305' 'ZXF_MEAS' '' '' ''.
*      RETURN.
*    endif.

  clear ls_auth_filter.
  loop at lt_auth_filter into ls_auth_filter.

    clear ls_targets.
    read table STH_MEAS_CLUSTER
      into ls_targets
      with key MEASID  = ls_auth_filter-TCTLOW.

    if sy-subrc <> 0.
*     381: Measure ID '&': Assignment to data cluster not maintained.
      ADD_MSG 'E' '381' ls_auth_filter-TCTLOW '' '' ''.
      RETURN.
    endif.

*   382: Measure Id '&'. Parameter '&' not maintained in 'Y0BW_XF_DATA_CLS'.
    if ls_targets-DATA_CLUSTER  is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Data Cluster'           '' ''. RETURN. endif.
    if ls_targets-SRC_VIRT_PROV is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Virtual Provider'       '' ''. RETURN. endif.
    if ls_targets-SOURCE        is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Source CDM Upload Cube' '' ''. RETURN. endif.
    if ls_targets-TARGET        is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Target Changelog DSO'   '' ''. RETURN. endif.
    if ls_targets-PROCESS_CHAIN is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Process Chain ID'       '' ''. RETURN. endif.

    clear ls_targets-MEASID.
    collect ls_targets into lt_targets.
*   modify table lt_targets from ls_targets. "transporting  DATA_CLUSTER
*                                                           SRC_VIRT_PROV
*                                                           SOURCE
*                                                           TARGET
*                                                           PROCESS_CHAIN.

  endloop.
  if <ls_target> is assigned. unassign <ls_target>. endif.
  if <LF_FIELD>  is assigned. unassign <LF_FIELD>.  endif.
  clear: ls_targets.

* ----------------------------------------------------------------------------
* - Update File ID
* ----------------------------------------------------------------------------
  MS_FILEID-ZXF_STAT = C_ZXF_STAT-SUBMITREQ.
  MS_FILEID-ZXF_SUBBY = MS_FILEID-ZXF_LEDBY = SY-UNAME.           "Submitted/Requested for Update by
  MS_FILEID-ZXF_REQD  = MS_FILEID-ZXF_LEDD  = SY-DATUM.           "Date and Time: Request for Update
  MS_FILEID-ZXF_REQT  = MS_FILEID-ZXF_LEDT  = SY-UZEIT.
* MS_FILEID-ZXF_SUBD  = SY-DATUM.           "Date and Time: Update completed
* MS_FILEID-ZXF_SUBT  = SY-UZEIT.           "    done by process chain !

* ----------------------------------------------------------------------------
* - Create a new request for update into the reporting layer
* ----------------------------------------------------------------------------
  clear ls_btc_header.
  ls_btc_header-/BIC/ZXF_UFID   = MS_FILEID-ZXF_UFID.
  ls_btc_header-/BIC/ZXF_LABEL  = MS_FILEID-ZXF_LABEL.
  ls_btc_header-/BIC/ZXF_DSF    = MS_FILEID-ZXF_DSF.
  ls_btc_header-/BIC/ZXF_REQBY  = MS_FILEID-ZXF_SUBBY.
  ls_btc_header-/BIC/ZXF_REQD   = MS_FILEID-ZXF_REQD.
  ls_btc_header-/BIC/ZXF_REQT   = MS_FILEID-ZXF_REQT.

  clear l_subrc.
  free: lt_btc_targets.

  call method Y0BW_CL_XF_UP_BATCH_CTRL=>CREATE_NEW_REQUEST

    exporting  I_T_DATA_CLUSTER  = lt_targets                "XF UP: Data Cluster (Source/Target/Process Chain)
    importing  E_T_BTC_TARGETS   = lt_btc_targets
    changing   C_S_BTC_HEADER    = ls_btc_header             "XF UP D301 Batch Control Table, Header ( Direct Update )
    exceptions PARAMETER_EMPTY          = 1
               ENQUEUE_FAILED           = 2
               UFID_ALREADY_IN_USE      = 3
               DSO_INSERT_HEADER_FAILED = 4
               DSO_INSERT_DCLUST_FAILED = 5
               others                   = 6.

* 388: Request for Update into Rep. Layer failed: '&'.
  case sy-subrc.
    when 0. .
    when 1. ADD_MSG 'E' '388' 'PARAMETER_EMPTY'          '' '' ''. RETURN.
    when 2. ADD_MSG 'E' '388' 'ENQUEUE_FAILED'           '' '' ''. RETURN.
    when 3. ADD_MSG 'E' '388' 'UFID_ALREADY_IN_USE'      '' '' ''. RETURN.
    when 4. ADD_MSG 'E' '388' 'DSO_INSERT_HEADER_FAILED' '' '' ''. RETURN.
    when 5. ADD_MSG 'E' '388' 'DSO_INSERT_DCLUST_FAILED' '' '' ''. RETURN.
    when 6. ADD_MSG 'E' '388' 'OTHERS'                   '' '' ''. RETURN.
  endcase.

  clear ls_btc_header.
  free: lt_targets, lt_btc_targets.


* ----------------------------------------------------------------------------
* - Update Status Record
* ----------------------------------------------------------------------------
  clear <lwa_data>.
  <lwa_data> = <ls_status>.

  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data>
                                                E_SUBRC     = l_subrc.

  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

  unassign <ls_status>.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert          <lwa_data>  into table C_TH_DATA.
  insert lines of <LT_SOURCE> into table C_TH_DATA.
  insert lines of <LT_TARGET> into table C_TH_DATA.
  insert lines of <LT_RECMSG> into table C_TH_DATA.
  insert lines of <LT_OTHERS> into table C_TH_DATA.

  free:
    <lwa_data>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.

* ----------------------------------------------------------------------------
* - Start Job ( 1 ) Prozesskettenstart per API Aufruf
* ----------------------------------------------------------------------------
*  DATA: lf_logid type RSPC_LOGID.
*  CALL FUNCTION 'RSPC_API_CHAIN_START'
*    EXPORTING
*      I_CHAIN             = 'ZXF_WW_A_00_TD00'
*      I_DONT_WAIT         = rs_c_true
*    IMPORTING
*      E_LOGID             = lf_logid
*      EXCEPTIONS
*       FAILED              = 1
*       OTHERS              = 2.

* ----------------------------------------------------------------------------
* - Start Job ( 2 ) Prozesskettenstart per Event
* ----------------------------------------------------------------------------
*  call method CL_BATCH_EVENT=>RAISE
*    EXPORTING
**     i_server              = p_server
*      i_eventid             = Y0BW_CL_XF_UP_BATCH_CTRL=>C_EVENTID-Y0BW_XF_UP_START_JOB
*      i_eventparm           = SPACE
*    EXCEPTIONS
*      EXCPT_RAISE_FAILED              = 1
*      EXCPT_SERVER_ACCEPTS_NO_EVENTS  = 2
*      EXCPT_RAISE_FORBIDDEN           = 3
*      EXCPT_UNKNOWN_EVENT             = 4
*      EXCPT_NO_AUTHORITY              = 5
*      OTHERS                          = 6.

* ----------------------------------------------------------------------------
* - Start Job ( 3 ) Programmaufruf
* ----------------------------------------------------------------------------
*  submit Y0BW_XF_UP_START_JOB  with P_TEST = RS_C_FALSE
*
*      using selection-screen 1000     "Dunkel abspielen               !!!
*      and return.                     "Kontrollfluss geht hier weiter !!!

* ----------------------------------------------------------------------------
* - Start Job ( 4 ) FuBa (wird vom Programm benutzt)
* ----------------------------------------------------------------------------
  DATA:
    l_ZXF_UFID         type  /BIC/OIZXF_UFID,
    l_ZXF_RUND         type  /BIC/OIZXF_RUND,
    l_ZXF_RUNT         type  /BIC/OIZXF_RUNT,
    ls_BATCH_HEADER    type  /BIC/AZXF_E30100,
    lt_BATCH_TARGETS   type  Y0BW_XF_UP_BATCH_TARGETS_T.

* Start Job
  clear: l_ZXF_UFID, ls_BATCH_HEADER.
  free: lt_BATCH_TARGETS.

* Start Job
  CALL FUNCTION 'Y0BW_XF_UP_START_JOB'
    IMPORTING
      E_ZXF_UFID                     = l_ZXF_UFID
      E_ZXF_RUND                     = l_ZXF_RUND
      E_ZXF_RUNT                     = l_ZXF_RUNT
      E_S_BATCH_HEADER               = ls_BATCH_HEADER
      E_T_BATCH_TARGETS              = lt_BATCH_TARGETS
    EXCEPTIONS
*     JOB_STARTED                    = 0     "OK
      ENQUEUE_FAILED                 = 1     "Failed to start a job due to lock issues !!!!!
      STILL_ACTIVE                   = 2     "OK
      NO_MORE_REQUESTS               = 3     "OK (a terminated job started the job once again)
      NO_DATA_CLUSTER                = 4     "Failed to start a job for Update into Reporting !!!!!
      DSO_UPDATE_HEADER_FAILED       = 5     "Failed to start a job for Update into Reporting !!!!!
      DSO_UPDATE_DCLUST_FAILED       = 6     "Failed to start a job for Update into Reporting !!!!!
      START_CHAIN_FAILED             = 7     "Failed to Start Process Chain
      OTHERS                         = 8.

* l_ZXF_UFID = MS_FILEID-ZXF_UFID ?

  case sy-subrc.

*   395: Job Started for Update into Reporting.
    when 0.                                                          "JOB_STARTED
      ADD_MSG 'I' '395' '' '' '' ''.

*   396: Job for Update into Reporting still active. Wait.
    when 2.                                                          "STILL_ACTIVE
      ADD_MSG 'I' '396' '' '' '' ''.

*   397: Job for Update into Reporting already processed.
    when 3.                                                          "NO_MORE_REQUESTS
      ADD_MSG 'I' '397' '' '' '' ''.

*   398: Failed to start a job for Update into Reporting '&'.
    WHEN 1. ADD_MSG 'W' '398' 'ENQUEUE_FAILED'           '' '' ''.
    WHEN 4. ADD_MSG 'W' '398' 'NO_DATA_CLUSTER'          '' '' ''.
    WHEN 5. ADD_MSG 'W' '398' 'DSO_UPDATE_HEADER_FAILED' '' '' ''.
    WHEN 6. ADD_MSG 'W' '398' 'DSO_UPDATE_DCLUST_FAILED' '' '' ''.

*   399: Start Chain FAILED for Update into Reporting.
    WHEN 7.
      ADD_MSG 'W' '399' '' '' '' ''.

  endcase.

ENDMETHOD. "EXEC_SUBMIT


method exec_trigger_pcst.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube -> UFID
* - Deletes the records from the generic upload cube, which have been copied
* - to the CDM Upload Cube bevore (in case the status equals VALID_FILE).
* ----------------------------------------------------------------------------

  field-symbols:
*   <LF_FIELD>       type ANY,

    <ls_status> type any,             "the status record as a pointer into a table, not a work area

    <lt_status> type standard table,
    <lt_source> type standard table,
    <lt_target> type standard table,
    <lt_recmsg> type standard table,
    <lt_others> type standard table.

  data:
    l_subrc   type sysubrc,
    lref_data type ref to data.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* Read current message context from preceeding process steps
  import mn_recno                = mn_recno                 "Current record number
         mn_tot                  = mn_tot                   "Total Number of Messages E / W / I
         mn_msg                  = mn_msg                   "Number of Errors/Warnings -> FlowControl !
         mn_err                  = mn_err                   "Number of Errors
         mn_war                  = mn_war                   "Number of Warnings
         mn_inf                  = mn_inf                   "Number of Informations
         mn_msg_recno            = mn_msg_recno             "Messages: Current Record Number
         mn_msg_linno            = mn_msg_linno             "Messages: Line Number for current record
         mn_msg_linno_last_rec_0 = mn_msg_linno_last_rec_0  "Messages: Last Line Number for record number "0" !

      from memory "see below for import
      id 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like standard table of i_s_block_line. assign lref_data->* to <lt_status>. clear lref_data.
  create data lref_data like standard table of i_s_block_line. assign lref_data->* to <lt_source>. clear lref_data.
  create data lref_data like standard table of i_s_block_line. assign lref_data->* to <lt_target>. clear lref_data.
  create data lref_data like standard table of i_s_block_line. assign lref_data->* to <lt_others>. clear lref_data.
  create data lref_data like standard table of i_s_block_line. assign lref_data->* to <lt_recmsg>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->separate_source_target_records
    exporting
      i_th_data  = c_th_data
      i_r_msg    = i_r_msg
    importing
      e_t_status = <lt_status>     "XF UP 301 Status Cube
      e_t_source = <lt_source>     "XF UP 302 Generic Upload Cube
      e_t_target = <lt_target>     "XF UP 304 CDM Upload Cube, and alike
      e_t_others = <lt_others>
      e_t_recmsg = <lt_recmsg>
      e_subrc    = l_subrc.
  if l_subrc <> 0.
    return.
  endif.

  field-symbols: <fs_target> type any.
  field-symbols: <fs_measure> type /bic/oizxf_meas.
  field-symbols: <fs_mpct> type /bic/oizxf_mpct.
  field-symbols: <fs_0calyear> type /bi0/oicalyear.
  field-symbols: <fs_zxf_scen> type /bic/oizxf_scen.
  data: lv_tscen type /bic/oizxf_tscen.
  data: l_r_pcrun type ref to y0bw_cl_xx_pcrun.
  data: l_t_runsel type y0bw_xx_pcr_tabty_sel.
  data: l_s_runsel like line of l_t_runsel.
  data: lv_enq_3rd_chain type boolean value abap_false.

  loop at <lt_target> assigning <fs_target>.
    assign component 'ZXF_MEAS' of structure <fs_target> to <fs_measure>.
    case <fs_measure>.
      when 'SASG000345'.
        l_r_pcrun = y0bw_cl_xx_pcrun=>factory( i_chain_id = 'ZII_US_A_01_TD02' ).

        l_s_runsel-sign = 'I'.
        l_s_runsel-opt = 'EQ'.

        l_s_runsel-vnam = 'ZRB_XFMEAS_CMSMY'.
        l_s_runsel-low = <fs_measure>.
        append l_s_runsel to l_t_runsel.

        assign component 'ZXF_MPCT' of structure <fs_target> to <fs_mpct>.
        l_s_runsel-vnam = 'ZRB_PROCTR_XFSPCT_CMSMY'.
        l_s_runsel-low = <fs_mpct>.
        append l_s_runsel to l_t_runsel.

        assign component '0CALYEAR' of structure <fs_target> to <fs_0calyear>.
        l_s_runsel-vnam = 'ZRB_CALYEA_CMSMY'.
        l_s_runsel-low = <fs_0calyear>.
        append l_s_runsel to l_t_runsel.

        assign component 'ZXF_SCEN' of structure <fs_target> to <fs_zxf_scen>.
        call method y0bw_cl_xf_var_utils=>get_from_zxf_oscen
          exporting
            i_zxf_oscen = <fs_zxf_scen>
          importing
            e_zxf_tscen = lv_tscen.
        l_s_runsel-vnam = 'ZXF_XFTSCN_X20000_CMSMY'.
        l_s_runsel-low = lv_tscen.
        append l_s_runsel to l_t_runsel.

        call method l_r_pcrun->validate_and_enqueue
          exporting
            i_t_current_runsel = l_t_runsel.
    endcase.

    exit. "There is a decision, to use only single value variables, so there should be only one value per variable. Therefore it is enough to read only one record.

  endloop.

* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
*  DATA ln_Lines type i.
*  describe table <LT_STATUS> lines ln_Lines.
*  if ln_Lines > 1.
**   302: More than one status record read.
*    ADD_MSG 'E' '302' '' '' '' ''.
*    RETURN.
*  endif.
*
*  read table <LT_STATUS> index 1 assigning <ls_status>.
*  if sy-subrc <> 0.
*
**   312: No status record with appropriate status '&' could be read.
**   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
*    ADD_MSG 'E' '312' 'Valid File' '' '' ''.           "The filter selects VALID status records only for copy
*    ADD_MSG 'E' '313' '' '' '' ''.                     "Stop Planning sequence from execution.
*    RETURN.
*  endif.
*
** ----------------------------------------------------------------------------
** - Fill the file id from the current status record
** ----------------------------------------------------------------------------
*  clear: MS_FILEID, l_subrc.
*  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
*                                                I_R_MSG     = I_R_MSG
*                                      importing E_S_FILEID  = MS_FILEID
*                                                E_SUBRC     = l_subrc.
*  if l_subrc <> 0.
*    RETURN.
*  endif.
*
** --------------------------------------------------------------------------
** - Check the status "04 VALIDFILE"
** --------------------------------------------------------------------------
*  if MS_FILEID-ZXF_STAT <> C_ZXF_STAT-VALID_FILE.
**   312: No status record with appropriate status '&' could be read.
*    ADD_MSG 'I' '312' 'Valid File' '' '' ''.
*    RETURN.
*  endif.
*
**   ----------------------------------------------------------------------------
**   - Copy Record related messages from validation
**   - into transaction data format with infoprovider information
**   - for update into the messages cube.
**   ----------------------------------------------------------------------------
*    free: MT_REC_MSG[].
**   476: Delete from Generic Upload Cube ..
*    ADD_MSG 'I' '476' '' '' '' ''.
*    call method ADD_RECORD_MESSAGES
*      exporting  I_S_FILEID  = MS_FILEID
*                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
*      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
*    free: MT_REC_MSG[].
*
*
** --------------------------------------------------------------------------
** - Delete the records from the generic upload cube
** --------------------------------------------------------------------------
*  if MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.
*
*    FREE: <LT_SOURCE>.
*  endif.
*
** ----------------------------------------------------------------------------
** - Return records
** ----------------------------------------------------------------------------
*  free: C_TH_DATA[].
*
*  insert lines of <LT_STATUS> into table C_TH_DATA.
*  insert lines of <LT_SOURCE> into table C_TH_DATA.
*  insert lines of <LT_TARGET> into table C_TH_DATA.
*  insert lines of <LT_RECMSG> into table C_TH_DATA.
*  insert lines of <LT_OTHERS> into table C_TH_DATA.
*
*  free:
*    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.
*
*
*  delete from memory id 'ZRB_XFUFID_XFX340_CXSMN'.  "The file upload crates the new File Id,
*                                                    "Copy to CDM upload Cube uses it
*                                                    "Delete from Gen. Upload Cube uses it and releases it
*
** Provide current message context for subsequent process steps
*  EXPORT MN_RECNO                = MN_RECNO                 "Current record number
*         MN_TOT                  = MN_TOT                   "Total Number of Messages E / W / I
*         MN_MSG                  = MN_MSG                   "Number of Errors/Warnings -> FlowControl !
*         MN_ERR                  = MN_ERR                   "Number of Errors
*         MN_WAR                  = MN_WAR                   "Number of Warnings
*         MN_INF                  = MN_INF                   "Number of Informations
*         MN_MSG_RECNO            = MN_MSG_RECNO             "Messages: Current Record Number
*         MN_MSG_LINNO            = MN_MSG_LINNO             "Messages: Line Number for current record
*         MN_MSG_LINNO_LAST_REC_0 = MN_MSG_LINNO_LAST_REC_0  "Messages: Last Line Number for record number "0" !
*
*      TO MEMORY "see below for import
*      ID 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.

endmethod. "EXEC_DELETE_FROM_UPL


METHOD EXEC_UPDATE_STATUS.
* ----------------------------------------------------------------------------
* - The filter provides either one File Id, which was "Submitted" by the user
* - or two File Id's: one deleting File Id, which has to be "Submitted" and
* - the related file Id, which has to be "Deleted"
* - Therefore following status updates are possible
* -
* - Always:
* - Update Status of File Id to either "Submitted"     (SUCCESS)
* -                                 or "Submit Failed" (FAILURE)
* -
* - In case of a "Delete" request:
* - Update the related file Id (which is to be deleted)
* -                          to either "Deleted"       (SUCCESS)
* -                                 or "Delted Failed" (FAILURE)
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,

    <lwa_data>       type ANY,             "WORK AREA, not a pointer     Status record for given File Id
                                           "pointer into C_TH_DATA !!

    <lwa_data_rel>   type ANY,             "WORK AREA, not a pointer     Status record for related File Id (to be deleted!)
                                           "pointer into C_TH_DATA !!

    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area (given File Id)
    <ls_status_rel>  type ANY,             "the status record as a pointer into a table, not a work area (related File Id -to be deleted!))

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    l_update_mode    type I,               "C_UPDATE_MODE-SUBMIT or C_UPDATE_MODE-DELETE
    lref_data        type REF TO DATA,

    lref_param       type REF TO IF_RSPLFA_PARAM_ELEM VALUE IS INITIAL,
    lf_data_cluster  type /BIC/OIZXF_DCLS,
    lf_batch_status  type /BIC/OIZXF_BTCS,
    lb_terminated    type rs_bool,
    ls_btc_header    type /BIC/AZXF_E30100.

* ----------------------------------------------------------------------------
* - Get parameter: P_DATA_CLUSTER
* ----------------------------------------------------------------------------
  lref_param = I_R_PARAM_SET->GET_PARAM_ELEM( C_PARAM_BATCH-NAME_DATA_CLUSTER ).
  if lref_param is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_BATCH-NAME_DATA_CLUSTER '' '' ''.
    RETURN.
  endif.

  clear lf_data_cluster.
  CALL METHOD lref_param->GET_VALUE IMPORTING E_VALUE = lf_data_cluster.
  if lf_data_cluster is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_BATCH-NAME_DATA_CLUSTER '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Get parameter: P_STATUS
* ----------------------------------------------------------------------------
  lref_param = I_R_PARAM_SET->GET_PARAM_ELEM( C_PARAM_BATCH-NAME_BATCH_STATUS ).
  if lref_param is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_BATCH-NAME_BATCH_STATUS '' '' ''.
    RETURN.
  endif.

  clear lf_batch_status.
  CALL METHOD lref_param->GET_VALUE IMPORTING E_VALUE = lf_batch_status.
  if lf_batch_status is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_BATCH-NAME_BATCH_STATUS '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.      clear lref_data.  "Status record File Id
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data_rel>.  clear lref_data.  "Status record Related File Id (to be deleted)

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Analyse Status Record(s)
* ----------------------------------------------------------------------------
  DATA:
    lref_status     type REF TO DATA,
    lref_status_rel type REF TO DATA.

  clear: l_subrc, l_update_mode.
  call method UPDATE_STATUS_ANALYSE_RECORDS

    exporting I_T_STATUS     = <LT_STATUS>
              I_R_MSG        = I_R_MSG
              I_S_BLOCK_LINE = I_S_BLOCK_LINE

    importing E_UPDATE_MODE  = l_update_mode
              E_R_STATUS     = lref_status
              E_R_STATUS_REL = lref_status_rel
              E_S_FILEID     = MS_FILEID
              E_S_FILEID_REL = MS_FILEID_REL
              E_SUBRC        = l_subrc.

  if l_subrc <> 0.
    RETURN.
  endif.

  if l_update_mode = C_UPDATE_MODE-SUBMIT.
    assign lref_status->*     to <ls_status>.
  else.
    assign lref_status->*     to <ls_status>.
    assign lref_status_rel->* to <ls_status_rel>.
  endif.

  clear: lref_status, lref_status_rel.

* ----------------------------------------------------------------------------
* - Update Status in Batch Control table for given data cluster
* ----------------------------------------------------------------------------
* ggf. einen Simulations-Modus einfuegen, der den kuenftigen Status
* ermittelt, aber kein update durchfuehrt. Dann, in einem zweiten Schritt
* der Planungssequenz NACH Aktualisierung des Status Satzes im Status Cube
* den Update auf der Batch Control Table durchfuehren, um sicherzugehen,
* dass der Statussatz zurueckgeschrieben werden konnte.
* ----------------------------------------------------------------------------
  lb_terminated = rs_c_false.
  clear ls_btc_header.
  CALL METHOD Y0BW_CL_XF_UP_BATCH_CTRL=>SET_STATUS_PER_DATA_CLUSTER
    EXPORTING
      I_ZXF_UFID                = MS_FILEID-ZXF_UFID     "File Id of active Job
      I_DATA_CLUSTER            = lf_data_cluster        "Data Cluster, that has terminated
      I_BATCH_STATUS            = lf_batch_status        "with Status SUCCESS or FAILURE
    IMPORTING
      E_UPDATE_TERMINATED       = lb_terminated          "All Data Clusters are terminated: Update Status Record
      E_S_BTC_HEADER            = ls_btc_header          "with overall Status
    EXCEPTIONS
      PARAMETER_EMPTY           = 1
      WRONG_BATCH_STATUS        = 2
      ENQUEUE_FAILED            = 3
      NO_JOB_BY_UFID            = 4
      NO_ACTIVE_JOB             = 5
      NO_DATA_CLUSTER           = 6
      DSO_UPDATE_DCLUST_FAILED  = 7
      DSO_UPDATE_HEADER_FAILED  = 8
      others                    = 9.

  if sy-subrc <> 0.
*   ADD_MSG
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Update Status Record(s)
* ----------------------------------------------------------------------------

* UPDATE STATUS RECORD ONLY AFTER THE LAST PROCESS HAS TERMINATED,
* EVEN IF A EARLIER PROCESS HAS failed, WHICH IN FACT DETERMINES THE
* FINAL STATUS !
  if lb_terminated = rs_c_true.

    if l_update_mode = C_UPDATE_MODE-SUBMIT or   "SUBMIT in either case
       l_update_mode = C_UPDATE_MODE-DELETE.

      clear <lwa_data>.
      <lwa_data> = <ls_status>.

*     ----------------------------------------------------------------------------
*     - Update File ID
*     ----------------------------------------------------------------------------
      case ls_btc_header-/BIC/ZXF_BTCS.

        when Y0BW_CL_XF_UP_BATCH_CTRL=>C_ZXF_BTCS-SUCCESS.

          MS_FILEID-ZXF_STAT = C_ZXF_STAT-SUBMITTED.

        when Y0BW_CL_XF_UP_BATCH_CTRL=>C_ZXF_BTCS-FAILURE.

          MS_FILEID-ZXF_STAT = C_ZXF_STAT-SUBMIT_FAILED.
      endcase.

*     MS_FILEID-ZXF_SUBBY = SY-UNAME.                    "Submitted/Requested for Update by
*     MS_FILEID-ZXF_REQD  = SY-DATUM.                    "Date and Time: Request for Update
*     MS_FILEID-ZXF_REQT  = SY-UZEIT.
      MS_FILEID-ZXF_SUBD  = MS_FILEID-ZXF_LEDD = ls_btc_header-/BIC/ZXF_ENDD. "Date and Time: Update completed
      MS_FILEID-ZXF_SUBT  = MS_FILEID-ZXF_LEDT = ls_btc_header-/BIC/ZXF_ENDT.

      clear: l_subrc.
      call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                    I_R_MSG     = I_R_MSG
                                          importing E_S_STATUS  = <lwa_data>
                                                    E_SUBRC     = l_subrc.
      if l_subrc <> 0.
        RETURN.
      endif.

      unassign <ls_status>.
    endif.

*   In case of Delete update related status record
    if l_update_mode = C_UPDATE_MODE-DELETE.

      clear <lwa_data_rel>.
      <lwa_data_rel> = <ls_status_rel>.

*     --------------------------------------------------------------------------
*     - Update related File ID
*     --------------------------------------------------------------------------
      case ls_btc_header-/BIC/ZXF_BTCS.

        when Y0BW_CL_XF_UP_BATCH_CTRL=>C_ZXF_BTCS-SUCCESS.

          MS_FILEID_REL-ZXF_STAT = C_ZXF_STAT-DELETED.

        when Y0BW_CL_XF_UP_BATCH_CTRL=>C_ZXF_BTCS-FAILURE.

          MS_FILEID_REL-ZXF_STAT = C_ZXF_STAT-DELETE_FAILED.
      endcase.

*     MS_FILEID_REL-ZXF_SUBBY = SY-UNAME.                    "Submitted/Requested for Update by
*     MS_FILEID_REL-ZXF_REQD  = SY-DATUM.                    "Date and Time: Request for Update
*     MS_FILEID_REL-ZXF_REQT  = SY-UZEIT.
*     MS_FILEID_REL-ZXF_SUBD  = ls_btc_header-/BIC/ZXF_ENDD. "Date and Time: Update completed
*     MS_FILEID_REL-ZXF_SUBT  = ls_btc_header-/BIC/ZXF_ENDT.
      MS_FILEID_REL-ZXF_DELD  = MS_FILEID_REL-ZXF_LEDD = ls_btc_header-/BIC/ZXF_ENDD. "Date and Time: Delete completed
      MS_FILEID_REL-ZXF_DELT  = MS_FILEID_REL-ZXF_LEDT = ls_btc_header-/BIC/ZXF_ENDT.
      clear: l_subrc.
      call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID_REL
                                                    I_R_MSG     = I_R_MSG
                                          importing E_S_STATUS  = <lwa_data_rel>
                                                    E_SUBRC     = l_subrc.
      if l_subrc <> 0.
        RETURN.
      endif.

      unassign <ls_status>.

    endif. "l_update_mode = C_UPDATE_MODE-DELETE

  endif. "lb_terminated = rs_c_true

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert          <lwa_data>      into table C_TH_DATA.

  if l_update_mode =
     C_UPDATE_MODE-DELETE.
    insert        <lwa_data_rel>  into table C_TH_DATA.
  endif.
  insert lines of <LT_SOURCE> into table C_TH_DATA.
  insert lines of <LT_TARGET> into table C_TH_DATA.
  insert lines of <LT_RECMSG> into table C_TH_DATA.
  insert lines of <LT_OTHERS> into table C_TH_DATA.

  free:
    <lwa_data>, <lwa_data_rel>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.

  clear: MS_FILEID, MS_FILEID_REL.

ENDMETHOD. "EXEC_UPDATE_STATUS


method fill_breakdown_meas_dis.

  field-symbols:
    <ls_meas_set>         type y0bw_xf_meas_set,
    <ls_meas_set_gen>     type y0bw_xf_meas_set,
    <ls_meas_set_upl>     type y0bw_xf_meas_set,
    <ls_meas_dis>         type y0bw_xf_meas_dis.

  data:
    l_subrc           type sysubrc,
    ls_range          type rrrange,               "RSCHAVL
    lt_range          type rsrcc_t_range,         "range of RSCHAVL

    ls_meas_set       type y0bw_xf_meas_set,

    lt_meas_set       type y0bw_xf_meas_set_t,    "Result for E_T_MEAS_SET: Condensed list of measures, for which either
                                                  "                         set "UPL" or "GEN" is defined. The set, for which
                                                  "                         dimensions are defined, is stored here.
    lt_meas_set_gen   type y0bw_xf_meas_set_t,
    lt_meas_set_upl   type y0bw_xf_meas_set_t,

    lt_meas_dis       type y0bw_xf_meas_dis_t,   "Result set for E_TH_MEAS_DIS: List of break-down characteristics for each
                                                 "                              Measure Id. The set has been cleared !
    lt_meas_dis_gen   type y0bw_xf_meas_dis_t,   "Assignment Measure Id to dimensions for set "GEN"
    lt_meas_dis_upl   type y0bw_xf_meas_dis_t,   "Assignment Measure Id to dimensions for set "UPL"

    lth_meas_dis_gen  type y0bw_xf_meas_dis_th, "for look up !
    lth_meas_dis_upl  type y0bw_xf_meas_dis_th. "for look up !

  e_subrc = 8.

  free:
    e_t_meas_set,
    e_th_meas_dis.

* ----------------------------------------------------------------------------
* - Get all measures, which have assigned a measure set for
* - purpose "GEN: Reporting"
* ----------------------------------------------------------------------------
  clear ls_range.
  ls_range-sign  = rs_c_range_sign-including.
  ls_range-opt   = rs_c_range_opt-equal.
  ls_range-low   = c_y0xf_purpose-gen.              "General (Reporting)
  append ls_range to lt_range.
  clear ls_range.

  clear l_subrc.
* call method
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_set( exporting  i_t_range_purpose = lt_range
                                        importing  e_subrc           = l_subrc
                                                   e_t_result        = lt_meas_set_gen ).
  free: lt_range[].

* ----------------------------------------------------------------------------
* - Get all measures, which have assigned a measure set for
* - purpose "UPL: Upload Framework"
* ----------------------------------------------------------------------------
  clear ls_range.
  ls_range-sign  = rs_c_range_sign-including.
  ls_range-opt   = rs_c_range_opt-equal.
  ls_range-low   = c_y0xf_purpose-upl.
  append ls_range to lt_range.
  clear ls_range.

  clear l_subrc.
* call method
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_set( exporting  i_t_range_purpose = lt_range
                                        importing  e_subrc           = l_subrc
                                                   e_t_result        = lt_meas_set_upl ).
  free: lt_range[].

* ----------------------------------------------------------------------------
* - Build a list of measures, for which a measure set of either purpose is
* - defined. The result is a >>comprehensive<< list of relevant measure id's!
* ----------------------------------------------------------------------------
  clear ls_meas_set.
  modify lt_meas_set_gen from ls_meas_set transporting purpose data_cluster where measid <> ''. "delete set and data cluster
  modify lt_meas_set_upl from ls_meas_set transporting purpose data_cluster where measid <> ''. "delete set and data cluster

  free: lt_meas_set.
  lt_meas_set[] = lt_meas_set_gen[].
  loop at lt_meas_set_upl assigning <ls_meas_set_upl>.

    collect <ls_meas_set_upl> into lt_meas_set.            "List of measure id's which have a set assigned
  endloop.

* ----------------------------------------------------------------------------
* - Get the dimension set for purpose "GEN: Reporting"
* ----------------------------------------------------------------------------
  clear ls_range.
  ls_range-sign  = rs_c_range_sign-including.
  ls_range-opt   = rs_c_range_opt-equal.
  ls_range-low   = c_y0xf_purpose-gen.              "General (Reporting)
  append ls_range to lt_range.
  clear ls_range.

  clear l_subrc.
* call method
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_dis( exporting  i_t_range_purpose = lt_range
                                        importing  e_subrc           = l_subrc
                                                   e_t_result        = lt_meas_dis_gen ).
  free: lt_range[].

* ----------------------------------------------------------------------------
* - Get the dimension set for purpose "UPL: Upload Framework"
* ----------------------------------------------------------------------------
  clear ls_range.
  ls_range-sign  = rs_c_range_sign-including.
  ls_range-opt   = rs_c_range_opt-equal.
  ls_range-low   = c_y0xf_purpose-upl.
  append ls_range to lt_range.
  clear ls_range.

  clear l_subrc.
* call method
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_dis( exporting  i_t_range_purpose = lt_range
                                        importing  e_subrc           = l_subrc
                                                   e_t_result        = lt_meas_dis_upl ).
  free: lt_range[].

* ----------------------------------------------------------------------------
* - Condense Measure/Dimension for either purpose into one table
* ----------------------------------------------------------------------------
  lth_meas_dis_upl[] = lt_meas_dis_upl[]. free: lt_meas_dis_upl[].
  lth_meas_dis_gen[] = lt_meas_dis_gen[]. free: lt_meas_dis_gen[].

* loop at all RELEVANT Measures, which have at least one set assigned (UPL or GEN)
  "delete lt_meas_set where purpose ne 'UPL'.
  loop at lt_meas_set_upl assigning <ls_meas_set>.

*   Assignment characteristic to measure for "UPL" comes first
    loop at lth_meas_dis_upl assigning <ls_meas_dis>
      where measid = <ls_meas_set>-measid.

      insert <ls_meas_dis> into table lt_meas_dis.       " <<<<< Measure Id: Dimensions for Set "UPL"
    endloop.

*   -----------------------------------------------------------------
*   - Measure Id -> "UPL"
*   - At least one assignment to a dimension is maintained for "UPL":
*   - Flag measure id as "UPL"
*   -----------------------------------------------------------------
    if sy-subrc = 0.

      <ls_meas_set>-purpose = c_y0xf_purpose-upl.

*   Not a single assignment to a dimension maintained for "UPL": Try "GEN"
    else.

      loop at lth_meas_dis_gen assigning <ls_meas_dis>
        where measid = <ls_meas_set>-measid.

        insert <ls_meas_dis> into table lt_meas_dis.     " <<<<< Measure Id: Dimensions for Set "GEN"
      endloop.
*     ---------------------------------------------------------------
*     - Measure Id -> "UPL"
*     - At least one assignment to a dimension is maintained for "GEN":
*     - Flag measure id as "GEN"
*     ---------------------------------------------------------------
      if sy-subrc = 0.

        <ls_meas_set>-purpose = c_y0xf_purpose-gen.

*     No assignment to dimension dimension has been maintained for either set
      else.
*       101: Measure Id '&'. No dimensions have been maintained for GEN or UPL.
        add_msg 'I' '101' <ls_meas_set>-measid '' '' ''.
      endif.
    endif. "Y0XF_PURPOSE-UPL
  endloop.

* Return tables
  e_t_meas_set[]  = lt_meas_set[].  "Condensed
  e_th_meas_dis[] = lt_meas_dis[].
  clear e_subrc.

  free: lt_meas_set,         lt_meas_dis,
        lt_meas_set_gen,     lt_meas_dis_gen,
        lt_meas_set_upl,     lt_meas_dis_upl,

                             lth_meas_dis_gen,
                             lth_meas_dis_upl.

endmethod. "FILL_BREAKDOWN_MEAS_DIS





***  *************************************************************************
***  DATA:
***    ln_Idx_GEN        type N,
***    ln_Idx_UPL        type N,
***    lb_lb_EOF_GEN type boolean,
***    lb_lb_EOF_UPL type boolean,
***
***  ln_Idx_GEN = 1. lb_EOF_GEN = rs_c_false.
***  ln_Idx_UPL = 1. lb_EOF_UPL = rs_c_false.
***  WHILE rs_c_true.
***
***    if lb_EOF_GEN = rs_c_false. read table lts_MEAS_SET_GEN index ln_Idx_GEN assigning <ls_MEAS_SET_GEN>. if sy-subrc <> 0. lb_EOF_GEN = rs_c_true.
***    if lb_EOF_UPL = rs_c_false. read table lts_MEAS_SET_UPL index ln_Idx_UPL assigning <ls_MEAS_SET_UPL>. if sy-subrc <> 0. lb_EOF_UPL = rs_c_true.
***
****   Both tables contain further entries
***    if lb_EOF_GEN = rs_c_false and
***       lb_EOF_UPL = rs_c_false = 0.
***
***      if <ls_MEAS_SET_GEN>-MEASID <= <ls_MEAS_SET_UPL>-MEASID
***        append <ls_MEAS_SET_GEN>-MEASID to lts_MEAS_SET.
***        ln_Idx_GEN = ln_Idx_GEN + 1.
***      else.
***        append <ls_MEAS_SET_UPL>-MEASID to lts_MEAS_SET.
***        ln_Idx_GEN = ln_Idx_UPL + 1.
***      endif.
***
****   Only GEN: Reporting contains further entries
***    elseif lb_EOF_GEN = rs_c_false.
***      append <ls_MEAS_SET_GEN>-MEASID to lts_MEAS_SET.
***      ln_Idx_GEN = ln_Idx_GEN + 1.
***
****   Only UPL: Upload Framework contains further entries
***    elseif lb_EOF_UPL = rs_c_false.
***      append <ls_MEAS_SET_UPL>-MEASID to lts_MEAS_SET.
***      ln_Idx_GEN = ln_Idx_UPL + 1.
***
****   Neither table contains further entries
***    else.
***      EXIT.
***    endif.
***
***    if <ls_MEAS_SET_GEN> is assigned. unassign <ls_MEAS_SET_GEN>. endif.
***    if <ls_MEAS_SET_UPL> is assigned. unassign <ls_MEAS_SET_UPL>. endif.
***
***  ENDWHILE.
***  if <ls_MEAS_SET_GEN> is assigned. unassign <ls_MEAS_SET_GEN>. endif.
***  if <ls_MEAS_SET_UPL> is assigned. unassign <ls_MEAS_SET_UPL>. endif.
***  free: lts_MEAS_SET_GEN[],
***        lts_MEAS_SET_UPL[].
***  *************************************************************************


method fill_filter_meas_fis.

  field-symbols:
    <ls_zxf_meas>         type t_s_measure_id,
    <ls_meas_fis>         type y0bw_xf_meas_fis.

  data:
    l_subrc            type sysubrc,
    ls_range           type rrrange,               "RSCHAVL
    lt_range_measid    type rsrcc_t_range,         "range of RSCHAVL
    lt_range_purpose   type rsrcc_t_range,         "range of RSCHAVL

    lt_meas_fis        type y0bw_xf_meas_fis_t,
    lt_meas_fis_seltp1 type y0bw_xf_meas_fis_t.   "Selection Type "1" Area Selection

  e_subrc = 8.

  free:
    e_ts_meid_fis.

* ----------------------------------------------------------------------------
* - Get Filter Set for purpose "UPL: Upload Framework"
* - for all Measure Id's in the upload file.
* ----------------------------------------------------------------------------
  free: lt_range_purpose[].
  clear ls_range.
  ls_range-sign  = rs_c_range_sign-including.
  ls_range-opt   = rs_c_range_opt-equal.
  ls_range-low   = c_y0xf_purpose-upl.
  append ls_range to lt_range_purpose.
  clear ls_range.

  free: lt_range_measid[].
  loop at mth_measure_id assigning <ls_zxf_meas>.
    clear ls_range.
    ls_range-sign  = rs_c_range_sign-including.
    ls_range-opt   = rs_c_range_opt-equal.
    ls_range-low   = <ls_zxf_meas>-measid.
    append ls_range to lt_range_measid.
    clear ls_range.
  endloop.
  if <ls_zxf_meas> is assigned. unassign <ls_zxf_meas>. endif.

  clear l_subrc.
  free: lt_meas_fis.
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_fis( exporting  i_t_range_measid  = lt_range_measid
                                                   i_t_range_purpose = lt_range_purpose
                                                   i_objvers         = rs_c_objvers-active
                                        importing  e_subrc           = l_subrc
                                                   e_t_result        = lt_meas_fis ).

* Restrict to Selection Type "1" Area selection
  free: lt_meas_fis_seltp1.
  loop at lt_meas_fis assigning <ls_meas_fis>.

    if <ls_meas_fis>-seltp = c_y0xf_seltp-_1.  "Area Selection
      append <ls_meas_fis> to lt_meas_fis_seltp1.
    endif.

  endloop.
  free: lt_meas_fis.

* Sort and return Filter Values
  sort lt_meas_fis_seltp1 by measid
                             purpose   "UPL
                             dimnm
                             index_number.

  clear e_subrc.
  e_ts_meid_fis[] = lt_meas_fis_seltp1[].

  free: lt_range_measid,
        lt_range_purpose,
        lt_meas_fis,
        lt_meas_fis_seltp1.

endmethod. "FILL_FILTER_MEAS_FIS


method fill_head__valid_header_fields.

  field-symbols:
*   <ls_head>        type T_S_HEAD,
    <ls_xf_upheader> type y0bw_xf_upheader.

  data:
     l_subrc                 type sysubrc,
     ls_head                 type t_s_head,
     lt_head                 type t_t_head,
     ls_valid_header_fields  type t_s_valid_header_fields,
     lt_valid_header_fields  type t_t_valid_header_fields,
     lt_xf_upheader          type y0bw_xf_upheader_t.


  e_subrc = 8.

  free:
    e_th_head,
    e_th_valid_header_fields.

* ----------------------------------------------------------------------------
* - Read Table Y0BW_XF_UPHEADER, "XF UP: Column Header"
* ----------------------------------------------------------------------------
  clear l_subrc.
* call method
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_upheader( importing  e_subrc    = l_subrc
                                                   e_t_result = lt_xf_upheader ).
  if l_subrc <> 0.
    return.
  endif.

* ----------------------------------------------------------------------------
* - Fill STH_HEAD
* ----------------------------------------------------------------------------
  free: lt_head.
  loop at lt_xf_upheader assigning <ls_xf_upheader>.

    move-corresponding <ls_xf_upheader> to ls_head.

*   Translate Column Header to UPPER CASE
    translate ls_head-col_header to upper case.          "Header CAPITALIZED: SCENARIO, AGE GROUP
    ls_head-col_head_low = <ls_xf_upheader>-col_header.  "Header 'Name':      Scenario, Age group
    append ls_head to lt_head.
  endloop.

  e_th_head[] = lt_head[].
  free: lt_head.

* --------------------------------------------------------------------------
* - Fill ST_VALID_HEADER_FIELDS
* --------------------------------------------------------------------------
  free: lt_valid_header_fields.

  loop at lt_xf_upheader assigning <ls_xf_upheader>.

    move-corresponding <ls_xf_upheader> to ls_valid_header_fields.

*   Translate Column Header to UPPER CASE
    translate ls_valid_header_fields-col_header to upper case.
    append ls_valid_header_fields to lt_valid_header_fields.
  endloop.

  sort lt_valid_header_fields by col_header              "readability only (hashed !)
                                 dimnm
                                 header_type
                                 header_subtype.

  e_th_valid_header_fields[] = lt_valid_header_fields[].
  free: lt_valid_header_fields.

  clear e_subrc.

endmethod. "FILL_HEAD__VALID_HEADER_FIELDS


method fill_meas_cluster.

  field-symbols:
    <ls_meas_set>     type y0bw_xf_meas_set,
    <ls_meas_cluster> type y0xfu_t_s_meas_cluster.

  data:
    l_subrc           type sysubrc,
    ls_range          type rrrange,                 "RSCHAVL
    lt_range          type rsrcc_t_range,           "range of RSCHAVL
    lth_meas_cluster  type y0xfu_t_th_meas_cluster.

  free: sth_meas_cluster.

* ----------------------------------------------------------------------------
* - Get the measure set for both purposes
* -    "UPL: Upload Framework"
* -    "GEN: General / Reporting"
* - enhanced by the data cluster per Measer id
* ----------------------------------------------------------------------------
  clear ls_range.
  ls_range-sign  = rs_c_range_sign-including.
  ls_range-opt   = rs_c_range_opt-equal.

  ls_range-low   = c_y0xf_purpose-upl.  append ls_range to lt_range.
  ls_range-low   = c_y0xf_purpose-gen.  append ls_range to lt_range.
  clear ls_range.

  clear l_subrc.
  free: lth_meas_cluster.
  y0bw_xf_kpi_il_v2=>get_y0bw_xf_meas_cluster( exporting  i_t_range_purpose = lt_range
                                            importing  e_subrc           = l_subrc
                                                       e_t_result        = lth_meas_cluster ).
  delete lth_meas_cluster
    where data_cluster = space.

  free: lt_range[].

* ----------------------------------------------------------------------------
* - Loop at the relevant measures (with relevant set)
* - and restrict the list of data clusters to the set
* - which is assigned to the measure.
* ----------------------------------------------------------------------------
  loop at i_t_meas_set assigning <ls_meas_set>.   "Measure Id/Set (UPL or GEN assigned !)

    read table lth_meas_cluster
      assigning <ls_meas_cluster>
      with key measid  = <ls_meas_set>-measid
*     PURPOSE = <ls_meas_set>-PURPOSE.
      purpose = c_y0xf_purpose-upl.               "2012-03-27 (mh) The Data Cluster is always maintained
    "                for the Upload Set ("UPL") only !
    if sy-subrc = 0.

      if not <ls_meas_cluster>-data_cluster is initial.

        insert <ls_meas_cluster>
          into table sth_meas_cluster.
      else.
*       381: Measure ID/Set '&'/'&': Assignment to data cluster not maintained..
        add_msg 'I' '381' <ls_meas_set>-measid
                          <ls_meas_set>-purpose '' ''.
      endif.
    else.
*     381: Measure ID/Set '&'/'&': Assignment to data cluster not maintained..
      add_msg 'I' '381' <ls_meas_set>-measid
                        <ls_meas_set>-purpose '' ''.
    endif.
  endloop.

  free: lth_meas_cluster.

endmethod. "FILL_MEAS_CLUSTER


METHOD IF_RSPLFA_SRVTYPE_IMP_EXEC~EXECUTE.


* ----------------------------------------------------------------------------
* - Get parameter: P_SERVTP
* ----------------------------------------------------------------------------
DATA:
  lstr_param  type        /BIC/OIZXFSERVTP,
  lref_param  TYPE REF TO IF_RSPLFA_PARAM_ELEM VALUE IS INITIAL,
  lstr_method TYPE string.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ALEREMOTE'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

  lref_param = I_R_PARAM_SET->GET_PARAM_ELEM( C_PARAM_SERVTP-NAME ).
  if lref_param is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_SERVTP-NAME '' '' ''.
    RETURN.
  endif.

  clear lstr_param.
  CALL METHOD lref_param->GET_VALUE IMPORTING E_VALUE = lstr_param.
  if lstr_param is initial.
*   411: Parameter '&' is not provided.
    ADD_MSG 'E' '411' C_PARAM_SERVTP-NAME '' '' ''.
    RETURN.
  endif.

  M_SERVTP = lstr_param.
  clear lstr_param.

  clear lstr_method.
  case M_SERVTP.

*   ==========================================================================
*   = U S E R  T R I G G E R E D    P L A N N I N G F U N C T I O N S
*   ==========================================================================

*   --------------------------------------------------------------------------
*   - File Upload
*   --------------------------------------------------------------------------
*   see BADI Implementation ZIF_EX_RSPLF_FILE_UPLOAD

*   --------------------------------------------------------------------------
*   - Cancel Upload - Delete File from Gereric/CDM Upload Cube
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-CANCEL.                 lstr_method =
         C_PARAM_SERVTP-FUNCT-CANCEL.

    when C_PARAM_SERVTP-VALUE-CANCEL_STEP2.           lstr_method =
         C_PARAM_SERVTP-FUNCT-CANCEL_STEP2.

*   --------------------------------------------------------------------------
*   - SUBMIT - Create Request from Update into Changelog DSO
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-SUBMIT.                 lstr_method =
         C_PARAM_SERVTP-FUNCT-SUBMIT.

*   --------------------------------------------------------------------------
*   - DELETE - Delete File from Reporting Layer (Step 1 + 2)
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-DELETE.                 lstr_method =
         C_PARAM_SERVTP-FUNCT-DELETE.

    when C_PARAM_SERVTP-VALUE-DELETE_STEP2.           lstr_method =
         C_PARAM_SERVTP-FUNCT-DELETE_STEP2.


*   ==========================================================================
*   = I N T E R N A L   P L A N N I N G F U N C T I O N S
*   ==========================================================================

*   --------------------------------------------------------------------------
*   - No Operation - Execute Filter for Authorization Check
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-NO_OPERATION.           lstr_method =
         C_PARAM_SERVTP-FUNCT-NO_OPERATION.

*   --------------------------------------------------------------------------
*   - Log entry
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-LOG_ENTRY.              lstr_method =
         C_PARAM_SERVTP-FUNCT-LOG_ENTRY.

*   --------------------------------------------------------------------------
*   - Save Data
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-SAVE_DATA.              lstr_method =
         C_PARAM_SERVTP-FUNCT-SAVE_DATA.

*   --------------------------------------------------------------------------
*   - Save Data on Invalid File and Stop Planning Sequence
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-SAVE_DATA_ON_INVALID.   lstr_method =
         C_PARAM_SERVTP-FUNCT-SAVE_DATA_ON_INVALID.

*   --------------------------------------------------------------------------
*   - Set Status to "NO_AUTHORIZATION" b  e v o r e  copy to CDM Upload Cube
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-SET_STATUS_NO_AUTH.     lstr_method =
         C_PARAM_SERVTP-FUNCT-SET_STATUS_NO_AUTH.

*   --------------------------------------------------------------------------
*   - Copy from Generic Upload Cube to CDM Upload Cube
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-COPY_TO_CDM.            lstr_method =
         C_PARAM_SERVTP-FUNCT-COPY_TO_CDM.

*   --------------------------------------------------------------------------
*   - Reset Status to "VALIDFILE"      a f t e r     copy to CDM Upload Cube
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-SET_STATUS_VALID_FILE.  lstr_method =
         C_PARAM_SERVTP-FUNCT-SET_STATUS_VALID_FILE.

*   --------------------------------------------------------------------------
*   - Delete from Generic Upoad Cube after Copy to CDM Upload Cube
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-DELETE_FROM_UPL.        lstr_method =
         C_PARAM_SERVTP-FUNCT-DELETE_FROM_UPL.

*   --------------------------------------------------------------------------
*   - UPDATE_STATUS - Update Status Record
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-UPDATE_STATUS.          lstr_method =
         C_PARAM_SERVTP-FUNCT-UPDATE_STATUS.

*   --------------------------------------------------------------------------
*   - UPDATE_STATUS - Update Status Record
*   --------------------------------------------------------------------------
    when C_PARAM_SERVTP-VALUE-TRIGGER_PCST.          lstr_method =
         C_PARAM_SERVTP-FUNCT-TRIGGER_PCST.


    when others.
*     412: Parameter '&' has unknown value '&'.
      ADD_MSG 'E' '412' C_PARAM_SERVTP-NAME
                        M_SERVTP '' ''.
      RETURN.

  endcase.


* ============================================================================
* = CALL METHOD
* ============================================================================
  if not lstr_method is initial.

    CALL METHOD (lstr_method)

        EXPORTING I_R_PARAM_SET  = I_R_PARAM_SET
                  I_S_BLOCK_LINE = I_S_BLOCK_LINE
                  I_R_MSG        = I_R_MSG
        CHANGING  C_TH_DATA      = C_TH_DATA.

  endif.
  clear: lstr_method.

ENDMETHOD. "IF_RSPLFA_SRVTYPE_IMP_EXEC~EXECUTE


method IF_RSPLFA_SRVTYPE_IMP_EXEC~FINISH_EXECUTION.
endmethod.


METHOD IF_RSPLFA_SRVTYPE_IMP_EXEC~INIT_EXECUTION.

DATA:
  l_subrc type SYSUBRC.


* --------------------------------------------------------------------------
* - Initialize Member Variables
* --------------------------------------------------------------------------
  INIT_MEMBER_VARIABLES.
  INIT_MESSAGE_VARIABLES.    "used by ADD_MSG and ADD_REC_MSG

* "Export" selection criteria for subsequnt calls (per data package)
  MT_DATA_CHARSEL = I_T_DATA_CHARSEL.

ENDMETHOD. "INIT_EXECUTION


method INIT_MAP_TO_CUBESTRUCT.
* ----------------------------------------------------------------------------
* - Initializes the mapping table with ln_max_fields empty eintries for
* - Index access ! (=> "OCCURRS ln_max_fields")
* ----------------------------------------------------------------------------


  DATA:
    ln_Idx           type SYINDEX,  "Currrent Index for identified characteristic
    ln_max_fields    type i,        "Maximum number of fields in the file

    ls_map_to_cubestruct type T_S_MAP_TO_CUBESTRUCT.

  ln_Idx = 1.                   "
  ln_max_fields = CN_MAX_CHAS +
                  CN_MAX_KYFS.

  free: E_T_MAP_TO_CUBESTRUCT.

  clear ls_map_to_cubestruct.
  while ln_Idx <= ln_max_fields.
    ls_map_to_cubestruct-nIdx = ln_Idx.
    append ls_map_to_cubestruct to E_T_MAP_TO_CUBESTRUCT.
    ln_Idx = ln_Idx + 1.
  endwhile.

  clear E_SUBRC.

endmethod. "INIT_CUBESTRUCT


method RESTRUCTRE_RECORD.

FIELD-SYMBOLS:
  <lf_src> type ANY,
  <lf_dst> type ANY,
  <ls_map_to_cubestruct> type T_S_MAP_TO_CUBESTRUCT.

DATA:
  ln_Idx        type SYINDEX,
  ln_FilePos    type SYINDEX,
  ln_max_fields type SYINDEX.

  ln_Idx = 1.
  ln_max_fields = CN_MAX_CHAS +
                  CN_MAX_KYFS.
  while ln_Idx <= ln_max_fields.

    read table MT_MAP_TO_CUBESTRUCT
      assigning <ls_map_to_cubestruct>
      index ln_Idx.

    if sy-subrc = 0.

      ln_FilePos = <ls_map_to_cubestruct>-nFilePos.
      if ln_FilePos > 0.

        assign component ln_Idx     of structure ls_data_dst to <lf_dst>.
        assign component ln_FilePos of structure ls_data_src to <lf_src>.

*       Convert keyfigures according to User Defaults for "DeCimalPoint" and "ForMat"
        if <ls_map_to_cubestruct>-HEADER_TYPE = C_Y0XF_HEADER_TYPE-KYFS.

          call method _DCPFM exporting I_KYF = <lf_src>
                             importing E_KYF = <lf_dst>.

*       Copy field
        else.
          <lf_dst> = <lf_src>.
        endif.

        unassign: <lf_src>,
                  <lf_dst>.
      endif.
    endif.
    ln_Idx = ln_Idx + 1.
  endwhile.
  clear ln_Idx.

endmethod.


METHOD SAVE_AUTH_REL_FILTERS.

  FIELD-SYMBOLS:
    <ls_data>             type ANY,
    <LF_FIELD>            type ANY,
    <ls_head_to_dim_chas> type T_S_HEAD_TO_DIM,
    <ls_auth_rel_chas>    type T_TH_AUTH_REL_CHAS.

  DATA:
    ls_auth_rel_filters   type T_S_AUTH_REL_FILTERS,
    lt_auth_rel_filters   type T_T_AUTH_REL_FILTERS.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* --------------------------------------------------------------------------
* - Loop at the records and check for authorization relevant characteristics
* --------------------------------------------------------------------------
  free lt_auth_rel_filters.
  loop at I_T_DATA assigning <ls_data>.

    loop at I_TH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim_chas>.

      read table I_TH_AUTH_REL_CHAS

          with key IOBJNM = <ls_head_to_dim_chas>-FIELDNM_DST
          transporting no fields.

      if sy-subrc = 0.

        assign component <ls_head_to_dim_chas>-FIELDNM_SRC
            of structure <ls_data> to <LF_FIELD>.
        if sy-subrc = 0.

          clear ls_auth_rel_filters.
          ls_auth_rel_filters-/BIC/ZXF_UFID = I_S_FILEID-ZXF_UFID.
          ls_auth_rel_filters-TCTSYSID      = SY-SYSID.
          ls_auth_rel_filters-TCTOBJVERS    = rs_c_objvers-active.
          ls_auth_rel_filters-TCTIOBJNM     = <ls_head_to_dim_chas>-FIELDNM_DST.
          ls_auth_rel_filters-TCTSIGN       = rs_c_range_sign-including.
          ls_auth_rel_filters-TCTOPTION     = rs_c_range_opt-equal.
          ls_auth_rel_filters-TCTLOW        = <LF_FIELD>.
          collect ls_auth_rel_filters into lt_auth_rel_filters.
          clear ls_auth_rel_filters.

        endif.
        if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.
      endif.

    endloop. "I_TH_AUTH_REL_CHARS

  endloop. "I_T_DATA
  if  <ls_data> is assigned. unassign  <ls_data>.  endif.
  clear ls_auth_rel_filters.

  DATA: ln_NoRec type I.
  clear ln_NoRec.
  call function 'RSDRI_ODSO_INSERT' exporting I_ODSOBJECT = 'ZXF_E304'
                                              I_T_INSERT  = lt_auth_rel_filters
                                    importing E_RECORDS   = ln_NoRec.
  if sy-subrc <> 0.
*   458: Insert of author. relevant filter values into DSO ZXF_E304 failed.
    ADD_MSG 'E' '458' '' '' '' ''.
  else.

    COMMIT WORK.

*   480: Filter Values have been saved for File Id '&'.
    ADD_MSG 'I' '480' I_S_FILEID-ZXF_UFID '' '' ''.
  endif.

  C_T_REC_MSG[] = MT_REC_MSG[].    "The soubroutines used ADD_REC_MSG which uses the MT_REC_MSG.


ENDMETHOD.  "BUILD_AUTH_REL_FILTERS


method SEPARATE_SOURCE_TARGET_RECORDS.

  FIELD-SYMBOLS:
    <0INFOPROV>      type ANY,
    <ls_record>      type ANY.             "unknown record type (C_TH_DATA)

  free: E_T_STATUS[],
        E_T_SOURCE[],
        E_T_RECMSG[],
        E_T_OTHERS.

  E_SUBRC = 8.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  loop at I_TH_DATA assigning <ls_record>.

    assign component '0INFOPROV' of structure <ls_record> TO <0INFOPROV>.

*   Status record
    if <0INFOPROV> = C_CUBE-STATUS_ADMIN.
      append <ls_record> to E_T_STATUS.

*   Source record
    elseif <0INFOPROV> = C_CUBE-GENERIC_UPLOAD.
      append <ls_record> to E_T_SOURCE.

*   Record related messages
    elseif <0INFOPROV> = C_CUBE-MESSAGES.
      append <ls_record> to E_T_RECMSG.

    else.

      read table ST_CDM_UPLOAD_CUBES

        with key SOURCE = <0INFOPROV>   "Source CDM Upload Cube; Source for update into the reporting layer
        transporting no fields.

*     Target record
      if sy-subrc = 0.
        append <ls_record> to E_T_TARGET.     "CDM Upload CUbe

*     Others
      else.
        append <ls_record> to E_T_OTHERS.
      endif.
    endif.
  endloop.

  if  <ls_record> is assigned.
    unassign  <ls_record>.
  endif.

  clear E_SUBRC.

endmethod. "SEPARATE_SOURCE_TARGET_RECORDS


METHOD SET_STATUS.
* ----------------------------------------------------------------------------
* - Reads the status record from the status cube -> UFID
* - Checks the predecessor status if required.
* - Updates the status to the new status.
* -
* - Mainly used to:
* - ( 1 ) Check the status "VALID_FILE" and set the status to "NO_AUTHORIZATION"
* -       bevore copy to CDM Upload Cube  OR
* - ( 2 ) Check the status "NO_AUTHORIZATION" and reset the status to "VALID_FILE"
* -       after the copy to CDM Upload Cube.
* -
* - The function may also be called maunally in order to correct a
* - corrupt status.
* ----------------------------------------------------------------------------
* - 2012-10-05 (mh)
* - Don't raise an error message in case the predecessor status is not met.
* - The next step in the planning sequencne
* -
* -   * ZUP_M301_PSQ_100, "Upload Framework: File Upload"
* -
* - will check the status and save data in case of status INVALID_FILE:
* - EXEC_SAVE_DATA_ON_INVALID_FILE.
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,

    <lwa_data>       type ANY,             "WORK AREA, not a pointer
                                           "pointer into C_TH_DATA !!
    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE.

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA.


* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* ----------------------------------------------------------------------------
* - Create a work area for the resulting record
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.  clear lref_data.  "Status record

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>. clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>. clear lref_data.

* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.


* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status>.
  if sy-subrc <> 0.

*   312: No status record with appropriate status '&' could be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '312' '' '' '' ''.                      "The filter selects VALID status records only for copy
    ADD_MSG 'E' '313' '' '' '' ''.                      "Stop Planning sequence from execution.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the file id from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Check the status, if required and Change Status
* ----------------------------------------------------------------------------
  if I_B_CHECK_PRED = rs_c_false or
     MS_FILEID-ZXF_STAT = I_STATUS_PRED.

*   474: Set Status '&' ..
    ADD_MSG 'I' '474' I_STATUS_NEW '' '' ''.

*   --------------------------------------------------------------------------
*   - Update File ID
*   --------------------------------------------------------------------------
    MS_FILEID-ZXF_STAT = I_STATUS_NEW.                                             "<<<<<

  endif.


* ----------------------------------------------------------------------------
* - Update Status Record
* ----------------------------------------------------------------------------
  clear <lwa_data>.
  <lwa_data> = <ls_status>.

  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data>
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

  unassign <ls_status>.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert          <lwa_data>  into table C_TH_DATA.
  insert lines of <LT_SOURCE> into table C_TH_DATA.
  insert lines of <LT_TARGET> into table C_TH_DATA.
  insert lines of <LT_RECMSG> into table C_TH_DATA.
  insert lines of <LT_OTHERS> into table C_TH_DATA.

  free:
    <lwa_data>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>.


ENDMETHOD. "SET_STATUS


method STATUS_GET_INTO_FILEID.

  FIELD-SYMBOLS:
    <lf_field> type ANY.

  E_SUBRC = 8.

*   305: Field Symbol '&' couldn't be assigned.
*   ADD_MSG 'E' '305' 'xxx' '' '' ''.


* Unique File ID
  assign component 'ZXF_UFID'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_UFID   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UFID'   '' '' ''. RETURN. endif.
  assign component 'ZXF_LABEL'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_LABEL  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LABEL'  '' '' ''. RETURN. endif.
  assign component 'ZXF_FERR'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_FERR   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_FERR'   '' '' ''. RETURN. endif.
  assign component 'ZXF_FDEL'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_FDEL   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_FDEL'   '' '' ''. RETURN. endif.
  assign component 'ZXF_RUFID'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_RUFID  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_RUFID'  '' '' ''. RETURN. endif.

* Status
  assign component 'ZXF_STAT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_STAT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_STAT'   '' '' ''. RETURN. endif.

* Source Flag
  assign component 'ZXF_DSF'    of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_DSF    = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DSF'    '' '' ''. RETURN. endif.

* Statistics
  assign component '0TCTSYSID'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-0TCTSYSID  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' '0TCTSYSID'  '' '' ''. RETURN. endif.

  assign component 'ZXF_UPLBY'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_UPLBY  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UPLBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_UPLD'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_UPLD   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UPLD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_UPLT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_UPLT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UPLT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_SUBBY'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_SUBBY  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_SUBBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_REQD'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_REQD   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_REQD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_REQT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_REQT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_REQT'   '' '' ''. RETURN. endif.
  assign component 'ZXF_SUBD'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_SUBD   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_SUBD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_SUBT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_SUBT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_SUBT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_CANBY'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_CANBY  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_CANBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_CAND'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_CAND   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_CAND'   '' '' ''. RETURN. endif.
  assign component 'ZXF_CANT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_CANT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_CANT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_DELBY'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_DELBY  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DELBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_DRQD'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_DRQD   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DRQD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_DRQT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_DRQT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DRQT'   '' '' ''. RETURN. endif.
  assign component 'ZXF_DELD'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_DELD   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DELD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_DELT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_DELT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DELT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_LEDBY'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_LEDBY  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LEDBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_LEDD'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_LEDD   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LEDD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_LEDT'   of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_LEDT   = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LEDT'   '' '' ''. RETURN. endif.

* Keyfigures
  assign component 'ZXF_NFILE'  of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-ZXF_NFILE  = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_NFILE'  '' '' ''. RETURN. endif.
  assign component '0TCTNUMREC' of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-0TCTNUMREC = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' '0TCTNUMREC' '' '' ''. RETURN. endif.
  assign component '0TCTRECERR' of structure I_S_STATUS to <lf_field>. if sy-subrc = 0. E_S_FILEID-0TCTRECERR = <lf_field>. unassign <lf_field>. else. ADD_MSG 'E' '305' '0TCTRECERR' '' '' ''. RETURN. endif.

  clear E_SUBRC.

endmethod. "STATUS_SET_FROM_FILEID


method STATUS_SET_FROM_FILEID.

  FIELD-SYMBOLS:
    <lf_field> type ANY.

  E_SUBRC = 8.

*   305: Field Symbol '&' couldn't be assigned.
*   ADD_MSG 'E' '305' '' '' '' ''.

* Unique File ID
  assign component 'ZXF_UFID'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_UFID.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UFID'   '' '' ''. RETURN. endif.
  assign component 'ZXF_LABEL'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_LABEL.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LABEL'  '' '' ''. RETURN. endif.
  assign component 'ZXF_FERR'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_FERR.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_FERR'   '' '' ''. RETURN. endif.
  assign component 'ZXF_FDEL'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_FDEL.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_FDEL'   '' '' ''. RETURN. endif.
  assign component 'ZXF_RUFID'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_RUFID.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_RUFID'  '' '' ''. RETURN. endif.

* Status
  assign component 'ZXF_STAT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_STAT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_STAT'   '' '' ''. RETURN. endif.

* Source Flag
  assign component 'ZXF_DSF'    of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_DSF.    unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DSF'    '' '' ''. RETURN. endif.

* Statistics
  assign component '0TCTSYSID'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-0TCTSYSID.  unassign <lf_field>. else. ADD_MSG 'E' '305' '0TCTSYSID'  '' '' ''. RETURN. endif.
  assign component 'ZXF_UPLBY'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_UPLBY.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UPLBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_UPLD'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_UPLD.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UPLD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_UPLT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_UPLT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_UPLT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_SUBBY'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_SUBBY.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_SUBBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_REQD'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_REQD.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_REQD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_REQT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_REQT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZZXF_REQT'  '' '' ''. RETURN. endif.
  assign component 'ZXF_SUBD'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_SUBD.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_SUBD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_SUBT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_SUBT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_SUBT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_CANBY'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_CANBY.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_CANBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_CAND'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_CAND.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_CAND'   '' '' ''. RETURN. endif.
  assign component 'ZXF_CANT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_CANT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_CANT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_DELBY'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_DELBY.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DELBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_DRQD'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_DRQD.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DRQD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_DRQT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_DRQT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DRQT'   '' '' ''. RETURN. endif.
  assign component 'ZXF_DELD'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_DELD.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DELD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_DELT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_DELT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_DELT'   '' '' ''. RETURN. endif.

  assign component 'ZXF_LEDBY'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_LEDBY.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LEDBY'  '' '' ''. RETURN. endif.
  assign component 'ZXF_LEDD'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_LEDD.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LEDD'   '' '' ''. RETURN. endif.
  assign component 'ZXF_LEDT'   of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_LEDT.   unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_LEDT'   '' '' ''. RETURN. endif.

* Keyfigures
  assign component 'ZXF_NFILE'  of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-ZXF_NFILE.  unassign <lf_field>. else. ADD_MSG 'E' '305' 'ZXF_NFILE'  '' '' ''. RETURN. endif.
  assign component '0TCTNUMREC' of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-0TCTNUMREC. unassign <lf_field>. else. ADD_MSG 'E' '305' '0TCTNUMREC' '' '' ''. RETURN. endif.
  assign component '0TCTRECERR' of structure E_S_STATUS to <lf_field>. if sy-subrc = 0. <lf_field> = I_S_FILEID-0TCTRECERR. unassign <lf_field>. else. ADD_MSG 'E' '305' '0TCTRECERR' '' '' ''. RETURN. endif.

  clear E_SUBRC.

endmethod. "STATUS_SET_FROM_FILEID


METHOD UPDATE_STATUS_ANALYSE_RECORDS.
* ----------------------------------------------------------------------------
* - The filter provides either one File Id, which was "Submitted" by the user
* - or two File Id's: one deleting File Id, which has to be "Submitted" and
* - the related file Id, which has to be "Deleted"
* - Therefore following status updates are possible
* -
* - Always:
* - Update Status of File Id to either "Submitted"     (SUCCESS)
* -                                 or "Submit Failed" (FAILURE)
* -
* - In case of a "Delete" request:
* - Update the related file Id (which is to be deleted)
* -                          to either "Deleted"       (SUCCESS)
* -                                 or "Delted Failed" (FAILURE)
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LS_RECORD>      type ANY,
    <LF_FIELD>       type ANY,

    <ls_status>      type ANY,             "the status record as a pointer into a table, not a work area (given File Id)
    <ls_status_rel>  type ANY.             "the status record as a pointer into a table, not a work area (related File Id -to be deleted!))

  DATA:
    lref_data        type REF TO DATA,
    ln_Lines         type i,               "1 = SUBMIT; 2 = DELETE
    l_subrc          type SYSUBRC.


  E_SUBRC = 8.
  clear: E_S_FILEID,
         E_S_FILEID_REL.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

  if not E_R_STATUS     is initial. clear  E_R_STATUS.     endif.
  if not E_R_STATUS_REL is initial. clear  E_R_STATUS_REL. endif.


* ----------------------------------------------------------------------------
* - ANALYSE STATUS RECORD(S)
* ----------------------------------------------------------------------------
  if <ls_status>     is assigned. unassign <ls_status>.     endif.
  if <ls_status_rel> is assigned. unassign <ls_status_rel>. endif.

  clear ln_Lines.
  describe table I_T_STATUS lines ln_Lines.


* No Status record read
  if ln_Lines <= 0.
*   309: Status record could not be read.
*   313: ERROR RAISED IN ORDER TO PREVENT SUBSEQUENT STEPS FROM EXECUTION.
    ADD_MSG 'E' '309' '' '' '' ''.                  "
    ADD_MSG 'E' '313' '' '' '' ''.                  "Stop Planning sequence from execution.
    RETURN.

* Too many Status records read
  elseif ln_Lines > 2.
*   390: More than two status records provided.
    ADD_MSG 'E' '390' '' '' '' ''.
    RETURN.

* One Status record read (Submit Requested)
  elseif ln_lines = 1.  "SUBMIT

    read table I_T_STATUS index 1 assigning <ls_status>.
    if sy-subrc <> 0.
      RETURN.
    endif.

* Two Status records read:
* One "Submit Requested",
* One "Delete Requested" (related File Id to be deleted)
  elseif ln_lines = 2.  "DELETE

    loop at I_T_STATUS assigning <LS_RECORD>.

*     Flag: "Delete Request" ?
      assign component 'ZXF_FDEL' of structure <LS_RECORD> to <LF_FIELD>.
      if sy-subrc <> 0.
*       305: Field Symbol '&' couldn't be assigned.
        ADD_MSG 'E' '305' 'ZXF_FDEL' '' '' ''.
        RETURN.
      endif.

*     "Delete Request"
      if <LF_FIELD> = rs_c_true.

        if not <ls_status> is assigned.
          get reference of <LS_RECORD> into lref_data.
          assign lref_data->* to <ls_status>.
          clear lref_data.
        endif.

*     Related Request (to be deleted)
      else.

        if not <ls_status_rel> is assigned.
          get reference of <LS_RECORD> into lref_data.
          assign lref_data->* to <ls_status_rel>.
          clear lref_data.
        endif.
      endif.
    endloop.

  endif. "ln_nLines.

  if not <ls_status> is assigned.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Submit Requested or Delete Requested' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the FILE ID from the current status record
* ----------------------------------------------------------------------------
  clear: E_S_FILEID, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = E_S_FILEID
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check status of FILE ID "SUBMITREQ"                 (SUBMIT or DELETE !)
* --------------------------------------------------------------------------
  if E_S_FILEID-ZXF_STAT <> C_ZXF_STAT-SUBMITREQ      and
     E_S_FILEID-ZXF_STAT <> C_ZXF_STAT-SUBMIT_FAILED  and  "Re-Start ?
     E_S_FILEID-ZXF_STAT <> C_ZXF_STAT-DELETE_FAILED.      "Re-Start ?
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Submit Requested' '' '' ''.
    RETURN.
  endif.


* In case of DELETE, treat the related Status record
  if ln_lines = 2.

    if not <ls_status_rel> is assigned.
*     391: Related Status Record could not be read for File Id '&'
      ADD_MSG 'E' '391' MS_FILEID-ZXF_UFID '' '' ''.
      RETURN.
    endif.

*   ----------------------------------------------------------------------------
*   - Fill the RELATED FILE ID from the current status record
*   ----------------------------------------------------------------------------
    clear: E_S_FILEID_REL, l_subrc.
    call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status_rel>
                                                  I_R_MSG     = I_R_MSG
                                        importing E_S_FILEID  = E_S_FILEID_REL
                                                  E_SUBRC     = l_subrc.

    if l_subrc <> 0.
      RETURN.
    endif.

    if E_S_FILEID_REL-ZXF_STAT <> C_ZXF_STAT-DELETEREQ     and   "to be deleted
       E_S_FILEID_REL-ZXF_STAT <> C_ZXF_STAT-SUBMIT_FAILED and   "Re-Start ?
       E_S_FILEID_REL-ZXF_STAT <> C_ZXF_STAT-DELETE_FAILED.      "Re-Start ?
*     312: No status record with appropriate status '&' could be read.
      ADD_MSG 'E' '312' 'Delete Requested' '' '' ''.
      RETURN.
    endif.

  endif.

* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  CHECK ( <ls_status> is assigned ).         "MS_FILEID
  if ln_Lines = 2.
    CHECK ( <ls_status_rel> is assigned ).   "MS_FILEID_REL
  endif.
* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

* SUBMIT
  if ln_lines = 1.
    if MS_FILEID-ZXF_FDEL = rs_c_true.
*     392: The Delete Flag mustn't be set for "SUBMIT".
      ADD_MSG 'E' '393' '' '' '' ''.
      RETURN.
    endif.

* DELETE
  elseif ln_lines = 2.
    if MS_FILEID-ZXF_FDEL <> rs_c_true.
*     393: The Delete Flag must be set for "DELETE".
      ADD_MSG 'E' '393' '' '' '' ''.
      RETURN.
    endif.
    if MS_FILEID_REL-ZXF_FDEL = rs_c_true.
*     394: The Delete Flag must'nt be set for "DELETE".
      ADD_MSG 'E' '394' '' '' '' ''.
      RETURN.
    endif.
  endif.


* ----------------------------------------------------------------------------
* - Set Return Values
* ----------------------------------------------------------------------------
  if ln_lines = 1.

    E_UPDATE_MODE = C_UPDATE_MODE-SUBMIT.
    GET REFERENCE OF <ls_status>     into E_R_STATUS.

  else.

    E_UPDATE_MODE = C_UPDATE_MODE-DELETE.
    GET REFERENCE OF <ls_status>     into E_R_STATUS.
    GET REFERENCE OF <ls_status_rel> into E_R_STATUS_REL.

  endif.

  clear ln_Lines.
  if <ls_status>     is assigned. unassign <ls_status>.     endif.
  if <ls_status_rel> is assigned. unassign <ls_status_rel>. endif.

  clear E_SUBRC.

ENDMETHOD. "UPDATE_STATUS_ANALYSE_RECORDS


method VALIDATE_RECORD_CONTENT.

* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* ----------------------------------------------------------------------------
* - 341: Record '&' has invalid master data '&' for characteristic '&'. (Measure ID)
* - 351: Record '&' has no Measure ID.
* - 364: Record '&' Measure ID '&' Type '&' is not input enabled.
*#-#352: Record '&' has no scaling factor.#
* - 353: Record '&' has neither value nor periodic value.
* - 354: Record '&' has no period, but value.
* - 355: Record '&' has period and periodic value.
* - 356: Record '&' has value and periodic value.
* ----------------------------------------------------------------------------
* - Validation of Breakdown Characteristics for the given KPI_ID
* ----------------------------------------------------------------------------
* - ( 1 ) All mandatory characteristics must be provided
* - ( 2 ) characteristics, which are not mandatory, must not be provided
* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* ----------------------------------------------------------------------------
* - 363: Record '&' Measure ID '&' has no breakdown chars in the KPI DB.
* - 357: Record '&' Mandatory characteristic '&' for KPI '&' not provided.      "<<<< NO HEADER !
* - 358: Record '&' Mandatory characteristic '&' for KPI '&' not provided.      "<<<< COLUMN EMPTY !
* - 361: Record '&' Characteristic '&' must't be provided for Measure '&'.
* ----------------------------------------------------------------------------
* - Check "Unit", if conveniant:
* -   ( A ) Check "Correct Currency"     in case of "Amount" and
* -   ( B ) Check "Base Unit of Measure" in case of "Unit"
* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* - 365: Record '&' Measure ID '&' has no currency assigned to the amount.
* - 366: Record '&' Company Code couldn't be derived from Profit Center '&'.
* - 367: Record '&' Currency couldn't be derived from Comp.-Code '&'.
* - 369: Record '&' Measure Id '&' has no unit assigned to the quantity.
* - 370: Record '&' Measure Id '&' Amount '&' has no unit object / fixedcurr
* ----------------------------------------------------------------------------

* The conversion routines have been applied already.

FIELD-SYMBOLS:
  <l_field>            type ANY,
  <ls_meas_id>         type Y0BW_XF_MEAS_ID,
  <ls_head_to_dim>     type T_S_HEAD_TO_DIM,
  <ls_MEID_DIM>        type T_S_MEID_DIM.

  DATA:
    l_subrc           type SYSUBRC,
    lf_value          type f,
    l_ZXF_MEAS        type /BIC/OIZXF_MEAS, " 'Measure ID' for validation of breakdown characteristics
    lstr_ZXF_MEAS     type string,          "For Messages ..
    lf_calmonth2      type /BI0/OICALMONTH2,
    lf_calyear        type /BI0/OICALYEAR.

  clear l_ZXF_MEAS.

  clear MB_MSG_RECERR.
  E_ERRONEOUS = 'X'.

* ----------------------------------------------------------------------------
* - 305: Field Symbol '&' couldn't be assigned.
* - 322: A column header for the Measure ID is mandatory.
* - 341: Record '&' has invalid master data '&' for characteristic '&'.
* - 351: Record '&' has no Measure ID.
* ----------------------------------------------------------------------------
  clear: l_subrc, l_ZXF_MEAS, lstr_ZXF_MEAS.
  call method _GET_FROM_REC_ZXF_MEAS

      exporting I_S_REC     = I_S_RECORD
                I_RECNO     = I_REC_NO
                I_B_CDM     = rs_c_false      " 'X'=CDM Upload Cube Structure, ' ' = Upload Cube
                I_VALID_MD  = rs_c_true       "just get the ZXF_MEASID and validata master data existence
                I_LOG_MSG   = rs_c_true       "log messages 351, 341
                I_R_MSG     = I_R_MSG
      importing E_ZXF_MEAS  = l_ZXF_MEAS
*               E_S_MEAS_ID = ls_meas_id      "don't need the master data record
                E_SUBRC     = l_subrc.
  if l_subrc = 0.

    lstr_ZXF_MEAS = l_ZXF_MEAS.
    shift lstr_ZXF_MEAS left deleting leading '0'.  "for the message only !

*   --------------------------------------------------------------------------
*   - 364: Record '&' Measure ID '&' Type '&' is not input enabled.
*   - 363: Record '&' Measure ID '&' is not maintained properly in the KPI DB.   "besser: keine Aufrissmerkmale def. !
*   --------------------------------------------------------------------------
*   Ensure the Measure Id is valid for upload / write access
    read table STH_MEAS_ID assigning <ls_meas_id>
      with key MEASID = l_ZXF_MEAS.
    if sy-subrc = 0.

*     Check, if Measure Id is Input enabled (Basic)
      if <ls_meas_id>-TECHNICAL_TYPE <> C_Y0XF_TECHNICAL_TYPE-B.  "Input (Basic)

*       364: Record '&' Measure ID '&' Type '&' is not input enabled.
        ADD_REC_MSG 'W' '364' I_REC_NO lstr_ZXF_MEAS
                          <ls_meas_id>-TECHNICAL_TYPE ''.
        RETURN.
      endif.

      if <ls_meas_id>-ACTIVE <> rs_c_true.

*       469: Record '&' Measure Id '&' is not active.
        ADD_REC_MSG 'W' '469' I_REC_NO lstr_ZXF_MEAS '' ''.
        RETURN.
      endif.

    endif. "read table STH_MEAS_ID assigning <ls_meas_id>
    clear l_subrc. "check further errors ..
  endif.

* --------------------------------------------------------------------------
* - 470: Record '&' Scenario 'CRE' is not valid for uplaod.
* --------------------------------------------------------------------------
  read table MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>
    with key DIMNM = 'ZXF_SCEN'.
  if sy-subrc = 0.                                                "We should have passed the structural validation

    assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_RECORD to <l_field>.
    if sy-subrc = 0.
      if <l_field> = 'CRE'.

*       470: Record '&' Scenario 'CRE' is not valid for uplaod.
        ADD_REC_MSG 'W' '470' I_REC_NO '' '' ''.
      endif.
    endif.
    if <l_field> is assigned. unassign <l_field>. endif.
  endif.

* ----------------------------------------------------------------------------
* - 052: Record '&' has no scaling factor.    SCALING FACTOR NOT YET SUPPORTED
* ----------------------------------------------------------------------------
*  read table MTH_HEAD_TO_DIM_KYFS with key /BIC/ZKP_KFYTP = 'SCF'                "Typ: Scaling factor
*                                           assigning  <ls_head_to_dim>.
*  if sy-subrc = 0.                                                              "Column header exists for "Scalinf factor"
*    assign component <ls_head_to_dim>-FIELDNM_SRC                               "ZKP_UPL00
*        of structure I_S_RECORD to <l_field>.
*    if sy-subrc = 0.
*      clear lf_value.
*      lf_value = <l_field>.
*      if lf_value is initial.                                                    "Scaling factor "0"
**       052: Record '&' has no scaling factor.
*        ADD_REC_MSG 'W' '052' I_REC_NO '' '' ''.
*      endif.
*    endif.
*  endif.
*  clear lf_value.
*  if <l_field>        is assigned. unassign <l_field>.        endif.
*  if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

* ----------------------------------------------------------------------------
* - 053: 053: Record '&' has neither value nor periodic value. >>NULL FILE !!!
* ----------------------------------------------------------------------------
***  if MB_FILE_TYPE_KF = CSTR_FILETYPE_KF_VALUE.
***
***    read table MTH_HEAD_TO_DIM_KYFS with key /BIC/ZKP_KFYTP = 'VAL'                "Value
***                                           assigning  <ls_head_to_dim>.
***
***    assign component <ls_head_to_dim>-FIELDNM_SRC
***        of structure I_S_RECORD to <l_field>.
***
***    if sy-subrc = 0.
***      clear lf_value.
***      lf_value = <l_field>.
***      if lf_value is initial.                                                      "Value "0"
****       053: Record '&' has no value.
***        ADD_REC_MSG 'W' '053' I_REC_NO '' '' ''.
***      endif.
***    endif.
***
***  elseif MB_FILE_TYPE_KF = CSTR_FILETYPE_KF_PERIODIC.
***
***    DATA: lb_has_no_value type boolean value 'X'.
***    loop at MTH_HEAD_TO_DIM_KYFS assigning <ls_head_to_dim>
***      where /BIC/ZKP_KFYTP = 'PER'.
***
***      assign component <ls_head_to_dim>-FIELDNM_SRC
***          of structure I_S_RECORD to <l_field>.
***
***      if sy-subrc = 0.
***        clear lf_value.
***        lf_value = <l_field>.
***        if not lf_value is initial.                                                  "One Periodic Value <> "0"
***          clear lb_has_no_value.
***        endif.
***      endif.
***    endloop.
***    if not lb_has_no_value is initial.
***      ADD_REC_MSG 'W' '053' I_REC_NO '' '' ''.
***    endif.
***  endif.
***  if <l_field>        is assigned. unassign <l_field>.        endif.
***  if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

* ----------------------------------------------------------------------------
* - 054: Record '&' has no period, but value.
* ----------------------------------------------------------------------------
  if MSTR_FILE_TYPE_KF = C_FILETYPE_KYF-VALUE.         "ONE VALUE + 0CALMONTH2

    read table MTH_HEAD_TO_DIM_CHAS
       assigning  <ls_head_to_dim>
       with key HEADER_TYPE    = C_Y0XF_HEADER_TYPE-CHAS
                HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-TIMMONTH.

    if sy-subrc = 0.

      assign component <ls_head_to_dim>-FIELDNM_SRC
          of structure I_S_RECORD to <l_field>.

      if sy-subrc = 0.
        lf_calmonth2 = <l_field>.
        if lf_calmonth2 is initial.
*         354: Record '&' has no period, but value.
          ADD_REC_MSG 'W' '354' I_REC_NO '' '' ''.
        endif.
        clear lf_calmonth2.
      endif.

    endif.
    if <l_field>        is assigned. unassign <l_field>.        endif.
    if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

* ----------------------------------------------------------------------------
* - 055: Record '&' has period and periodic value.
* ----------------------------------------------------------------------------
  elseif MSTR_FILE_TYPE_KF = C_FILETYPE_KYF-PERIODIC.    "VALUE RANGE [JAN..DEC]    "Has already been inhibited by the structural
                                                                                  "validation !!! Anyway, ..
    read table MTH_HEAD_TO_DIM_CHAS
       assigning  <ls_head_to_dim>
       with key HEADER_TYPE    = C_Y0XF_HEADER_TYPE-CHAS
                HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-TIMMONTH.
                                             .
    if sy-subrc = 0.

      assign component <ls_head_to_dim>-FIELDNM_SRC
          of structure I_S_RECORD to <l_field>.   "

      if sy-subrc = 0.
        lf_calmonth2 = <l_field>.
        if not lf_calmonth2 is initial.
*         055: Record '&' has period and periodic value.
          ADD_REC_MSG 'W' '055' I_REC_NO '' '' ''.
        endif.
        clear lf_calmonth2.
      endif.
    endif.
  endif. "MSTR_FILE_TYPE_KF = C_FILETYPE_KYF-VALUE.
  if <l_field>        is assigned. unassign <l_field>.        endif.
  if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.


* ----------------------------------------------------------------------------
* - 056: Record '&' has value and periodic value.
* ----------------------------------------------------------------------------
* OBSOLET, IF A SINGLE FILE CAN HAVE ONLY "VALUE" OR "PERIODIC VALUES"


* Ensure the record has a valid KPI_ID for validation of breakdown characteristics
  if not l_ZXF_MEAS is initial.

*   --------------------------------------------------------------------------
*   - Validation of Breakdown Characteristics for the given Measure Id
*   --------------------------------------------------------------------------
*   - ( 1 ) All mandatory characteristics must be provided
*   - ( 2 ) characteristics, which are not mandatory, must not be provided
*   --------------------------------------------------------------------------
    call method VALIDATE_RECORD_CONTENT_BRKDWN

        exporting I_REC_NO   = I_REC_NO
                  I_S_RECORD = I_S_RECORD
                  I_R_MSG    = I_R_MSG.

*   --------------------------------------------------------------------------
*   - Check "Unit", if conveniant:
*   -   ( A ) Check "Correct Currency"     in case of "Amount" and
*   -   ( B ) Check "Base Unit of Measure" in case of "Unit"
*   --------------------------------------------------------------------------
    call method VALIDATE_RECORD_CONTENT_UNITS

        exporting I_REC_NO   = I_REC_NO
                  I_S_RECORD = I_S_RECORD
                  I_R_MSG    = I_R_MSG.


*   --------------------------------------------------------------------------
*   - Check Filter values
*   --------------------------------------------------------------------------
    call method VALIDATE_RECORD_CONTENT_FILTER

        exporting I_REC_NO    = I_REC_NO
                  I_S_RECORD  = I_S_RECORD
                  I_R_MSG     = I_R_MSG.

  endif.  "not l_ZXF_MEAS is initial.


* Check for errors
* MN_MSG
  if MB_MSG_RECERR is initial.
    clear E_ERRONEOUS.
  endif.
  clear MB_MSG_RECERR.     "clear Flag/Record for the next record

endmethod.  "VALIDATE_RECORD_CONTENT



* ============================================================================
* = E O F
* ============================================================================

* ----------------------------------------------------------------------------
* - 351: Record '&' has no Measure ID.
* ----------------------------------------------------------------------------
*  read table MTH_HEAD_TO_DIM_CHAS with key DIMNM = 'ZXF_MEAS'
*                                           assigning  <ls_head_to_dim>.
*  if sy-subrc = 0.                                                              "Column header exists for "KPI ID"
*    assign component <ls_head_to_dim>-FIELDNM_SRC
*        of structure I_S_RECORD to <l_field>.   "ZXF_MEAS
*    if sy-subrc = 0.
*      if <l_field> is initial.
**       351: Record '&' has no Measure ID.
*        ADD_REC_MSG 'W' '351' I_REC_NO '' '' ''.
*      else.
*        l_ZXF_MEAS = <l_field>.                                                  "Save KPI_ID for further processing
*      endif.
*    endif.
*  endif.
*  if <l_field>        is assigned. unassign <l_field>.        endif.
*  if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

* ----------------------------------------------------------------------------
* - 341: Invalid master data '&' for characteristic 'Measure Id'.
* ----------------------------------------------------------------------------
*  read table STH_MEAS_ID with key MEASID   = l_ZXF_MEAS
*                                  OBJVERS  = RS_C_OBJVERS-ACTIVE
*    transporting no fields.
*
*  if sy-subrc <> 0.
**   341: Record '&' has invalid master data '&' for characteristic '&'.
*    ADD_REC_MSG 'W' '341' I_REC_NO l_ZXF_MEAS 'Measure ID' ''.
*  endif.


method validate_record_content_brkdwn.

* ----------------------------------------------------------------------------
* - Validation of Breakdown Characteristics for the given KPI_ID
* ----------------------------------------------------------------------------
* - ( 1 ) All mandatory characteristics must be provided
* - ( 2 ) characteristics, which are not mandatory, must not be provided
* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* ----------------------------------------------------------------------------
* - 363: Record '&' Measure ID '&' has no breakdown chars in the KPI DB.
* - 357: Record '&' Mandatory characteristic '&' for KPI '&' not provided.      "<<<< NO HEADER !
* - 358: Record '&' Mandatory characteristic '&' for KPI '&' not provided.  "<<<< COLUMN EMPTY !
* - 361: Record '&' Characteristic '&' must't be provided for Measure '&'.
* ----------------------------------------------------------------------------

* The conversion routines have been applied already.

  field-symbols:
    <l_field>            type any,
    <l_field_int>        type any,
    <ls_meas_id>         type y0bw_xf_meas_id,
    <ls_head_to_dim>     type t_s_head_to_dim,
    <ls_meid_dim>        type t_s_meid_dim.

  data:
    l_subrc           type sysubrc,
    lf_value          type f,
    l_zxf_meas        type /bic/oizxf_meas, " 'Measure ID' for validation of breakdown characteristics
    lstr_zxf_meas     type string.          " for Meassages

  clear l_zxf_meas.


* ----------------------------------------------------------------------------
* - 305: Field Symbol '&' couldn't be assigned.
* - 322: A column header for the Measure ID is mandatory.
* - 341: Record '&' has invalid master data '&' for characteristic '&'.
* - 351: Record '&' has no Measure ID.
* ----------------------------------------------------------------------------
  clear: l_subrc, l_zxf_meas, lstr_zxf_meas.
  call method _get_from_rec_zxf_meas
    exporting
      i_s_rec     = i_s_record
      i_recno     = i_rec_no
      i_b_cdm     = rs_c_false      " 'X'=CDM Upload Cube Structure, ' ' = Upload Cube
      i_valid_md  = rs_c_true       "just get the ZXF_MEASID and validata master data existence
      i_log_msg   = rs_c_true       "log messages 351, 341
      i_r_msg     = i_r_msg
    importing
      e_zxf_meas  = l_zxf_meas
*     E_S_MEAS_ID = ls_meas_id      "don't need the master data record
      e_subrc     = l_subrc.

* Ensure the record has a valid Measure Id
* for validation of breakdown characteristics
  if l_subrc = 0 and
     not l_zxf_meas is initial.

    lstr_zxf_meas = l_zxf_meas.
    shift lstr_zxf_meas left deleting leading '0'.  "for the message only !

*   Ensure KPI_ID has maintained breakdown characteristics in the KPI database
    read table mth_meid_dim with key measid = l_zxf_meas
        transporting no fields.
    if sy-subrc <> 0.
*     363: Record '&' Measure ID '&' has no breakdown chars in the KPI DB.
      add_msg 'W' '363' i_rec_no l_zxf_meas '' ''.
    else.

*     ----------------------------------------------------------------------------
*     - Validation of Breakdown Characteristics for the given KPI_ID
*     ----------------------------------------------------------------------------
*     - ( 1 ) All MANDATORY characteristics MUST be provided
*     ----------------------------------------------------------------------------
      loop at mth_meid_dim                              "measure id / dimension for all
                                                        "measure id's in the current file
          assigning <ls_meid_dim>
          where measid = l_zxf_meas.

*       Check "relevant" characteristics ...
        if    <ls_meid_dim>-optional <> rs_c_true       "skip optional characteristics

*         =========================================================================================
          and <ls_meid_dim>-dimnm    <> '0CALMONTH2'    "skip the cal. month since the file is
                                                        "         of either type
                                                        "                 C_FILETYPE_KYF-VALUE or
                                                        "                 C_FILETYPE_KYF-PERIODIC
                                                        "         and thus the cal. month will be
                                                        "         created in any case.
          and <ls_meid_dim>-dimnm    <> 'ZXF_CURT'      "skip currency type, since we derive it
*         =========================================================================================

*         =========================================================================================
          and <ls_meid_dim>-dimnm    <> '0CALMONTH'     "skip the compounded time char, used by Reporting Set "GEN"
          and <ls_meid_dim>-dimnm    <> '0FISCPER'      "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0FISCPER3'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0FISCVARNT'    "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0FISCYEAR'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0CALQUART1'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0WEEKDAY1'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0HALFYEAR1'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0CALQUARTER'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0CALWEEK'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> '0CALDAY'     "skip 'mandatory' time chars, which will be drived during upload *) 2012-06-05 (mh)
          and <ls_meid_dim>-dimnm    <> 'ZXF_CURR'      "skip currency, will be checked for keyfiguretype "Amount"
          and <ls_meid_dim>-dimnm    <> '0BASE_UOM'     "skip unit,     will be checked for keyfiguretype "Quantity"
          and <ls_meid_dim>-dimnm    <> 'ZXF_QUSU'      "need to skip reporting relevant units ?
          and <ls_meid_dim>-dimnm    <> 'ZXF_QUEA'.     "need to skip reporting relevant units ?
*         =========================================================================================

          read table mth_head_to_dim_chas               "mapping: dimesnion -> source characteristic

              assigning  <ls_head_to_dim>
              with key dimnm  = <ls_meid_dim>-dimnm.

*         The mandatory charactersitic has not been provided in the file
*         since no header description exists for this characteristic. The
*         column is not provided by the filestructure.
*         Already caught by the structural validation, anyway ..
          if sy-subrc <> 0.

*           357: Record '&' No Header '&' for Measure ID '&' provided.          "<<<< NO HEADER !
            add_rec_msg 'W' '357' i_rec_no <ls_meid_dim>-dimnm
                                    "  <ls_head_to_dim>-COL_HEAD_LOW      "replace by Name -> look up
                                       lstr_zxf_meas ''.

          else.

            assign component <ls_head_to_dim>-fieldnm_src
                of structure i_s_record to <l_field>.

            if sy-subrc = 0.

              assign <ls_head_to_dim>-ls_treatment_chas-ref_val_int->* to <l_field_int>.
              if sy-subrc = 0.
                clear <l_field_int>.                                        "clear data type (internal format)

                if <l_field> is initial or                                  "
                   <l_field> = <l_field_int>.                               "ALPHA Conversion results in e.g. '0000' for numeric values

*               358: Record '&' Mandatory characteristic '&' for KPI '&' not provided.  "<<<< COLUMN EMPTY !
                  add_rec_msg 'W' '358' i_rec_no <ls_head_to_dim>-col_head_low lstr_zxf_meas ''.
                endif.
              endif.
            endif.
            if <l_field> is assigned. unassign <l_field>. endif.
          endif. "read table MTH_HEAD_TO_DIM_CHAS
          if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.
        endif. "<ls_MEID_DIM>-OPTIONAL = rs_c_false.

      endloop. "MTH_MEID_DIM

      if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>.  endif.
      if <ls_meid_dim>    is assigned. unassign <ls_meid_dim>.     endif.

*     ----------------------------------------------------------------------------
*     - Validation of Breakdown Characteristics for the given KPI_ID
*     ----------------------------------------------------------------------------
*     - ( 2 ) characteristics, which are NOT MAINTAINED as break-down
*             characteristics at all are neither if MANDATORY nor OPTIONAL and
*             therefore MUST NOT be provided.
*     ----------------------------------------------------------------------------
      loop at mth_head_to_dim_chas                           "characteristics in the file

          assigning <ls_head_to_dim>

          where header_subtype = space.                      "Skip: Time, Unit, Currency
*           and HEADER_TYPE    = C_Y0XF_HEADER_TYPE-CHAS     "Implicite

*       if <ls_head_to_dim>-DIMNM <> 'ZXF_MEAS'.             "Skip: Measure Id

        assign component <ls_head_to_dim>-fieldnm_src
            of structure i_s_record to <l_field>.

        if sy-subrc = 0.                                   "Should not fail ...

          assign <ls_head_to_dim>-ls_treatment_chas-ref_val_int->* to <l_field_int>.
          clear <l_field_int>.                                        "clear data type (internal format)
          if not <l_field> is initial and                     "Skip: Empty Chatacteristics (=> other Measure ID !)
                 <l_field> <> <l_field_int>.                  "ALPHA Conversion results in e.g. '0000' for numeric values




            read table mth_meid_dim                        "measure id / dimension for all
                                                           "measure id's in the current file

                with key measid = l_zxf_meas
                         dimnm  = <ls_head_to_dim>-dimnm
                transporting no fields.
            if sy-subrc <> 0 and <ls_head_to_dim>-ls_treatment_chas-ref_val_int is not initial. "Field was not derrived.

*               361: Record '&' Characteristic '&' must't be provided for Measure '&'.
              add_rec_msg 'W' '361' i_rec_no <ls_head_to_dim>-dimnm
                                             lstr_zxf_meas ''.

            endif.
          endif. "not <lf_field> is initial.

        endif. "assign component <ls_head_to_dim>-FIELDNM_SRC
        if <l_field> is assigned. unassign <l_field>. endif.

*       endif.  "<ls_head_to_dim>-DIMNM <> 'ZXF_MEAS'.
      endloop. "MTH_HEAD_TO_DIM_CHAS
      if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

    endif. "Ensure KPI_ID has maintained breakdown characteristics in the KPI database

  endif. "not l_ZKP_MEID is initial

endmethod.  "VALIDATE_RECORD_CONTENT_BRKDWN


method VALIDATE_RECORD_CONTENT_FILTER.

* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* ----------------------------------------------------------------------------
* 372: Record '&' Measure Id '&' Empty Dimension '&' has a filter assigned.
* 373: Record '&' Measure Id '&' Dimension '&' value '&' invalid by filter.
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <l_field>         type ANY,
    <ls_head_to_dim>  type T_S_HEAD_TO_DIM,
    <ls_MEAS_FIS>     type Y0BW_XF_MEAS_FIS.

  DATA:
    l_subrc           type SYSUBRC,
    lb_covered        type RSBOOL,          "dimension value covered by filter value (true: Valid)
    l_ZXF_MEAS        type /BIC/OIZXF_MEAS, " 'Measure ID' for validation of breakdown characteristics
    lstr_ZXF_MEAS     type STRING.          " for Meassages

  clear l_ZXF_MEAS.


* Get the Measure Id from the Record
  clear: l_subrc, l_ZXF_MEAS, lstr_ZXF_MEAS.
  call method _GET_FROM_REC_ZXF_MEAS

      exporting I_S_REC     = I_S_RECORD
                I_RECNO     = I_REC_NO
                I_B_CDM     = rs_c_false      " 'X'=CDM Upload Cube Structure, ' ' = Upload Cube
                I_VALID_MD  = rs_c_true       "get the ZXF_MEASID and validata master data existence
                I_LOG_MSG   = rs_c_true       "log messages 351, 341
                I_R_MSG     = I_R_MSG
      importing E_ZXF_MEAS  = l_ZXF_MEAS
*               E_S_MEAS_ID = ls_meas_id      "don't need the master data record
                E_SUBRC     = l_subrc.

* Ensure the record has a valid Measure Id
* for validation of Filters per Measure Id
  if l_subrc = 0 and
     not l_ZXF_MEAS is initial.

    lstr_ZXF_MEAS = l_ZXF_MEAS.
    shift lstr_ZXF_MEAS left deleting leading '0'.  "for the message only !

*   --------------------------------------------------------------------------
*   - Loop at the Characteristics in the File and check,
*   - if Filter Values have been defined for the current dimension
*   --------------------------------------------------------------------------
    loop at MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>.

*     Check, if Filter value(s) exist for the current Dimension
      read table MTS_MEID_FIS

          with key MEASID   = l_ZXF_MEAS
                   PURPOSE  = C_Y0XF_PURPOSE-UPL              "Upload Framework
                   DIMNM    = <ls_head_to_dim>-DIMNM

          transporting no fields.

*     Filter values defined for Dimension DIMNM
      if sy-subrc = 0.

*       Read value for the Dimension form the record
        assign component <ls_head_to_dim>-FIELDNM_SRC
                of structure I_S_RECORD to <l_field>.
        if sy-subrc = 0.

*         Dimension has a value assigned in the record:
*         Check against the filter values
          if <l_field> is initial.

*           372: Record '&' Measure Id '&' Empty Dimension '&' has a filter assigned.
            ADD_REC_MSG 'W' '372' I_REC_NO lstr_ZXF_MEAS <ls_head_to_dim>-COL_HEAD_LOW ''.

          else.

            lb_covered = rs_c_false.
            loop at MTS_MEID_FIS assigning <ls_MEAS_FIS>

                where MEASID  = l_ZXF_MEAS
                  and PURPOSE  = C_Y0XF_PURPOSE-UPL              "Upload Framework
                  and DIMNM    = <ls_head_to_dim>-DIMNM.

              if <ls_MEAS_FIS>-SIGN = rs_c_range_sign-including.
                case <ls_MEAS_FIS>-OPT.

                  when rs_c_range_opt-equal.        if <l_field> EQ <ls_MEAS_FIS>-LOW. lb_covered = rs_c_true. EXIT. endif.
                  when rs_c_range_opt-less.         if <l_field> LT <ls_MEAS_FIS>-LOW. lb_covered = rs_c_true. EXIT. endif.
                  when rs_c_range_opt-lessequal.    if <l_field> LE <ls_MEAS_FIS>-LOW. lb_covered = rs_c_true. EXIT. endif.
                  when rs_c_range_opt-greater.      if <l_field> GT <ls_MEAS_FIS>-LOW. lb_covered = rs_c_true. EXIT. endif.
                  when rs_c_range_opt-greaterequal. if <l_field> GE <ls_MEAS_FIS>-LOW. lb_covered = rs_c_true. EXIT. endif.
                  when rs_c_range_opt-pattern.      if <l_field> CP <ls_MEAS_FIS>-LOW. lb_covered = rs_c_true. EXIT. endif.

                  when rs_c_range_opt-between.      if <l_field> GE <ls_MEAS_FIS>-LOW  and
                                                       <l_field> LE <ls_MEAS_FIS>-HIGH.
                                                        lb_covered = rs_c_true.
                                                        EXIT.                     "exit loop.
                                                    endif.
                endcase.
              endif.
            endloop.

            if lb_covered = rs_c_false.
*             373: Record '&' Measure Id '&' Dimension '&' value '&' invalid by filter.
              ADD_REC_MSG 'W' '373' I_REC_NO lstr_ZXF_MEAS <ls_head_to_dim>-COL_HEAD_LOW <l_field>.
            endif.

          endif. "<lf_field> is initial
        endif. "assign component <l_field>
      endif. "Check, if Filter value(s) exist for the current Dimension

    endloop. "MTH_HEAD_TO_DIM_CHAS

  endif. "not l_ZXF_MEAS is initial

endmethod.  "VALIDATE_RECORD


method VALIDATE_RECORD_CONTENT_UNITS.

* ----------------------------------------------------------------------------
* - Check "Unit", if conveniant:
* -   ( A ) Check "Correct Currency"     in case of "Amount" and
* -   ( B ) Check "Base Unit of Measure" in case of "Unit"
* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* - 365: Record '&' Measure ID '&' has no currency assigned to the amount.
* - 366: Record '&' Company Code couldn't be derived from Profit Center '&'.
* - 367: Record '&' Currency couldn't be derived from Comp.-Code '&'.
* - 369: Record '&' Measure Id '&' has no unit assigned to the quantity.
* - 370: Record '&' Measure Id '&' Amount '&' has no unit object / fixedcurr
* - 378: Record '&' Measure Id '&' Unit '&' <> Default Unit '&'.
* ----------------------------------------------------------------------------

* ----------------------------------------------------------------------------
  FIELD-SYMBOLS:
    <l_field>            type ANY,
    <ls_head_to_dim>     type T_S_HEAD_TO_DIM,
    <ls_MEID_DIM>        type T_S_MEID_DIM,
    <ls_treatment_kyfs>  type T_S_TREATMENT_KYFS,
    <ls_mpct_curr>       type T_S_MPCT_CURR.


  DATA:
    l_subrc              type SYSUBRC,
    lf_value             type f,
    l_ZXF_MEAS           type /BIC/OIZXF_MEAS, " 'Measure ID' for validation of breakdown characteristics
    lstr_ZXF_MEAS        type STRING,          " for Meassages
    ls_meas_id           type Y0BW_XF_MEAS_ID,
    l_MPCT               type /BIC/OIZXF_MPCT,
    l_CurrencyRec        type /BI0/OICURRENCY,     "Currency provided by the record
    l_CurrencyChk        type /BI0/OICURRENCY,     "Currency derived from CompCode
    l_UnitRec            type /BI0/OIUNIT,
    lstr_expected        type string.

  clear l_ZXF_MEAS.


* ----------------------------------------------------------------------------
* - 305: Field Symbol '&' couldn't be assigned.
* - 322: A column header for the Measure ID is mandatory.
* - 341: Record '&' has invalid master data '&' for characteristic '&'.
* - 351: Record '&' has no Measure ID.
* ----------------------------------------------------------------------------
  clear: l_subrc, l_ZXF_MEAS, lstr_ZXF_MEAS.
  call method _GET_FROM_REC_ZXF_MEAS

      exporting I_S_REC     = I_S_RECORD
                I_RECNO     = I_REC_NO
                I_B_CDM     = rs_c_false      " 'X'=CDM Upload Cube Structure, ' ' = Upload Cube
                I_VALID_MD  = rs_c_true       "just get the ZXF_MEASID and validata master data existence
                I_LOG_MSG   = rs_c_true       "log messages 351, 341
                I_R_MSG     = I_R_MSG
      importing E_ZXF_MEAS  = l_ZXF_MEAS
                E_S_MEAS_ID = ls_meas_id      "keyfigure type Unit/Currency,
                E_SUBRC     = l_subrc.

* Ensure the record has a valid Measure Id
* for validation of breakdown characteristics
  if l_subrc = 0 and
     not l_ZXF_MEAS is initial.

    lstr_ZXF_MEAS = l_ZXF_MEAS.
    shift lstr_ZXF_MEAS left deleting leading '0'.  "for the message only !

*   ----------------------------------------------------------------------------
*   - Check "Unit", if conveniant:
*   -   ( A ) Check "Correct Currency"     in case of "Currency" and
*   -   ( B ) Check "Base Unit of Measure" in case of "Unit"
*   -   ( C ) Check Keyfigure type         in case of "Number"
*   ----------------------------------------------------------------------------
    CASE ls_meas_id-UNIT_TYPE.

*   ==========================================================================
*   = ( A ) Check "Correct Currency" in case of "Amount" and
*   ==========================================================================
    when C_Y0XF_UNIT_TYPE-C. "Currency

*     The Measure Id is assigned to (physical) keyfigure <> "Amount"
      if ls_meas_id-PHYS_KEY_FIGURE <> C_Y0XF_PHYS_KEY_FIGURE-ZXF_AMNT and
         ls_meas_id-PHYS_KEY_FIGURE <> C_Y0XF_PHYS_KEY_FIGURE-ZXF_AMNF.

        clear lstr_expected.
        concatenate C_Y0XF_PHYS_KEY_FIGURE-ZXF_AMNT
                    C_Y0XF_PHYS_KEY_FIGURE-ZXF_AMNF
                    into lstr_expected separated by ', '.

*       377: Record '&' Measure Id '&' has assigned Keyfigure '&'. Expected '&'.
        ADD_MSG 'I' '377' I_REC_NO lstr_ZXF_MEAS
                          ls_meas_id-PHYS_KEY_FIGURE
                          lstr_expected.
      endif.

*     ------------------------------------------------------------------------
*     - Read the keyfigure's meta info and
*     - either get the fixed currency
*     - or the info object for the currency
*     ------------------------------------------------------------------------
      clear: l_CurrencyRec, l_CurrencyChk.
      read table MT_TREATMENT_KYFS
        with key PHYS_KEY_FIGURE = ls_meas_id-PHYS_KEY_FIGURE
        assigning <ls_treatment_kyfs>.
      if sy-subrc = 0.

*       The Measure Id's Unit Type doesn't match the Keyfigure Type of the
*       Physical Keyfigure, which is assigned to the Measure Id.
        if <ls_treatment_kyfs>-KYFTP <> rsd_c_kyftp-amount.

*         374: Record '&' Measure Id '&' Unit Type 'Currency'<>Kfy-Typ '&' of '&'.
          ADD_REC_MSG 'W' '374' I_REC_NO lstr_ZXF_MEAS
                                <ls_treatment_kyfs>-KYFTP
                                ls_meas_id-PHYS_KEY_FIGURE.

        else.

*         Get the fixed currency from the physical keyfigure's meta info
          if not <ls_treatment_kyfs>-FIXCUKY is initial.
            l_CurrencyRec = <ls_treatment_kyfs>-FIXCUKY.

*         Get the info object for the currency from the Record
          else.

            if <ls_treatment_kyfs>-UNINM is initial.
*             370: Record '&' Measure Id '&' Amount '&' has no unit object / fixedcurr
              ADD_REC_MSG 'W' '370' lstr_ZXF_MEAS ls_meas_id-PHYS_KEY_FIGURE '' ''.
            else.
              if <ls_treatment_kyfs>-UNINM <> 'ZXF_CURR'.
*               ADD_MSG 'I' maybe sth wrong .. ??
              endif.
              read table MTH_HEAD_TO_DIM_CHAS
                assigning <ls_head_to_dim>
                with key DIMNM = <ls_treatment_kyfs>-UNINM.
              if sy-subrc = 0.
                assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_RECORD to <l_field>.
                if sy-subrc = 0.
                  l_CurrencyRec = <l_field>.
                  unassign <l_field>.
                endif.
              endif.
            endif. "<ls_treatment_kyfs>-UNINM is initial
          endif. "not <ls_treatment_kyfs>-FIXCUKY is initial.

*         ----------------------------------------------------------------------
*         - Currency is known
*         ----------------------------------------------------------------------
          if l_CurrencyRec is initial.
*           365: Record '&' Measure ID '&' has no currency assigned to the amount.
            ADD_REC_MSG 'W' '365' I_REC_NO  lstr_ZXF_MEAS  '' ''.
          else.

*           Currency "EUR" is always allowed ..
            if l_CurrencyRec <> 'EUR'.

*             Check Currency for the given Management Profitcenter
              clear l_MPCT.
              read table MTH_HEAD_TO_DIM_CHAS
                  assigning <ls_head_to_dim>
                  with key DIMNM = 'ZXF_MPCT'.
              if sy-subrc = 0.
                assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_RECORD to <l_field>.
                if sy-subrc = 0.
                  l_MPCT = <l_field>.

                  read table STH_MPCT_CURR
                    assigning <ls_mpct_curr> with key ZXF_MPCT = l_MPCT
                                                      ZXF_CURR = l_CurrencyRec.
                  if sy-subrc <> 0.
*                   371: Record '&' Measure Id '&' Currency '&' is not allowed for MPCT '&'.
                    ADD_REC_MSG 'W' '371' I_REC_NO lstr_ZXF_MEAS  l_CurrencyRec l_MPCT.
                  endif.
                endif.
              endif. "read table MTH_HEAD_TO_DIM_CHAS

            endif. "l_CurrencyRec <> 'EUR'
          endif. "l_Currency is initial.
        endif. "if <ls_treatment_kyfs>-KYFTP <> rsd_c_kyftp-amount
      endif. "read table MT_TREATMENT_KYFS

*   ==========================================================================
*   = ( B ) Check "Base Unit of Measure" in case of "Unit"
*   ==========================================================================
    when C_Y0XF_UNIT_TYPE-U. "Unit

      clear l_UnitRec.
*     The Measure Id is assigned to (physical) keyfigure "Quantity"
      if ls_meas_id-PHYS_KEY_FIGURE <> C_Y0XF_PHYS_KEY_FIGURE-ZXF_QUAN and
         ls_meas_id-PHYS_KEY_FIGURE <> C_Y0XF_PHYS_KEY_FIGURE-ZXF_QUAF.

        clear lstr_expected.
        concatenate C_Y0XF_PHYS_KEY_FIGURE-ZXF_NUMB
                    C_Y0XF_PHYS_KEY_FIGURE-ZXF_NUMF
                    into lstr_expected separated by ', '.

*       377: Record '&' Measure Id '&' has assigned Keyfigure '&'. Expected '&'.
        ADD_MSG 'I' '377' I_REC_NO lstr_ZXF_MEAS
                          ls_meas_id-PHYS_KEY_FIGURE
                          lstr_expected.
      endif.

*     Read the keyfigure's meta info and
*     get the info object for the unit
      read table MT_TREATMENT_KYFS
        with key PHYS_KEY_FIGURE = ls_meas_id-PHYS_KEY_FIGURE
        assigning <ls_treatment_kyfs>.
      if sy-subrc = 0.

*       The Measure Id's Unit Type doesn't match the Keyfigure Type of the
*       Physical Keyfigure, which is assigned to the Measure Id.
        if <ls_treatment_kyfs>-KYFTP <> rsd_c_kyftp-quantity.

*         375: Record '&' Measure Id '&' Unit Type 'Unit'<>Kfy-Typ '&' of Keyf.'&'.
          ADD_REC_MSG 'W' '375' I_REC_NO lstr_ZXF_MEAS
                                <ls_treatment_kyfs>-KYFTP
                                ls_meas_id-PHYS_KEY_FIGURE.
        else.

*         Get the info object for the Unit
          if <ls_treatment_kyfs>-UNINM is initial.
*           ADD_MSG
          else.
            if <ls_treatment_kyfs>-UNINM <> '0BASE_UOM'.
*             ADD_MSG maybe sth wrong .. ??
            endif.
            read table MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim> with key DIMNM = <ls_treatment_kyfs>-UNINM.
            if sy-subrc = 0.
              assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_RECORD to <l_field>.
              if sy-subrc = 0.
                l_UnitRec = <l_field>.                               "The Unit provided in the record
                unassign <l_field>.
              endif.
            endif.
          endif. "<ls_treatment_kyfs>-UNINM is initial
        endif. "<ls_treatment_kyfs>-KYFTP <> rsd_c_kyftp-quantity
      endif. "read table MT_TREATMENT_KYFS

      if l_UnitRec is initial.
*       369: Record '&' Measure Id '&' has no unit assigned to the quantity.
        ADD_MSG 'W' '369' I_REC_NO lstr_ZXF_MEAS '' ''.

*     check Unit against Default Unit
      else.

        FIELD-SYMBOLS: <ls_meas_id> type Y0BW_XF_MEAS_ID.
        read table STH_MEAS_ID
          assigning <ls_meas_id>
          with key MEASID = l_ZXF_MEAS.
        if sy-subrc = 0.

*         Unit conversion is not allowed => Provide only default unit !
          if <ls_meas_id>-UNIT_CONVERSION <> rs_c_true.

            if l_UnitRec <> <ls_meas_id>-DEFAULT_UNIT.

*             378: Record '&' Measure Id '&' Unit '&' <> Default Unit '&'.
              ADD_REC_MSG 'W' '378' I_REC_NO lstr_ZXF_MEAS
                                l_UnitRec
                                <ls_meas_id>-DEFAULT_UNIT.

            endif. "l_UnitRec <> <ls_meas_id>-DEFAULT_UNIT.
          endif. "<ls_meas_id>-UNIT_CONVERSION <> rs_c_true.
        endif. "read table STH_MEAS_ID
      endif. "l_UnitRec is initial.

*   ==========================================================================
*   = ( C ) Check Keyfigure type in case of "Number"
*   ==========================================================================
    when C_Y0XF_UNIT_TYPE-N. "Numbers

*     The Measure Id is assigned to (physical) keyfigure "Number"
      if ls_meas_id-PHYS_KEY_FIGURE <> C_Y0XF_PHYS_KEY_FIGURE-ZXF_NUMB and
         ls_meas_id-PHYS_KEY_FIGURE <> C_Y0XF_PHYS_KEY_FIGURE-ZXF_NUMF.

        clear lstr_expected.
        concatenate C_Y0XF_PHYS_KEY_FIGURE-ZXF_NUMB
                    C_Y0XF_PHYS_KEY_FIGURE-ZXF_NUMF
                    into lstr_expected separated by ', '.

*       377: Record '&' Measure Id '&' has assigned Keyfigure '&'. Expected '&'.
        ADD_MSG 'I' '377' I_REC_NO lstr_ZXF_MEAS
                          ls_meas_id-PHYS_KEY_FIGURE
                          lstr_expected.
      endif.

*     Read the keyfigure's meta info and
*     get the info object for the unit
      read table MT_TREATMENT_KYFS
        with key PHYS_KEY_FIGURE = ls_meas_id-PHYS_KEY_FIGURE
        assigning <ls_treatment_kyfs>.
      if sy-subrc = 0.

*       The Measure Id's Unit Type doesn't match the Keyfigure Type of the
*       Physical Keyfigure, which is assigned to the Measure Id.
        if <ls_treatment_kyfs>-KYFTP <> rsd_c_kyftp-number and
           <ls_treatment_kyfs>-KYFTP <> rsd_c_kyftp-integer.

*         376: Record '&' Measure Id '&' Unit Type 'Number'<>Kfy-Typ '&' of Keyf.'&
          ADD_REC_MSG 'W' '376' I_REC_NO lstr_ZXF_MEAS
                                <ls_treatment_kyfs>-KYFTP
                                ls_meas_id-PHYS_KEY_FIGURE.
        endif.
      endif.

    ENDCASE. "ls_meas_id-UNIT_TYPE.

  endif. "not l_ZXF_MEAS is initial

endmethod.  "VALIDATE_RECORD_CONTENT_UNITS







*****DATA: *       l_ProfitCenter type /BI0/OIPROFIT_CTR,
******       l_CompCode     type /BI0/OICOMP_CODE,
*****
******         Get the Company Code from the Record
*****          read table MTH_HEAD_TO_DIM_CHAS
*****              assigning <ls_head_to_dim>
*****              with key DIMNM = '0COMP_CODE'.
*****          if sy-subrc = 0.
*****            assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_RECORD to <l_field>.
*****            if sy-subrc = 0.
*****              l_CompCode = <l_field>.
*****            endif.
*****
******         Get the Profitcenter from the Record, then look up the Comp.-Code assigned to it
*****          else.
*****            read table MTH_HEAD_TO_DIM_CHAS
*****                assigning <ls_head_to_dim>
*****                with key DIMNM = '0PROFIT_CTR'.
*****            if sy-subrc = 0.
*****              assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_RECORD to <l_field>.
*****              if sy-subrc = 0.
******               look up Comp.-Code for Profitcenter
*****                clear: l_subrc, l_CompCode.
*****                l_ProfitCenter = <l_field>.
*****                CALL METHOD Y0BW_CL_XF_UTILITIES=>GET_COMP_CODE_FROM_PROFIT_CTR
*****
*****                    exporting I_CO_AREA    = 'RB01'
*****                              I_PROFIT_CTR = l_ProfitCenter
*****                    importing E_COMP_CODE  = l_CompCode
*****                              E_SUBRC      = l_subrc.
*****                if l_subrc <> 0.
******                 366: Record '&' Company Code couldn't be derived from Profit Center '&'.
*****                  ADD_REC_MSG 'W' '366' I_REC_NO l_ProfitCenter '' ''.
*****                endif.
*****              endif.
*****            endif.
*****          endif.
*****
******         Look up Currency for the given Comp.-Code
*****          if not l_CompCode is initial.
*****
*****            clear: l_subrc, l_CurrencyChk.
*****            CALL METHOD Y0BW_CL_XF_UTILITIES=>GET_CURR_FROM_COMP_CODE
*****
*****                exporting I_COMP_CODE = l_CompCode
*****                importing E_CURRENCY  = l_CurrencyChk
*****                          E_SUBRC     = l_subrc.
*****
*****            if l_subrc <> 0.
******             367: Record '&' Currency couldn't be derived from Comp.-Code '&'.
*****              ADD_REC_MSG 'W' '367' I_REC_NO l_CompCode '' ''.
*****            endif.
*****            if not l_CurrencyChk is initial.
*****
*****              if l_CurrencyRec <> l_CurrencyChk.
******               365: Record '&' Measure Id '&' has currency '&' <> '&'.
*****                ADD_REC_MSG 'W' '365' I_REC_NO  lstr_ZXF_MEAS l_CurrencyRec l_CurrencyChk.
*****              endif.
*****
*****            endif. "l_CurrencyChk
*****          endif. "l_CompCodeRec


method validate_upload_data.

  field-symbols:
    <ls_data>        type any,
    <0infoprov>      type any,
    <lt_cdm_chas>    type standard table.  "The Records with chars moved to CDM characteristics


  data:
    l_subrc           type sysubrc,
    lref_data         type ref to data.


* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* --------------------------------------------------------------------------
* - Initialize return parameters
* --------------------------------------------------------------------------
  clear: e_nrecerr.
  e_zxf_stat = c_zxf_stat-file_not_readable.                                        " <<<< S T A T U S


  free:
    mth_measure_id,
    mth_meid_dim,
    mts_meid_fis.

* --------------------------------------------------------------------------
* - Mandatory Breakdown Dimensions by KPI ID
* --------------------------------------------------------------------------
  clear l_subrc.
  call method me->build_breakdown_meid_dim
    exporting
      i_s_file        = i_s_status      "depends on chars in file, cannot
                                                        "be done during construction / initialization !
      i_t_data        = c_t_data        "create list of measure id's from the file
      i_r_msg         = i_r_msg
    importing
      e_subrc         = l_subrc         "
      e_th_measure_id = mth_measure_id  "List of Measure Id's in the current File
      e_th_meas_dim   = mth_meid_dim.   "Break-Down Characteristics (w. OPTIONAL) by Measure Id

  if l_subrc <> 0.
    return.
  endif.

* --------------------------------------------------------------------------
* - Filter values by Measure Id / Dimension
* --------------------------------------------------------------------------
  clear l_subrc.
  call method fill_filter_meas_fis
    exporting
      i_r_msg         = i_r_msg
      i_th_measure_id = mth_measure_id
    importing
      e_subrc         = l_subrc
      e_ts_meid_fis   = mts_meid_fis.

  if l_subrc <> 0.
    return.
  endif.

* ==========================================================================
* = ( 1 ) Validate the header information
* ==========================================================================
* 451:Validate Header ..                      " -> TRANSPORM_FILE
* ADD_MSG 'I' '451' '' '' '' ''.

  call method validation_step1_header
    exporting
      i_r_msg            = i_r_msg
    importing
      e_str_file_type_kf = mstr_file_type_kf.

  if mn_msg > 0.    "ADD_MSG ..

*   316: FILE NOT READABLE. The file's structure is not valid.
    add_msg 'W' '316' '' '' '' ''.

*   307: ERRORS OCCURRED. PROCESSING TERMINATED.
    add_msg 'W' '307' '' '' '' ''.
    e_zxf_stat = c_zxf_stat-file_not_readable.                                      " <<<< S T A T U S

  endif.


* ----------------------------------------------------------------------------
* - Create table for a local copy of C_TH_DATA for the CDM characteristics
* ----------------------------------------------------------------------------
  if mn_msg = 0.

    data: lf_rsview2 type rsviewtiobjnm2.         "View: InfoObjects + Nav.Attr. with InfoObject field names(2)
    call function 'RSD_TNAMES_GET_FOR_CUBE'
      exporting
        i_infocube     = 'ZXF_M301'
      importing
        e_viewtiobjnm2 = lf_rsview2.

    create data lref_data type standard table of (lf_rsview2).
    assign lref_data->* to <lt_cdm_chas>.
    clear: lref_data, lf_rsview2.

    call method create_cdm_data_for_validation
      exporting
        i_r_msg               = i_r_msg
        i_th_head_to_dim_chas = mth_head_to_dim_chas
        i_t_data              = c_t_data
      changing
        c_t_cdm_chas          = <lt_cdm_chas>.

  endif.

* ==========================================================================
* = ( 4 ) Process Validation Rules
* ==========================================================================
  if mn_msg = 0.

*   482: Process Validation Rules.
    add_msg 'I' '482' '' '' '' ''.

    call method validation_step4_check_rules
      exporting
        i_r_msg               = i_r_msg
      importing
        e_nrecerr             = e_nrecerr
      changing
        c_s_status            = i_s_status
        i_th_head_to_dim_chas = mth_head_to_dim_chas
        c_t_rec_msg           = c_t_rec_msg
        c_t_cdm_chas          = <lt_cdm_chas>
        c_t_data              = c_t_data.

    if mn_msg > 0.
*     483:INVALID FILE. The file violates at least one validation rule.
      add_msg 'W' '483' '' '' '' ''.

*     307: ERRORS OCCURRED. PROCESSING TERMINATED.
      add_msg 'W' '307' '' '' '' ''.
      e_zxf_stat = c_zxf_stat-invalid_file.                                         " <<<< S T A T U S
    endif.

  endif. "MN_MSG = 0

* ==========================================================================
* = ( 2 ) Validate master data
* ==========================================================================
  if mn_msg = 0.

*   452: Validate Master Data ..
    add_msg 'I' '452' '' '' '' ''.

    call method validation_step2_master_data
      exporting
        i_r_msg               = i_r_msg
        i_th_head_to_dim_chas = mth_head_to_dim_chas
      importing
        e_nrecerr             = e_nrecerr
      changing
        c_t_rec_msg           = c_t_rec_msg
        c_t_cdm_chas          = <lt_cdm_chas>
        c_t_data              = c_t_data.

    if mn_msg > 0.
*     342: INVALID FILE. The file contains invalid master data.
      add_msg 'W' '342' '' '' '' ''.

*     307: ERRORS OCCURRED. PROCESSING TERMINATED.
      add_msg 'W' '307' '' '' '' ''.
      e_zxf_stat = c_zxf_stat-invalid_file.                                         " <<<< S T A T U S
    endif.

  endif. "MN_MSG = 0



* ==========================================================================
* = ( 3 ) Validate Content
* ==========================================================================
  if mn_msg = 0.

*   453: Validate Content:
    add_msg 'I' '453' '' '' '' ''.

*   456: Check characteristics provided in excess of mandatory breakdown char
    add_msg 'I' '456' '' '' '' ''.
*   457: Check Filter Values ..
    add_msg 'I' '457' '' '' '' ''.
    call method validation_step3_content
      exporting
        i_r_msg               = i_r_msg
        i_th_head_to_dim_chas = mth_head_to_dim_chas
      importing
        e_nrecerr             = e_nrecerr
      changing
        c_t_rec_msg           = c_t_rec_msg
        c_t_data              = c_t_data.

    if mn_msg > 0.
*     317: 317: INVALID FILE. The file contains records, which are not valid.
      add_rec_msg 'W' '317' '0' '' '' ''.

*     307: ERRORS OCCURRED. PROCESSING TERMINATED.
      add_rec_msg 'W' '307' '0' '' '' ''.
      e_zxf_stat = c_zxf_stat-invalid_file.                                         " <<<< S T A T U S
    endif.

  endif. "MN_MSG = 0.


* --------------------------------------------------------------------------
* - Set Status
* --------------------------------------------------------------------------
  if mn_msg = 0.

    e_zxf_stat = c_zxf_stat-valid_file.                                             " <<<< S T A T U S

*   318: VALID FILE. The file passed the validations: Structure/MD/Content.
    add_msg 'I' '318' '' '' '' ''.

  endif.

* ----------------------------------------------------------------------------
* - Return Errors and Messages
* ----------------------------------------------------------------------------
* E_NRECERR     = ln_RecErr.       "Has been set properly above
* E_ZXF_STAT    = C_ZXF_STAT- ...  "Has been set properly above
  c_t_rec_msg[] = mt_rec_msg[].    "The soubroutines used ADD_REC_MSG which uses the MT_REC_MSG.

  free: mt_rec_msg.
* clear: MN_ERR, MN_WAR, MN_MSG, MN_MSG_RECNO, MN_MSG_LINNO.

  if <lt_cdm_chas> is assigned. free: <lt_cdm_chas>. endif.

* --------------------------------------------------------------------------
* - Initialize Member Variables used by ADD_MSG and ADD_REC_MSG
* --------------------------------------------------------------------------
* INIT_MESSAGE_VARIABLES.

endmethod.  "VALIDATE_UPLOAD_DATA


method VALIDATION_STEP1_HEADER.

* ----------------------------------------------------------------------------
* - Messages covered by the validation of the header information
* ----------------------------------------------------------------------------
* - 321: .. Header column '&' cannot be mapped to an existing dimension.
* - 322: .. A column header  for the KPI information is mandatory.
*#-#323: .. A column header for the scaling factor is mandatory.#
* - 324: .. A column header for either a value or a periodic value is mandatory.   "ASSUME: EITHER OR in one file !
* - 325: .. A column header for the period is mandatory in case of value.
* - 326: .. A column header for the period must not be provided in case of perio
* - 327: .. Column header for value and periodic value must not be prov. simul??   "ASSUME: EITHER OR in one file !
* ----------------------------------------------------------------------------

FIELD-SYMBOLS:
  <ls_head_to_dim>     type T_S_HEAD_TO_DIM.

  clear:
    E_STR_FILE_TYPE_KF.

* ----------------------------------------------------------------------------
* - 321: Header column '&' cannot be mapped to an existing dimension.
* ----------------------------------------------------------------------------

* C H A R A C R E R I S T I C S
  loop at MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>.

    read table STH_HEAD with key HEADER_TYPE = C_Y0XF_HEADER_TYPE-CHAS
                                 COL_HEADER  = <ls_head_to_dim>-COL_HEADER
                                 transporting no fields.

    if sy-subrc <> 0.
*     321: Header column '&' cannot be mapped to an existing dimension.
      ADD_MSG     'W' '321' <ls_head_to_dim>-COL_HEAD_LOW '' '' ''.
    endif.

  endloop. "MTH_HEAD_TO_DIM_CHAS
  if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

* K E Y F I G U R E S
  loop at MTH_HEAD_TO_DIM_KYFS assigning <ls_head_to_dim>.

    read table STH_HEAD with key HEADER_TYPE = C_Y0XF_HEADER_TYPE-KYFS
                                 COL_HEADER  = <ls_head_to_dim>-COL_HEADER
                                 transporting no fields.

    if sy-subrc <> 0.
*     321: Header column '&' cannot be mapped to an existing dimension.
      ADD_MSG 'W' '321' <ls_head_to_dim>-COL_HEAD_LOW '' '' ''.
    endif.

  endloop. "MTH_HEAD_TO_DIM_KYFS
  if <ls_head_to_dim> is assigned. unassign <ls_head_to_dim>. endif.

* ----------------------------------------------------------------------------
* - 322: A column header for the KPI information is mandatory.
* ----------------------------------------------------------------------------
  read table MTH_HEAD_TO_DIM_CHAS with key DIMNM = 'ZXF_MEAS'          "besser: /BIC/ZKP_KFYTP = 'KPI'
                                           transporting no fields.
   if sy-subrc <> 0.
*    322: A column header for the KPI information is mandatory.
     ADD_MSG 'W' '322' '' '' '' ''.
   endif.

** ----------------------------------------------------------------------------
** - 023: A column header for the scaling factor is mandatory.                    SCALING FACTOR NOT YET SUPPORTED
** ----------------------------------------------------------------------------
*  read table MTH_HEAD_TO_DIM_KYFS with key /BIC/ZKP_KFYTP = 'SCF'                "Typ: Scaling factor
*                                           transporting no fields.
*   if sy-subrc <> 0.
**    023: A column header for the scaling factor is mandatory.
*     ADD_MSG 'E' '023' '' '' '' ''.
*   endif.

* ============================================================================
* = 324: A column header for either a value or a periodic value is mandatory.   "ASSUME: EITHER OR in one file !
* = 325: A column header for the period is mandatory in case of value.
* = 326: A column header for the period must not be provided in case of perio
* = 327: Column header for value and periodic value must not be prov. simul??
* ============================================================================
  DATA: lb_value   type boolean,
        lb_perval  type boolean,
        lb_period  type boolean.

  clear: lb_value, lb_perval, lb_period.

* Value field (non periodic; 0CALMONTH2 in the record)
  read table MTH_HEAD_TO_DIM_KYFS with key HEADER_TYPE    = C_Y0XF_HEADER_TYPE-KYFS
                                           HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-KFYVAL
                                           transporting no fields.
  if sy-subrc = 0.
    lb_value = rs_c_true.
  endif.

* Periodic Value field(s); Each column represents a specific period
  read table MTH_HEAD_TO_DIM_KYFS with key HEADER_TYPE    = C_Y0XF_HEADER_TYPE-KYFS
                                           HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-KFYMON
                                           transporting no fields.
  if sy-subrc = 0.
    lb_perval = rs_c_true.
  endif.

* Period
  read table MTH_HEAD_TO_DIM_CHAS with key HEADER_TYPE    = C_Y0XF_HEADER_TYPE-CHAS
                                           HEADER_SUBTYPE = C_Y0XF_HEADER_SUBTYPE-TIMMONTH
                                           transporting no fields.
  if sy-subrc = 0.
    lb_period = rs_c_true.
  endif.

* ----------------------------------------------------------------------------
* - 324: A column header for either a value or a periodic value is mandatory.   "ASSUME: EITHER OR in one file !
* ----------------------------------------------------------------------------
  if lb_value  = rs_c_false    and
     lb_perval = rs_c_false.
    ADD_MSG 'W' '324' '' '' '' ''.
  endif.

* ----------------------------------------------------------------------------
* - 325: A column header for the period is mandatory in case of value.
* ----------------------------------------------------------------------------
  if lb_value  = rs_c_true and
     lb_period = rs_c_false.
    ADD_MSG 'W' '325' '' '' '' ''.
  endif.

* ----------------------------------------------------------------------------
* - 326: A column header for the period must not be provided in case of perio
* ----------------------------------------------------------------------------
  if lb_perval = rs_c_true and
     lb_period = rs_c_true.
    ADD_MSG 'W' '326' '' '' '' ''.
  endif.

* ----------------------------------------------------------------------------
* - 327: Column header for value and periodic value must not be prov. simul??
* ----------------------------------------------------------------------------
  if lb_value  = rs_c_true and
     lb_perval = rs_c_true.
    ADD_MSG 'W' '327' '' '' '' ''.
  endif.

* Filetyp: VALUE
  if     lb_value  = rs_c_true  and
         lb_perval = rs_c_false and
         lb_period = rs_c_true.

    E_STR_FILE_TYPE_KF = C_FILETYPE_KYF-VALUE.

* Filetyp: PERIODIC VALUES
  elseif     lb_value  = rs_c_false  and
             lb_perval = rs_c_true   and
             lb_period = rs_c_false.

    E_STR_FILE_TYPE_KF = C_FILETYPE_KYF-PERIODIC.

* Filetype couldn't be recognized
  else.
*   310: Filetyp VALUE or PERIODIC VALUE could'nt be recognized.
    ADD_MSG 'W' '310' '' '' '' ''.
  endif.

endmethod.  "VALIDATE_HEADER


METHOD VALIDATION_STEP2_MASTER_DATA.

  FIELD-SYMBOLS:
    <LF_FIELD>       type ANY,

    <ls_source>      type ANY,             "the source record as a pointer into a table, not a work area
    <ls_target>      type ANY,             "the target record as a pointer into a table, not a work area

    <LT_CDM_CHAS>    type STANDARD TABLE,  "The Records with chars moved to CDM characteristics

    <ls_head_to_dim_chas> type T_S_HEAD_TO_DIM.

  DATA:
    l_subrc           type SYSUBRC,
    ls_charnm type Y0XFU_T_S_CHARNM,        "List of characteristics, which are
    lt_charnm type Y0XFU_T_T_CHARNM.        "to be validated along with buffering mode.


* ----------------------------------------------------------------------------
* - Create the list of charcteristics, which are to be validated.
* ----------------------------------------------------------------------------
  free  lt_charnm.
  loop at I_TH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim_chas>.

    clear ls_charnm.
    ls_charnm-RSIOBJNM     = <ls_head_to_dim_chas>-DIMNM.                               "=FIELDNM_DST

*   --------------------------------------------------------------------------
*   ACTIVATE SINGLE RECORD BUFFERING (SRB) FOR CHARACTERISTICS WITH HUGE CARDINALITY.
*   BETTER: READ BUFFER MODE FROM TABLE Y0BW_XF_UPHEADER AND SUPPORT FULLY BUFFERED
*           USING TRANSACTION DATA AS FILTER VALUES !!!
*   --------------------------------------------------------------------------                         SRB
*    1  ZXF_SCEN     |  X X   Table[initial|Table[initial]|Table[        7  x120]  |Scenario       <
*    2  0CALYEAR     |  X X   Table[initial|Table[initial]|Table[       12  x120]  |Year           <
*    3  0CALMONTH2   |        Table[initial|Table[initial]|Table[       13  x120]  |Month          <
*    4  ZXF_MEAS     |  X X   Table[initial|Table[initial]|Table[    6.742  x12|   |MeasureID      <
*    5  ZXF_MPCT     |  X X   Table[initial|Table[initial]|Table[      430  x120|  |MgmtPC         <
*    6  ZXF_SBBRN    |  X X   Table[initial|Table[initial]|Table[       66  x120]  |Subbrand       <
*    7  0CO_AREA     |  X X   Table[initial|Table[initial]|Table[       15  x120]  |COArea         <
*    8  ZXF_CURR     |  X X   Table[initial|Table[initial]|Table[      183  x120   |Currency       <
*    9  0BASE_UOM    |  X X   Table[initial|Table[initial]|Table[      298  x120   |Unit           <
*    10 0COMP_CODE   |  X X   Table[initial|Table[initial]|Table[      182  x120   |CompanyCode    <
*    11 0PROFIT_CTR  |X X X   Table[1x132] |Table[initial]|Table[    2.850  x12    |ProfitCenter   <
*    12 0COSTCENTER  |X X X   Table[1x132] |Table[initial]|Table[    8.997  x12    |CostCenter     <
*    13 0COORDER     |  X X   Table[0x132] |Table[initial]|Table[  610.532  x      |InternalOrder  <  (X)
*    14 0PLANT       |  X X   Table[0x132] |Table[initial]|Table[      196  x120   |Plant          <
*    15 0MATERIAL    |  X X   Table[0x132] |Table[initial]|Table[   38.891  x1     |Material       <  (X)
*    16 0SALESORG    |  X X   Table[0x132] |Table[initial]|Table[       91  x120]  |SalesOrg       <
*    17 0DIVISION    |        Table[0x132] |Table[initial]|Table[       20  x120]  |Division       <
*    18 0DISTR_CHAN  |        Table[0x132] |Table[initial]|Table[       25  x120]  |DistrChannel   <
*    19 0SOLD_TO     |  X X   Table[0x132] |Table[initial]|Table[  135.824  x      |SoldToParty    <  (X)
*    20 0SHIP_TO     |  X X   Table[0x132] |Table[initial]|Table[  135.824  x      |ShipTo         <  (X)
*    21 0CUST_SALES  |X X X   Table[3x132] |Table[initial]|Table[  347.826  x      |CustomerSales  <  (X)
*    22 ZXF_AGEG     |  X X   Table[0x132] |Table[initial]|Table[       16  x120]  |AgeGroup       <
*    23 ZXF_ACLAS    |  X X   Table[0x132] |Table[initial]|Table[       36  x120]  |AccountClass   <
*    24 ZPARTNER     |  X X   Table[0x132] |Table[initial]|Table[1.462.803         |Partner        <  (X)
*    25 0PAYER       |  X X   Table[0x132] |Table[initial]|Table[  135.824  x      |Payer          <  (X)
*    26 ZBT_CPROJ    |  X X   Table[0x132] |Table[initial]|Table[      155  x120]  |
*   --------------------------------------------------------------------------

    case ls_charnm-RSIOBJNM.

*     Don't read master data in advance, single record buffering instead
      when '0COORDER'
        or '0MATERIAL'
        or '0SOLD_TO'
        or '0SHIP_TO'
        or '0CUST_SALES'
        or 'ZPARTNER'
        or '0PAYER'
        or 'ZPRT_SEND'
        or 'ZPRT_RECV'
        or 'ZPRT_REMP'.

        ls_charnm-BUFF_MODE = Y0BW_CL_XF_UP_MD_VALIDATION=>MD_BUFF_MODE-SINGLE_REC_BUFF. "

*     Buffer Method: Fully buffered
      when others.

        ls_charnm-BUFF_MODE = Y0BW_CL_XF_UP_MD_VALIDATION=>MD_BUFF_MODE-FULLY_BUFFERED.

    endcase.

    ls_charnm-COL_HEAD_LOW = <ls_head_to_dim_chas>-COL_HEAD_LOW.                        "Column Header as delivered
                                                                                        "(not translated to uppcer case)
                                                                                        "for messages
    append ls_charnm to lt_charnm.

  endloop. "I_TH_HEAD_TO_DIM_CHAS
  if <ls_head_to_dim_chas> is assigned. unassign <ls_head_to_dim_chas>. endif.
  clear ls_charnm.

* ----------------------------------------------------------------------------
* - Create instance of validation object or init buffer
* ----------------------------------------------------------------------------
  if MOREF_MD_VALIDATION is initial.

    create object MOREF_MD_VALIDATION                   "It's buffer is static !
      exporting I_T_CHARNM = lt_charnm.

  else.

    call method MOREF_MD_VALIDATION->INIT_BUFFER        "It's buffer is static !
      exporting I_T_CHARNM = lt_charnm.

  endif.

* ----------------------------------------------------------------------------
* - Validate master data
* ----------------------------------------------------------------------------
  DATA: ln_tot type I,
        ln_msg type I,
        ln_err type I,
        ln_war type I,
        ln_inf type I,

        lt_rec_msg type T_T_REC_MSG.

  clear: ln_tot, ln_msg, ln_err, ln_war, ln_inf.
  free: lt_rec_msg.
  call method MOREF_MD_VALIDATION->MD_VALIDATE_DATA

      exporting I_T_CHARNM         = lt_charnm
                I_R_MSG            = I_R_MSG
                I_FLAGNCNT_ERR_REC = rs_c_true     "mark erroneous records and set erroneous records counter
      importing E_NRECERR          = E_NRECERR
                E_MN_TOT           = ln_tot
                E_MN_MSG           = ln_msg
                E_MN_ERR           = ln_err
                E_MN_WAR           = ln_war
                E_MN_INF           = ln_inf
                C_T_REC_MSG        = lt_rec_msg
      changing  C_T_DATA           = C_T_CDM_CHAS.

      append lines of lt_rec_msg to MT_REC_MSG.

* ----------------------------------------------------------------------------
* - copy back flag "Record erroneous" and erroneous record counter
* ----------------------------------------------------------------------------
  DATA: ln_RecNo type i.
  clear ln_RecNo.
  loop at C_T_CDM_CHAS assigning <ls_target>.

    assign component 'ZXF_FERR' of structure <ls_target> to <LF_FIELD>.
    if sy-subrc = 0.

*     Record has been marked as erroneous
      if <LF_FIELD> = 'X'.

        unassign <LF_FIELD>.
        assign component 'ZXF_RECNO' of structure <ls_target> to <LF_FIELD>.
        if sy-subrc = 0.

          ln_RecNo = <LF_FIELD>.
          unassign <LF_FIELD>.

*         look up erroneous record in the generic uplaod cube structure
          loop at C_T_DATA assigning <ls_source>.

            assign component 'ZXF_RECNO' of structure <ls_source> to <LF_FIELD>.
            if sy-subrc = 0.

              if <LF_FIELD> = ln_RecNo.
                unassign <LF_FIELD>.
                assign component 'ZXF_FERR'   of structure <ls_source> to <LF_FIELD>. if sy-subrc = 0. <LF_FIELD> = 'X'. unassign <LF_FIELD>. endif. "Mark record as erroneous
                assign component '0TCTRECERR' of structure <ls_source> to <LF_FIELD>. if sy-subrc = 0. <LF_FIELD> =  1.  unassign <LF_FIELD>. endif. "Count erroneous records
              endif.
            endif.
          endloop. "C_T_DATA
          if <ls_source> is assigned. unassign <ls_source>. endif.

        endif.
      endif.
    endif.

  endloop. "<LT_CDM_CHAS>
  if <ls_target> is assigned. unassign <ls_target>. endif.

  MN_TOT = MN_TOT + ln_tot.
  MN_MSG = MN_MSG + ln_msg.
  MN_WAR = MN_WAR + ln_war.
  MN_ERR = MN_ERR + ln_err.
  MN_INF = MN_INF + ln_inf.

  free:
    lt_charnm.

ENDMETHOD.  "VALIDATE_MASTER_DATA


METHOD VALIDATION_STEP3_CONTENT.

  FIELD-SYMBOLS:
    <ls_data>        type ANY,
    <LF_FIELD>       type any.

  DATA:
    ln_NoMessages    type I,
    ln_RecNo         type I,
    lb_erroneous     type RS_BOOL.

* --------------------------------------------------------------------------
* - Loop at the records and validate each record
* --------------------------------------------------------------------------
  clear ln_RecNo.
  loop at C_T_DATA assigning <ls_data>.

    clear lb_erroneous.

*   Get the Record Number form the Record
    clear ln_RecNo.
    assign component 'ZXF_RECNO' of structure <ls_data> to <LF_FIELD>.
    if sy-subrc = 0.
      ln_RecNo = <LF_FIELD>.
    endif.
    if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

*   Validate Record (Content Validation)
    call method me->VALIDATE_RECORD_CONTENT

        exporting I_REC_NO    = ln_RecNo
                  I_S_RECORD  = <ls_data>
                  I_R_MSG     = I_R_MSG
        importing E_ERRONEOUS = lb_erroneous.

*   Record is erroneous
    if lb_erroneous = rs_c_true.

      E_NRECERR = E_NRECERR + 1.
      assign component 'ZXF_FERR'   of structure <ls_data> to <lf_field>. <lf_field> = 'X'. "Mark record as erroneous
      assign component '0TCTRECERR' of structure <ls_data> to <lf_field>. <lf_field> =  1.  "Count erroneous records

    endif.
    if <lf_field> is assigned. unassign <lf_field>. endif.

    clear: lb_erroneous.

    if MN_TOT > CN_MAX_TOT.
      EXIT.   "exit loop !
    endif.

  endloop. "<LT_SOURCE>
  if  <ls_data> is assigned. unassign  <ls_data>.  endif.

  C_T_REC_MSG[] = MT_REC_MSG[].    "The soubroutines used ADD_REC_MSG which uses the MT_REC_MSG.


ENDMETHOD.  "VALIDATION_STEP3_CONTENT


method validation_step4_check_rules.

  field-symbols:
    <lf_field>          type any,
    <ls_source>         type any,             "the source record as a pointer into a table, not a work area (generich upload cube)
    <ls_cdm_chas>       type any,             "the source record as a pointer into a table, not a work area (cdm cube, chars only)
    <lt_cdm_chas>       type standard table,  "The Records with chars moved to CDM characteristics

    <ls_msg>            type rsplf_s_msg.

  data:
    l_subrc             type sysubrc,
    lb_success          type rs_bool,
    ln_recno            type i,
    lr_msg              type ref to cl_rsplfu_msg,
    lt_msg              type rsplf_t_msg.


* ----------------------------------------------------------------------------
* - Create instance of the validation object and message object
* ----------------------------------------------------------------------------
  if moref_vld_rules is initial.

    moref_vld_rules = y0bw_cl_xf_vld_generic=>get_instance( ).

  endif.

  create object lr_msg.

* ----------------------------------------------------------------------------
* - Validate data according to validation rules
* ----------------------------------------------------------------------------


* Process each characteristic combination check the validation rules
  loop at c_t_cdm_chas assigning <ls_cdm_chas>.

    clear: ln_recno,
           lb_success.

    call method lr_msg->clear.

*   Get the record numer
    assign component 'ZXF_RECNO' of structure <ls_cdm_chas> to <lf_field>.
    if sy-subrc = 0.
      ln_recno = <lf_field>.
      unassign <lf_field>.
    endif.

*   Validate the record according to the validation rules
    call method moref_vld_rules->validate_record
      exporting
        rbmodule    = 'UP'
        i_r_message = lr_msg
        recno       = ln_recno
      importing
        success     = lb_success
      changing
        record      = <ls_cdm_chas>.

*   The record violates at least one validation rule
*   if lb_success <> rs_c_true.
    if lr_msg->contains_error( ) = rs_c_true.

*     look up erroneous record by record number in the generic uplaod cube structure
      loop at c_t_data assigning <ls_source>.

        assign component 'ZXF_RECNO' of structure <ls_source> to <lf_field>.
        if sy-subrc = 0.

          if <lf_field> = ln_recno.

            unassign <lf_field>.

            assign component 'ZXF_FERR'   of structure <ls_cdm_chas> to <lf_field>.
            if sy-subrc = 0. <lf_field> = 'X'. unassign <lf_field>. endif. "Mark record as erroneous
            assign component '0TCTRECERR' of structure <ls_cdm_chas> to <lf_field>.
            if sy-subrc = 0. <lf_field> =  1.  unassign <lf_field>. endif. "Count erroneous records

            exit.
          endif.
        endif.

      endloop. "C_T_DATA

*     create / copy messages
      lt_msg = lr_msg->get_t_msg( ).

      loop at lt_msg assigning <ls_msg>.

*       xxx: Record '&' Measure ID '&' Type '&' is not input enabled.
        add_rec_msg_id <ls_msg>-msgid
                                'W'          "<ls_msg>-MSGTY
                       <ls_msg>-msgno
                       <ls_msg>-msgv1
                       <ls_msg>-msgv2
                       <ls_msg>-msgv3
                       <ls_msg>-msgv4.

      endloop.

    endif. "lb_success <> rs_c_true

  endloop. "C_T_CDM_CHAS

  call method validation_step5_conv_cmd
    exporting
      i_r_msg               = i_r_msg
    importing
      e_nrecerr             = e_nrecerr
    changing
      c_s_status            = c_s_status
      i_th_head_to_dim_chas = i_th_head_to_dim_chas
      c_t_cdm_chas          = c_t_cdm_chas
      c_t_data              = c_t_data
      c_t_rec_msg           = c_t_rec_msg.


endmethod.  "VALIDATE_MASTER_DATA


method validation_step5_conv_cmd.

  field-symbols:
    <l_field>            type any,
    <l_field_int>        type any,
    <ls_meas_id>         type y0bw_xf_meas_id,
    <ls_head_to_dim>     type t_s_head_to_dim,
    <ls_data>            type any,
    <fs_dim>             like line of mth_meid_dim,
    <ls_meid_dim>        type t_s_meid_dim.

  data:
    l_tabix           type sy-tabix,
    l_subrc           type sysubrc,
    lf_value          type f,
    l_zxf_meas        type /bic/oizxf_meas, " 'Measure ID' for validation of breakdown characteristics
    lstr_zxf_meas     type string.          " for Meassages
  data: lth_head_to_dim type hashed table of t_s_head_to_dim with unique key fieldnm_dst.
  data: ls_head_to_dim like line of i_th_head_to_dim_chas.
  data: lt_cdm_rec type y0bw_cl_xf_vld_generic=>tt_record_table.
  field-symbols: <ls_trg> type any.
  field-symbols: <fs_cdm_rec> like line of lt_cdm_rec.
  data: lth_head type hashed table of t_s_head with unique key dimnm.
  field-symbols: <fs_head> like line of lth_head.
  field-symbols: <fs_recno> type /bic/oizxf_recno.
  data: ls_tabix like sy-tabix.

  loop at sth_head assigning <fs_head> where header_type = c_y0xf_header_type-chas.
    insert <fs_head> into table lth_head.
  endloop.

  lth_head_to_dim[] = i_th_head_to_dim_chas[].

* Transform each record of CDM table into Record Table
  loop at c_t_cdm_chas assigning <ls_data>.
    assign component 'ZXF_RECNO' of structure <ls_data> to <fs_recno>.
    clear ls_tabix.
    if sy-subrc = 0. ls_tabix = <fs_recno>. endif.
    read table c_t_data assigning <ls_trg> index ls_tabix.
    y0bw_cl_xf_vld_generic=>record2table(
    exporting
      record = <ls_data>
      importing
        record_table = lt_cdm_rec ).
* Delete all entries with initial values
    delete lt_cdm_rec where value is initial.
* Search for each dimension in the transformation table
    loop at lt_cdm_rec assigning <fs_cdm_rec>.
      read table lth_head_to_dim transporting no fields with key fieldnm_dst = <fs_cdm_rec>-infoobject.
* If not available, check if the field is available in cha60 structure
      if sy-subrc <> 0.
        assign component <fs_cdm_rec>-infoobject of structure <ls_trg> to <l_field>.
* If not, add a new entry
        if sy-subrc <> 0.
          assign component <fs_cdm_rec>-infoobject of structure <ls_data> to <l_field>.
          if sy-subrc = 0 and <l_field> is not initial.
            sort i_th_head_to_dim_chas by fieldnm_src descending.
            l_tabix = 1.
            loop at i_th_head_to_dim_chas into ls_head_to_dim.
              if l_tabix = 1 and ls_head_to_dim-fieldnm_src(7) = 'ZXF_CHA'.
                l_tabix = 0.
                if ls_head_to_dim-fieldnm_src+7(2) < 10.
                  ls_head_to_dim-fieldnm_src+7(1) = '0'.
                  ls_head_to_dim-fieldnm_src+8(1) = ls_head_to_dim-fieldnm_src+7(2) + 1.
                else.
                  ls_head_to_dim-fieldnm_src+7(2) = ls_head_to_dim-fieldnm_src+7(2) + 1.
                endif.
                ls_head_to_dim-fieldnm_dst = <fs_cdm_rec>-infoobject.
                ls_head_to_dim-dimnm = <fs_cdm_rec>-infoobject.
                ls_head_to_dim-header_type = 'CHA'.
                clear: ls_head_to_dim-col_header, ls_head_to_dim-header_subtype, ls_head_to_dim-kfy_month, ls_head_to_dim-col_head_low, ls_head_to_dim-ls_treatment_chas, ls_head_to_dim-b_treatment.

* Add new dimension into the status Record (not the dimension, but corresponding Upload Header Title)
                assign component ls_head_to_dim-fieldnm_src of structure c_s_status to <l_field>.
                if sy-subrc = 0.
                  read table lth_head with table key dimnm = <fs_cdm_rec>-infoobject assigning <fs_head>.
                  if sy-subrc = 0.
                    <l_field> = <fs_head>-col_header.
                    insert ls_head_to_dim into table i_th_head_to_dim_chas.
                    insert ls_head_to_dim into table lth_head_to_dim.
                  endif.
                endif.
              endif.
            endloop.
          endif.
        endif.
      endif.
    endloop.

* Copy CDM table into Char60 Table
    field-symbols: <fs_trg> type any.
    field-symbols: <fs_src> type any.
    loop at i_th_head_to_dim_chas into ls_head_to_dim.
      assign component ls_head_to_dim-fieldnm_src of structure <ls_trg> to <fs_trg>.
      assign component ls_head_to_dim-fieldnm_dst of structure <ls_data> to <fs_src>.
      if sy-subrc = 0.
        <fs_trg> = <fs_src>.
      endif.
    endloop.


  endloop.

endmethod.  "VALIDATE_MASTER_DATA


method ZIF_EX_RSPLF_FILE_UPLOAD~TRANSFORM_DATA.
* ----------------------------------------------------------------------------
* - ( A ) Create the status record with chars and keyfigure-descriptions
* -
* - ( B ) Build the translation tables of type "Column header to Dimensions"
* -       for  CHARACTERISTICS and KEYFIGURES.
* -
* - ( C ) Build tables for column treatment and apply conversions.
* -       CHARACTERISTICS:     CHAVL, TOUPPER, CONVERSION EXIT, TYP CONVERSION
* -       PHYSICAL KEYFIGURES: CONVAMOUNT as defined in TCURX
* -
* - ( D ) Check for duplicates AFTER the conversions have been applied
* -
* - ( E ) Perform validations and update status record
* -       Validate File: Structural validation (header)
* -       Validate File: Master Data Validation
* -       Validate File: Content Validation (Breakdown chars and Filter)
* -
* - ( F ) Save filter values on authorization relevant characteristics
* -       for subsequent process steps.
* -
* - ( - ) Move from "Generic Upload Cube" to "CDM Upload Cube(s)"
*         HAS BEEN REPLACED BY SECOND STEP IN THE PLANNING SEQUENCE DUE TO
*         OBLIGATORY RESTRICTIONS ON AUTHORIZATION RELEVANT CHARACTERISTICS.
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <lf_field>       type ANY,

    <LT_DATA>        type STANDARD TABLE,    "Upload data
    <LT_TARGET>      type STANDARD TABLE,    "CDM Upload Cube
    <LT_RECMSG>      type STANDARD TABLE,    "Record related messages

    <lwa_status>     type ANY.               "WORK AREA, not a pointer
                                             "pointer into C_TH_DATA !!

  DATA:
    ln_RecErr        type I,                 "Number of erroneous records detected   by the validation routine
    lt_rec_msg       type T_T_REC_MSG,       "Record related errors       generated  by the validation routine
    l_xf_status      type /BIC/OIZXF_STAT,   "Status                      calculated by the validation routine

    lr_data          type REF TO DATA,       "dynamic data creation
    l_subrc          type SYSUBRC.


* ----------------------------------------------------------------------------
* - Create a work area for the status record
* ----------------------------------------------------------------------------
  create data lr_data like line of C_TH_DATA. assign lr_data->* to <lwa_status>. clear lr_data.

* ----------------------------------------------------------------------------
* - Create table for the local copy of C_TH_DATA and the record messages
* ----------------------------------------------------------------------------
  create data lr_data like standard table of <lwa_status>.  assign lr_data->* to <LT_DATA>.   clear lr_data.
  create data lr_data like standard table of <lwa_status>.  assign lr_data->* to <LT_TARGET>. clear lr_data.
  create data lr_data like standard table of <lwa_status>.  assign lr_data->* to <LT_RECMSG>. clear lr_data.

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* create a local copy of C_TH_DATA
  <lt_data>[] = C_TH_DATA[].
  free: C_TH_DATA[].


* ============================================================================
* = ( A ) Create the status record with chars and keyfigure-descriptions
* ============================================================================
  ln_RecErr   = MS_FILEID-0TCTRECERR. "read nr of err. rec from TRANSFORM_FILE
  l_xf_status = MS_FILEID-ZXF_STAT.   "read current status from TRANSFORM_FILE
  clear MS_FILEID-0TCTRECERR.
  clear MS_FILEID-ZXF_STAT.
  clear l_subrc.
  call method CREATE_STATUS_RECORD    "with current status from TRANSFORM_FILE

    exporting I_R_UPLOAD = I_R_UPLOAD
              I_R_MSG    = I_R_MSG
              I_ZXF_STAT = l_xf_status
    importing E_SUBRC    = l_subrc
    changing  C_S_STATUS = <lwa_status>.                        " <<<

  if l_subrc <> 0.
  endif.

  call method ADD_RECORD_MESSAGES
    exporting  I_S_FILEID  = MS_FILEID
               I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
    changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
  free: MT_REC_MSG[].

* ============================================================================
* = ( B ) Build the translation tables
* ============================================================================
  if l_xf_status = C_ZXF_STAT-VALID_FILE.

*   --------------------------------------------------------------------------
*   - Build the translation tables of type "Column header to Dimensions" for
*   - C H A R A C T E R I S T I C S  and  K E Y F I G U R E S, based on the
*   - status record.
*   --------------------------------------------------------------------------
    clear l_subrc.
    free: MTH_HEAD_TO_DIM_CHAS,
          MTH_HEAD_TO_DIM_KYFS.

    call method BUILD_TRANSLATION_HEAD_TO_DIM

      exporting I_S_STATUS           = <lwa_status>               " <<<
                I_R_MSG              = I_R_MSG
      importing E_TH_HEAD_TO_DIM_CHAS = MTH_HEAD_TO_DIM_CHAS
                E_TH_HEAD_TO_DIM_KYFS = MTH_HEAD_TO_DIM_KYFS
                E_SUBRC              = l_subrc.

    if l_subrc <> 0.
    endif.

    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: MT_REC_MSG[].

  endif.

* ============================================================================
* = ( C ) Build tables for column treatment and apply conversions.
* =       CHARACTERISTICS:     CHAVL, TOUPPER, CONVERSION EXIT, TYP CONVERSION
* =       PHYSICAL KEYFIGURES: CONVAMOUNT as defined in TCURX
* ============================================================================
  if l_xf_status = C_ZXF_STAT-VALID_FILE.

    if I_R_UPLOAD->N_CONV_FIELDS  = rs_c_true or
       I_R_UPLOAD->N_CONV_AMOUNTS = rs_c_true.

*       477: Apply conversions
        ADD_MSG 'I' '477' '' '' '' ''.

*     Schedule characteristics and amounts for conversions
      clear l_subrc.
      call method BUILD_COLUMN_TREATMENT

        exporting I_CONV_FIELDS         = I_R_UPLOAD->N_CONV_FIELDS
                  I_CONV_AMOUNTS        = I_R_UPLOAD->N_CONV_AMOUNTS
                  I_R_MSG               = I_R_MSG
                  I_T_CDM_UPLOAD_CUBES  = ST_CDM_UPLOAD_CUBES   "List of CDM Upload Cubes
                                                                "   -> List of PHYSICAL KEYFIGURES
        importing E_T_TREATMENT_CHAS    = MT_TREATMENT_CHAS
                  E_T_TREATMENT_KYFS    = MT_TREATMENT_KYFS     " List of possible physical keyfigures
                                                                " derived from ST_CDM_UPLOAD_CUBES
                                                                " with cobj_pro info object attributes
                  E_SUBRC               = l_subrc

        changing  C_TH_HEAD_TO_DIM_CHAS = MTH_HEAD_TO_DIM_CHAS. "enhance every char by treatment-info
                                                                "and set relevance indicator
      if l_subrc = 0.

*       Apply conversions to characteristics and amounts as scheduled
        clear l_subrc.
        call method APPLY_CONVERSIONS_CHAS_KYFS

          exporting I_R_MSG               = I_R_MSG
                    I_T_TREATMENT_CHAS    = MT_TREATMENT_CHAS
                    I_T_TREATMENT_KYFS    = MT_TREATMENT_KYFS

          importing E_SUBRC               = l_subrc
          changing  C_T_DATA              =  <LT_DATA>.  " File w/o header line
                                                         " no status record yet
        if l_subrc <> 0.
        endif.

      endif. "l-subrc = 0.
    endif. "I_R_UPLOAD->N_CONV_FIELDS  = rs_c_true

    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: MT_REC_MSG[].

  endif.

* ============================================================================
* - ( D ) Check for duplicates AFTER the conversions have been applied
* ============================================================================
* Perform further validations, in case
* TRANSFORM_FILE has not detected any errors
* in the columns headers or duplicate records !
  if l_xf_status = C_ZXF_STAT-VALID_FILE.

    if M_N_CHECK_DUPLICATES <> SPACE.

*     478: Check file for duplicate records
      ADD_MSG 'I' '478' '' '' '' ''.

      clear: ln_RecErr.
      free:  lt_rec_msg.
      call method CHECK_DUPLICATES_HASH

          exporting I_R_MSG     = I_R_MSG
                    I_R_UPLOAD  = I_R_UPLOAD
                    I_S_STATUS  = <lwa_status>
          importing E_NRECERR   = ln_RecErr
                    E_ZXF_STAT  = l_xf_status
          changing  C_T_REC_MSG = lt_rec_msg
                    C_T_DATA    = <lt_data>.

      call method ADD_RECORD_MESSAGES
        exporting  I_S_FILEID  = MS_FILEID
                   I_T_REC_MSG = lt_rec_msg    "Messages from Validation
        changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
      free: lt_rec_msg[], MT_REC_MSG[].

    endif.
  endif. "l_xf_status = C_ZXF_STAT-VALID_FILE.


* ----------------------------------------------------------------------------
* - Update Status Record
* ----------------------------------------------------------------------------
  MS_FILEID-ZXF_STAT    = l_xf_status.              "Generic File Upload Status

  if ln_RecErr is initial.
  MS_FILEID-ZXF_FERR    = rs_c_false.  else.        "Flag: Record erroneous
  MS_FILEID-ZXF_FERR    = rs_c_true.   endif.

  MS_FILEID-0TCTRECERR  = ln_RecErr.                "Keyfigure: Number of Erroneous
                                                    "    Records in the file
  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_status>
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''.
    RETURN.
  endif.


* ============================================================================
* = ( E ) Perform validations and update status record
* ============================================================================

* ----------------------------------------------------------------------------
* - Validate data
* -   Validate File: Structural validation (header)
* -   Validate File: Master Data Validation
* -   Validate File: Content Validation (Breakdown chars and Filter)
* ----------------------------------------------------------------------------

* Perform further validations, in case
* TRANSFORM_FILE has not detected any errors
* in the columns headers or duplicate records !
  if l_xf_status = C_ZXF_STAT-VALID_FILE.

    clear: l_xf_status.
    clear: ln_RecErr.
    free:  lt_rec_msg.

    call method VALIDATE_UPLOAD_DATA

      exporting  I_R_MSG        = I_R_MSG

      importing  E_NRECERR      = ln_RecErr
                 E_ZXF_STAT     = l_xf_status
      changing   C_T_DATA       = <lt_data>
                 I_S_STATUS     = <lwa_status>
                 C_T_REC_MSG    = lt_rec_msg.

    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = lt_rec_msg    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: lt_rec_msg[], MT_REC_MSG[].

  endif.


* ----------------------------------------------------------------------------
* - Update Status Record
* ----------------------------------------------------------------------------
  MS_FILEID-ZXF_STAT    = l_xf_status.              "Generic File Upload Status

  if ln_RecErr is initial.
  MS_FILEID-ZXF_FERR    = rs_c_false.  else.        "Flag: Record erroneous
  MS_FILEID-ZXF_FERR    = rs_c_true.   endif.

  MS_FILEID-0TCTRECERR  = ln_RecErr.                "Keyfigure: Number of Erroneous
                                                    "    Records in the file
  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_status>
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''.
    RETURN.
  endif.

* ============================================================================
* = ( F ) Save filter values on authorization relevant characteristics
* =       for subsequent process steps.
* ============================================================================
  if MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.

    free: lt_rec_msg.

*   479: Save Filter Values for File Id '&'.
    ADD_MSG 'I' '479' MS_FILEID-ZXF_UFID '' '' ''.

    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: MT_REC_MSG[].

    free: lt_rec_msg, MT_REC_MSG.
    call method SAVE_AUTH_REL_FILTERS exporting   I_R_MSG               = I_R_MSG
                                                  I_S_FILEID            = MS_FILEID
                                                  I_TH_HEAD_TO_DIM_CHAS = MTH_HEAD_TO_DIM_CHAS
                                                  I_TH_AUTH_REL_CHAS    = STH_AUTH_REL_CHAS
                                                  I_T_DATA              = <lt_data>
                                      changing    C_T_REC_MSG           = lt_rec_msg.

    call method ADD_RECORD_MESSAGES
      exporting  I_S_FILEID  = MS_FILEID
                 I_T_REC_MSG = lt_rec_msg    "Messages from Validation
      changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
    free: lt_rec_msg[], MT_REC_MSG[].

  endif.

****** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
****** + HAS BEEN REPLACED BY SECOND STEP IN THE PLANNING SEQUENCE DUE TO
****** + OBLIGATORY RESTRICTIONS ON AUTHORIZATION RELEVANT CHARACTERISTICS.
****** ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

****** ============================================================================
****** = ( F ) Move from Generic Upload Cube into CDM Upload Cube
****** ============================================================================
*****  if l_xf_status = C_ZXF_STAT-VALID_FILE.
*****
******   Copy from Upload Cube to CDM Upload Cube(s)
*****    call method MOVE_TO_CDM_UPLOAD
*****
*****      exporting  I_R_MSG        = I_R_MSG
*****                 I_T_SOURCE     = <LT_DATA>
*****      importing  E_T_TARGET     = <LT_TARGET>.
*****
******   Delete File from Upload Cube
*****    free: <LT_DATA>.
*****  endif.
*****
*****
****** ----------------------------------------------------------------------------
****** - Copy Record related messages from validation
****** - into transaction data format with infoprovider information
****** - for update into the messages cube.
****** ----------------------------------------------------------------------------
*****  call method ADD_RECORD_MESSAGES
*****    exporting  I_S_FILEID  = MS_FILEID
*****               I_T_REC_MSG = MT_REC_MSG    "Messages from Validation
*****    changing   C_T_RECMSG  = <LT_RECMSG>.  "Transaction data
*****  free: MT_REC_MSG[].


* ----------------------------------------------------------------------------
* - Return records (C_TH_DATA)
* ----------------------------------------------------------------------------
  FIELD-SYMBOLS: <ls_data> type ANY.
  free: C_TH_DATA[].

  insert          <lwa_status> into table C_TH_DATA.       "Status record
  insert lines of <LT_DATA>    into table C_TH_DATA.       "Upload Cube
                                                           "Each record has a unique record number !
  insert lines of <LT_RECMSG>  into table C_TH_DATA.       "Messages

*****  case M_N_CHECK_DUPLICATES.
*****
*****    when I_R_UPLOAD->n_c_duplicates_error.
*****
*****      insert lines of <LT_TARGET>  into table C_TH_DATA.   "CDM Upload Cube, empty in case of        INVALID_FILE
*****
*****    when SPACE
*****      or I_R_UPLOAD->n_c_duplicates_add                    "aggregate and remain silent ...           VALID_FILE
*****      or I_R_UPLOAD->n_c_duplicates_warn.                  "aggregate and issue an information only   VALID_FILE
*****
*****      loop at <LT_TARGET> assigning <ls_data>.
*****
*****        collect <ls_data> into C_TH_DATA.                  "counter Number records may show a value > 1 !
*****                                                           "aggregate, if duplicate records are allowed
*****                                                           "since the record number is no longer part of the model.
*****      endloop.
*****  endcase.



* Provide current message context for subsequent process steps
  EXPORT MN_RECNO                = MN_RECNO                 "Current record number
         MN_TOT                  = MN_TOT                   "Total Number of Messages E / W / I
         MN_MSG                  = MN_MSG                   "Number of Errors/Warnings -> FlowControl !
         MN_ERR                  = MN_ERR                   "Number of Errors
         MN_WAR                  = MN_WAR                   "Number of Warnings
         MN_INF                  = MN_INF                   "Number of Informations
         MN_MSG_RECNO            = MN_MSG_RECNO             "Messages: Current Record Number
         MN_MSG_LINNO            = MN_MSG_LINNO             "Messages: Line Number for current record
         MN_MSG_LINNO_LAST_REC_0 = MN_MSG_LINNO_LAST_REC_0  "Messages: Last Line Number for record number "0" !

      TO MEMORY "see below for import
      ID 'Y0BW_CL_XF_UP_GEN_FILE_UPLOAD'.


  free:
    <LT_DATA>, <LT_TARGET>, <LT_RECMSG>,
    <lwa_status>.                            "must not forget !

endmethod. "ZIF_EX_RSPLF_FILE_UPLOAD~TRANSFORM_DATA.


method ZIF_EX_RSPLF_FILE_UPLOAD~TRANSFORM_FILE.
* ----------------------------------------------------------------------------
* - ( A) Create index-based mapping table MT_MAP_TO_CUBESTRUCT
* ----------------------------------------------------------------------------
* - ( B ) Separate characteristics from keyfigures
* -       and apply "DeCimal Point and ForMat" from user settings.
* -          Characteristics: [ZXF_CHAS01 .. ZXF_CHAS40]
* -          Keyfigures:      [ZXF_KYFS01 .. ZXF_KYFS12]
* ----------------------------------------------------------------------------
*   ( C ) Skip empty records
* ----------------------------------------------------------------------------
* - ( D ) Check for duplicate rows (with identical characteristic combination)
* ----------------------------------------------------------------------------

* ----------------------------------------------------------------------------
* - ( A & B)
* - Reads the file's first line, which is supposed to hold the column headers.
* - The names of the header columns are stored in a table (index = order) and
* - the header line is deleted from the file.
* - The file's records are restructured according to the mapping table, such
* - that characteristics are placed first and the keyfigures start at
* - CC_MAX_CHAR + 1.
* ----------------------------------------------------------------------------
* - ( C )
* - Check for duplicate records. Must be carried out in BADI "TRANSFORM_RECORD"
* - because, otherwise, the standard implementation performs the aggragation
* - and issues warnings and error messages (File Status/store messages?)
* - or generates a dump, if switched off !
* - After the check was performed, the memeber attribute
* - I_R_UPLOAD->n_check_duplicates is cleared to save peroformance.
* - The attribute has been changed from "READ ONLY" therefore !
* ----------------------------------------------------------------------------
* - Status
* -   FILE_NOT_READABLE  The header line contains invalid InfoObject(s).
* -   INVALID_FILE       The file is empty or contains duplicate records.
* -   VALID_FILE         Column header OK (so far), no duplicates in the file.
* ----------------------------------------------------------------------------
* - ( D )
* - The detection of duplicate records in BADI TRANSFORM_FILE allows to use
* - the original switch I_R_UPLOAD->n_check_duplicates and detect duplicate
* - records BEFORE the standard implementation detects them.
* - Duplicate records in the loadfile are detected and treated according
* - to the setting.
* - Nevertheless: Due to subsequent treatment of conversions as
* -   * deletion of leading blanks
* -   * TO UPPER conversion
* -   * conversion exits
* - duplicate records might be created after the treatment has been applied!
* - Must be re-tested after the treatment has been applied !
* ----------------------------------------------------------------------------
* - 2012-10-04 (mh)
* -
* - I_R_UPLOAD->n_check_duplicates set to '#' in Planning function
* -
* - ZUP_A302_PFU_010	UP  Upload To Generic Upload Cube TXT/CSV
* -
* - Check duplicates has been disabled in TRANSFORM_FILE, because the main
* - program in ZRSPLF does no longer check and identify duplicates due to
* - the current setting of member variable n_check_duplicates.
* ----------------------------------------------------------------------------


  FIELD-SYMBOLS:
    <ls_file>         type ANY,                   "Pointer into the file as it is provided

*   >>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
*   <ls_dupl_chas>    type ANY,                   "Pointer into table ..
*   <lt_dupl_chas>    type STANDARD TABLE,        "  .. with only characteristics (duplicate rows)
*   <lwa_dupl_chas>   type ANY,                   "corresponding WORK AREA, dynamically created !!!

*   <ls_aggr>         type ANY,                   "pointer into table ..
*   <lt_aggr>         type STANDARD TABLE,        "  .. with numeric data types for keyfigures P/IF/ instead of CHAR 30
*   <lwa_aggr>        type ANY,                   "corresponding WORK AREA, dynamically created !!!
*   >>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

    <ls_resultfile>   type ANY,                   "pointer into table ..
    <lt_resultfile>   type STANDARD TABLE,        "  .. file keyfigures of type char30
    <lwa_resultfile>  type ANY,                   "WORK AREA for target record, dynamically created !!!

    <ls_charsel>      type RSPLF_S_CHARSEL.

  DATA:

*   >>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
*   lref_wa_dupl_chas type REF TO DATA,           "dynamic data creation
*   lref_t_dupl_chas  type REF TO DATA,           "dynamic data creation
*   lref_wa_aggr      type REF TO DATA,           "dynamic data creation
*   lref_t_aggr       type REF TO DATA.           "dynamic data creation
*   >>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

    ln_RecNo          type i,                     "Record number
    lb_firstrow       type RSBOOL,                "rs_c_true: skip record and create mapping table
    lb_duplicates     type RSBOOL,                "rs_c_true: duplicate record found
    lr_data           type REF TO DATA.           "dynamic data creation

* ============================================================================
* = FOR DEBUGGNIG PURPOSES ONLY
* ============================================================================
*  if sy-uname = 'ATX-MHAHN'.
*    DATA: stopit type c value '#'.
*    while stopit = '#'. endwhile.
*  endif.
* ============================================================================

* --------------------------------------------------------------------------
* - Initialize Member Variables
* --------------------------------------------------------------------------
  INIT_MEMBER_VARIABLES.
  INIT_MESSAGE_VARIABLES.    "used by ADD_MSG and ADD_REC_MSG
  MN_TRANS_FILE_REC_ERR = 0. "Anzahl fehlerhafter Saetze in TRANSFORM_FILE

* Initialize status
  MS_FILEID-ZXF_STAT = C_ZXF_STAT-FILE_NOT_READABLE.


  M_R_UPLOAD = I_R_UPLOAD.  "Provide Access to the attributes of ZCL_RSPLF_FILE_UPLOAD

* ----------------------------------------------------------------------------
* - Create a work area and table for the resulting file w/o the header line
* ----------------------------------------------------------------------------
  create data lr_data like line of C_T_FILE.                   assign lr_data->* to <lwa_resultfile>.
  create data lr_data like standard table of <lwa_resultfile>. assign lr_data->* to <lt_resultfile>.


* ----------------------------------------------------------------------------
* - Read the File Id and create a message
* ----------------------------------------------------------------------------
  read table M_R_UPLOAD->N_T_CHARSEL
    assigning <ls_charsel>
    with key IOBJNM = 'ZXF_UFID'.
  if sy-subrc = 0.
    if <ls_charsel> is assigned.
      if not <ls_charsel>-LOW is initial.
        DATA: lstr_FileId type string.
        lstr_FileId = <ls_charsel>-LOW.
        shift lstr_FileId left deleting leading '0'.

*       461: File Id '&' generated for current file upload.
        ADD_MSG 'I' '461' lstr_FileId '' '' ''.

      endif.
    endif.
  endif.

* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
* ----------------------------------------------------------------------------
* - Create structure(s) and table(s) for identifying duplicates and agregation
* ----------------------------------------------------------------------------
*  clear: lref_wa_aggr, lref_wa_dupl_chas,
*         lref_t_aggr,  lref_t_dupl_chas.
*
*  call method _CHECK_DUPLICATES_CREATE_DATA
*
*      exporting  I_T_IOBJNM   = I_R_UPLOAD->N_T_IOBJNM
*      importing  E_REF_WA_AGGR      = lref_wa_aggr         "work area for record with numeric keyfigures for aggregation
*                 E_REF_T_AGGR       = lref_t_aggr          "Table for aggregation
*                 E_REF_WA_DUPL_CHAS = lref_wa_dupl_chas    "work area for record with only characteristics
*                 E_REF_T_DUPL_CHAS  = lref_t_dupl_chas     "Table for checking duplicates (only characteristics)
*      exceptions INVALID_FIELD      = 1
*                 NO_FIELDS          = 2
*                 others             = 3.
*
*  if sy-subrc <> 0.
*    RETURN.
*  endif.
*
*  if not lref_wa_aggr      is initial. assign lref_wa_aggr->*      to <lwa_aggr>.      endif. clear lref_wa_aggr.
*  if not lref_t_aggr       is initial. assign lref_t_aggr->*       to  <lt_aggr>.      endif. clear lref_t_aggr.
*
*  if not lref_wa_dupl_chas is initial. assign lref_wa_dupl_chas->* to <lwa_dupl_chas>. endif. clear lref_wa_dupl_chas.
*  if not lref_t_dupl_chas  is initial. assign lref_t_dupl_chas->*  to <lt_dupl_chas>.  endif. clear lref_t_dupl_chas.
* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>


* ----------------------------------------------------------------------------
* - Iterate the file's records, store the fieldnames of the header line
* - and create a copy of the file without the header line.
* ----------------------------------------------------------------------------
  free: <lt_resultfile>[].
  clear ln_RecNo.
  lb_firstrow   = rs_c_true.
  lb_duplicates = rs_c_false.
  loop at C_T_FILE assigning <ls_file>.

*   --------------------------------------------------------------------------
*   - First Row / Header Line:
*   - Build index based mapping table MT_MAP_TO_CUBESTRUCT
*   --------------------------------------------------------------------------
    if lb_firstrow = rs_c_true.

*     ----------------------------------------------------------------------------
*     451:Validate Header ..                "folowing two errors are detected
      ADD_MSG 'I' '451' '' '' '' ''.        " ( A ) Column header name must be valid
                                            " ( B ) Each column name must be provided only once
                                            " ( C ) Column header has unnown dimension type
*     ----------------------------------------------------------------------------
      call method build_map_to_cubestruct

                exporting  I_R_MSG = I_R_MSG
                changing   ls_file = <ls_file>.  "upper case conversion

      if MN_MSG > 0.
*       307: ERRORS OCCURRED. PROCESSING TERMINATED.
        ADD_MSG 'W' '307' '' '' '' ''.
        RETURN.
      endif.

      lb_firstrow = rs_c_false.

*   --------------------------------------------------------------------------
*   - Data row: Copy data records into the resulting file
*   - thereby restructure the record: move CHAS to CHAS, KYFS to KYFS !
*   - Convert keyfigures by decimal notation "DeCimal Point and ForMat"
*   - as defined in the user's defaults. Check for duplicates, if required.
*   --------------------------------------------------------------------------
    else.

*     Skip empty records
      if <ls_file> is initial.
        CONTINUE.
      endif.

      ln_RecNo = ln_RecNo + 1.

*     ----------------------------------------------------------------------------
      if ln_RecNo = 1.
*       if not I_R_UPLOAD->n_check_duplicates is initial.    "Parameter set to "#"
*         454: Check file for duplicate records ..
*         ADD_MSG 'I' '454' '' '' '' ''.
*       endif.
      endif.
*     ----------------------------------------------------------------------------
*     Restructure record (CHAS <-|-> KYFS),
*     and apply "DeCimal Point and ForMat" from user settings
      clear <lwa_resultfile>.
      call method restructre_record                                  "chas to chas and kyfs to kyfs and apply decimal notation

               exporting ls_data_src  = <ls_file>
                         I_R_MSG     = I_R_MSG
               importing ls_data_dst = <lwa_resultfile>.

*     >>> INSERTED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
      append <lwa_resultfile> to <lt_resultfile>.        "<<<<<
*     >>> INSERTED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
*     Don't check for duplicate records
*     if I_R_UPLOAD->n_check_duplicates is initial.
*     if rs_c_true = rs_c_true.
*
*       append <lwa_resultfile> to <lt_resultfile>.        "<<<<<
*
*     Check for duplicate records
*      else.
*
*        clear <lwa_dupl_chas>.
*        move-corresponding <lwa_resultfile> to <lwa_dupl_chas>.      "move CHARACTERISTICS
*
*        clear <lwa_aggr>.
*        move-corresponding <lwa_resultfile> to <lwa_aggr>.           "move CHARACTERISTICS and
*                                                                     "     KEYFIGURES into structure
*                                                                     "with keyfigures I/P/F instead of CHAR30 !
**       look up characteristic combination
*        read table <lt_dupl_chas> from <lwa_dupl_chas>
*          transporting no fields.
*
**       Not a duplicate record
*        if sy-subrc <> 0.
*
*          insert <lwa_dupl_chas> into table <lt_dupl_chas>.          "Store the characteristic combination
*                                                                     "for later look up
*          insert <lwa_aggr>      into table <lt_aggr>.     "<<<<<    "Add the current record with it's keyfigures
*                                                                     "for aggregation
**       Duplicate record found
*        else.
*
*          lb_duplicates = rs_c_true.
*          MS_FILEID-0TCTRECERR = MS_FILEID-0TCTRECERR + 1.           "Count erroneous records
**         collect <lwa_dupl_chas> into <lt_dupl_chas>.               "Store the characteristic combination OBSOLET
**                                                                    "for later look up                    OBSOLET
*          collect <lwa_aggr>      into <lt_aggr>.          "<<<<<    "Aggregate keyfigures for identical characteristics
*
**          362: Record '&' Duplicate Record.
**          case I_R_UPLOAD->n_check_duplicates.
**            when I_R_UPLOAD->n_c_duplicates_add.    "aggregate and remain silent ...
**            when I_R_UPLOAD->n_c_duplicates_warn.   ADD_REC_MSG 'I' '362' ln_RecNo '' '' ''.
**            when I_R_UPLOAD->n_c_duplicates_error.  ADD_REC_MSG 'W' '362' ln_RecNo '' '' ''.   "E/W -> "MSG"
**          endcase.
*
*        endif. "Duplicate record found
*      endif. "not I_R_UPLOAD->n_check_duplicates is initial
*     clear: <lwa_resultfile>, <lwa_dupl_chas>, <lwa_aggr>.
* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

    endif. "lb_firstrow = rs_c_true.
  endloop. "at C_T_FILE assigning <ls_file>.
  lb_firstrow = abap_undefined.

* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
* ----------------------------------------------------------------------------
* - If aggregation was performed on the "keyfigure structure,
* - copy back aggregation results into "char30" structure.
* ----------------------------------------------------------------------------
*  if not I_R_UPLOAD->n_check_duplicates is initial.
*  if rs_c_true = rs_c_false.
*
**   <lt_resultfile> = <lt_aggr>.  type mismatch I/P/F -> CHAR 30
*    clear <lwa_resultfile>.
*    free: <lt_resultfile>.
*    loop at <lt_aggr> assigning <ls_aggr>.
*      move-corresponding <ls_aggr> to <lwa_resultfile>.
*      insert <lwa_resultfile> into table <lt_resultfile>.
*    endloop.
*    if <ls_aggr> is assigned. unassign <ls_aggr>. endif.
*
*  endif. "not I_R_UPLOAD->n_check_duplicates is initial.
*
* free: <lwa_aggr>, <lwa_dupl_chas>,
*       <lt_aggr>,  <lt_dupl_chas>.
* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>


* Update status

*  >>>>>> INSERTED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
   MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.
*  >>>>>> INSERTED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
*  if I_R_UPLOAD->n_check_duplicates is initial.
*
*    MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.
*
*  else.
*
*    case I_R_UPLOAD->n_check_duplicates.
*
*      when I_R_UPLOAD->n_c_duplicates_add.    MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.
*      when I_R_UPLOAD->n_c_duplicates_warn.   MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.
*      when I_R_UPLOAD->n_c_duplicates_error.  if lb_duplicates = rs_c_false.
*                                              MS_FILEID-ZXF_STAT = C_ZXF_STAT-VALID_FILE.   else.
*                                              MS_FILEID-ZXF_STAT = C_ZXF_STAT-INVALID_FILE. endif.
*    endcase.
*
*  endif.
* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

*  M_N_CHECK_DUPLICATES = I_R_UPLOAD->n_check_duplicates.
   M_N_CHECK_DUPLICATES = I_R_UPLOAD->n_c_duplicates_error.    "UPLOAD FRAMEWORK LOGIC !!!!

* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>
* Prevent Standard Upload from checking
* again after BADI Call "TRANSFORM_FILE"
*  if not I_R_UPLOAD->n_check_duplicates is initial.
*    clear I_R_UPLOAD->n_check_duplicates.             "changed READ ONLY Member Attribute !
*  endif.
* >>>>>>> DELETED >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 2012-10-04 (mh) >>>

* Check for empty file
  if <lt_resultfile> is initial.

    MS_FILEID-ZXF_STAT = C_ZXF_STAT-INVALID_FILE.

*   311: No source records provided for copy! STOP subsequent steps.
    ADD_MSG 'W' '311' '' '' '' ''.
  endif.

* ----------------------------------------------------------------------------
* - Return the file content without the header line
* ----------------------------------------------------------------------------
  free: C_T_FILE[].
  C_T_FILE[] = <lt_resultfile>[].

  free:
*   <lwa_aggr>, <lwa_dupl_chas>,   "WORK AREA
*    <lt_aggr>,  <lt_dupl_chas>.    "Tables
    <lwa_resultfile>,
     <lt_resultfile>.

endmethod. "ZIF_EX_RSPLF_FILE_UPLOAD~TRANSFORM_FILE


method ZIF_EX_RSPLF_FILE_UPLOAD~TRANSFORM_RECORD.
* ----------------------------------------------------------------------------
* - Add the Target Generic Upload Cube to the record for each line of the file
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <lf_field>        type ANY.

* ----------------------------------------------------------------------------
* - Set the Target Infoprovider (=Generic Upload Cube) into the record
* ----------------------------------------------------------------------------
  assign component '0INFOPROV' of structure C_S_DATA to <lf_field>.
  if sy-subrc = 0.

    <lf_field> = C_CUBE-GENERIC_UPLOAD.    "replaced by source from data cluster
    unassign <lf_field>.
  endif.

* ----------------------------------------------------------------------------
* - Set the record number into the record (-> for the Messages)
* ----------------------------------------------------------------------------
  MN_RECNO = MN_RECNO + 1.
  assign component 'ZXF_RECNO' of structure C_S_DATA to <lf_field>.
  if sy-subrc = 0.

    <lf_field> = MN_RECNO.
    unassign <lf_field>.
  endif.

* ----------------------------------------------------------------------------
* - Keyfigure: Set the record counter to "1"
* ----------------------------------------------------------------------------
  assign component '0TCTNUMREC' of structure C_S_DATA to <lf_field>.
  if sy-subrc = 0.

    <lf_field> = 1.
    unassign <lf_field>.
  endif.

endmethod.  "ZIF_EX_RSPLF_FILE_UPLOAD~TRANSFORM_RECORD


METHOD _CHECK_DUPLICATES_CREATE_DATA.

  FIELD-SYMBOLS:
    <wa>                type ANY.       "Field symbol to dynamically created work area

  DATA:
    l_iobjnm            TYPE rsiobjnm,
*   l_field             TYPE rsvalue,
*   l_field_ext         TYPE rschavlext,
    l_s_cob_pro         TYPE rsd_s_cob_pro,
    l_s_comp            TYPE cl_abap_structdescr=>component,
    l_t_comp_dupl_chas  TYPE cl_abap_structdescr=>component_table,
    l_t_comp_aggr       TYPE cl_abap_structdescr=>component_table,

    l_r_structdescr     TYPE REF TO cl_abap_structdescr,
    lref_data           TYPE REF TO DATA.

* Select all InfoObject and determine their data type
  loop at I_T_IOBJNM into l_iobjnm.

    call function 'RSD_IOBJ_INCL_ATR_NAV_GET'

      exporting  I_IOBJNM       = l_iobjnm
      importing  E_S_COB_PRO    = l_s_cob_pro
      exceptions IOBJ_NOT_FOUND               = 1
                 ILLEGAL_INPUT                = 2
                 OTHERS                       = 3.

    if sy-subrc = 0.

      clear l_s_comp.
      l_s_comp-name  = l_s_cob_pro-iobjnm.
      l_s_comp-type ?= cl_abap_structdescr=>describe_by_name( p_name = l_s_cob_pro-dtelnm ).

      append l_s_comp TO l_t_comp_aggr.         "keyfigures wirh nuumeric data taypes P/F/I !

      if l_s_cob_pro-iobjtp <> rsd_c_objtp-keyfigure.
        append l_s_comp TO l_t_comp_dupl_chas.
      endif.
    else.
      raise INVALID_FIELD.
    endif.
  endloop.

* Dynamically create data:
* Only CHARACTERISTICS for identifying duplicates
  if lines( l_t_comp_dupl_chas ) > 0.

    l_r_structdescr = cl_rsr=>type_factory( i_t_comp_r = l_t_comp_dupl_chas ).
    create data E_REF_WA_DUPL_CHAS type handle l_r_structdescr.
    assign E_REF_WA_DUPL_CHAS->* to <wa>.

    create data E_REF_T_DUPL_CHAS like standard table of <wa>.
    clear: l_r_structdescr, <wa>.
  else.
    raise NO_FIELDS.
  endif.

* Dynamically create data:
* CHARACTERISTICS and KEYFIGURES with numeric data type for aggregation
  if lines( l_t_comp_aggr ) > 0.

    l_r_structdescr = cl_rsr=>type_factory( i_t_comp_r = l_t_comp_aggr ).
    create data E_REF_WA_AGGR type handle l_r_structdescr.
    assign E_REF_WA_AGGR->* to <wa>.

    create data E_REF_T_AGGR like standard table of <wa>.
    clear: l_r_structdescr, <wa>.
  else.
    raise NO_FIELDS.
  endif.

ENDMETHOD. "_CHECK_DUPLICATES_CREATE_DATA


method _CONVERT_AMOUNT.

  FIELD-SYMBOLS:
    <lf_kfy>       type ANY,
    <lf_curr>      type ANY,
    <ls_tcurx>     type TCURX.

  DATA:
    l_currency     type /BI0/OICURRENCY,
    l_amount       type P LENGTH 16 DECIMALS 5.

  E_SUBRC = 8.

* --------------------------------------------------------------------------
* - Get the currency related to the keyfigure
* --------------------------------------------------------------------------
  clear l_currency.

* The keyfigure has a fixed currency assigned
  if not I_S_TREATMENT_KYFS-FIXCUKY is initial.

    l_currency = I_S_TREATMENT_KYFS-FIXCUKY.

* The keyfigure has a currency object assigned
  else.
    if I_S_TREATMENT_KYFS-UNINM is initial.
*     ADD_MSG amount / unit
      RETURN.
    endif.

    assign component I_S_TREATMENT_KYFS-UNINM of structure C_S_DATA to <lf_curr>.
    if sy-subrc <> 0.
*     ADD_MSG
      RETURN.
    endif.
    l_currency = <lf_curr>.
  endif.

* Ensure, the currency is provided
  if l_currency is initial.
*   ADD_MSG
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Get the decimal specification for the currency related to the keyfigure
* --------------------------------------------------------------------------
  read table STH_CURX assigning <ls_tcurx>
    with key CURRKEY = l_currency.
  if sy-subrc <> 0.
*   ADD_MSG
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Convert the amount according to the specification
* --------------------------------------------------------------------------
  if <ls_tcurx>-CURRDEC <> 2.

    assign component I_KYF_NAME                "Keyfigure name
        of structure C_S_DATA to <lf_kfy>.
    if sy-subrc <> 0.
*     ADD_MSG
      RETURN.
    endif.

    l_amount = <lf_kfy>.

    CATCH SYSTEM-EXCEPTIONS:
      arithmetic_errors = 1
      OTHERS = 2.

      l_amount = l_amount * ( 10 ** ( <ls_tcurx>-CURRDEC - I_S_TREATMENT_KYFS-DECIMALS ) ).

    ENDCATCH.
    if sy-subrc <> 0.
      ADD_MSG_ID 'UPF' 'E' '065' I_S_TREATMENT_KYFS-TXTSH '' '' ''.
    endif.

    <lf_kfy> = l_amount.

  endif.

  clear E_SUBRC.

endmethod. "_CONVERT_AMOUNT


method _DCPFM.
* Convert keyfigures according to User Default "DeCimalPoint" and "ForMat"

  clear E_KYF.

  if not I_KYF is initial.

    E_KYF = I_KYF.

    if SS_USER_DEFAULTS-DCPFM is initial.       "for test purpeses only REMOVE !!!
      SS_USER_DEFAULTS-DCPFM = C_XUDCPFM-GER.   "for test purpeses only REMOVE !!!
    endif.                                      "for test purpeses only REMOVE !!!

    case SS_USER_DEFAULTS-DCPFM.

      when C_XUDCPFM-GER.    "1.234.567,89
                             replace all occurrences of '.' in E_KYF with ''  .
                             replace all occurrences of ',' in E_KYF with '.'.

      when C_XUDCPFM-US.     "1,234,567.89
                             replace all occurrences of ',' in E_KYF with ''.

      when C_XUDCPFM-GER2.   "1 234 567,89
                             replace all occurrences of ' ' in E_KYF with ''.
                             replace all occurrences of ',' in E_KYF with '.'.

    endcase.
  endif.

endmethod. "_DCPFM


METHOD _EXEC_DELETE_BAK.
* ----------------------------------------------------------------------------
* - Identifies both File ID's, original File Id and new File Id, by comparing
* - the restrictions on the File ID provided by the filter (original and
*  - new File Id) against the selected status record (original file Id).
* - Reads the content of the given (original) File ID from the CDM Upload
* - Cubes and creates a new File Id and assigns all neccessary characteristic
* - combinations described by the status record (old File Id) to the records
* - of the new File ID with all keyfigures set to Zero, except for the technical
* - keyfigure "Number of Records".
* - The new File ID is requested for update into the reporting layer.
* - The final status will be "Submitted".
* - The status of the original File Id changes to "Deleted".
* - In order to identify the File ID deleting the original File ID, the
* - Flag "Delete" is set to "X" for the deleting File Id. Additionaly,
* - the original File ID, which was deleted by the current Fild Id is
* - registered in the Field "Related File ID".
* - The status record of the origonal File Id, which was deleted is also
* - enriched by the deleting File Id, us-ing the same Field "Related File Id".
* -
*  - ----------------+------------+----------------------------+-----------------
*  - Unique File ID  |  Delte     | Generic File Upload Status | Related File ID
*  - ZXF_UFID        |  ZXF_FDEL  | ZXF_STAT                   | ZXF_RUFID
*  - ----------------+------------+----------------------------+-----------------
*  - 4711            |  #         | DELETED                    | 4753              "MS_FILEID_REL  <ls_status_rel>
*  - 4753            |  X         | SUBMITTED                  | 4711              "MS_FILEID      <ls_status>
* ----------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <LF_FIELD>        type ANY,

    <lwa_data>       type ANY,             "WORK AREA, not a pointer     Status record for given File Id
                                           "pointer into C_TH_DATA !!

    <lwa_data_rel>   type ANY,             "WORK AREA, not a pointer     Status record for related File Id (to be deleted!)
                                           "pointer into C_TH_DATA !!

*   <ls_status>      type ANY,             "the status record  as a pointer into a table, not a work area (given File Id)
    <ls_status_rel>  type ANY,             "the status record  as a pointer into a table, not a work area (related File Id -to be deleted!))
    <ls_target>      type ANY,             "the target records as a pointer into a table, not a work area

    <LT_STATUS>      type STANDARD TABLE,
    <LT_SOURCE>      type STANDARD TABLE,
    <LT_TARGET>      type STANDARD TABLE,
    <LT_RECMSG>      type STANDARD TABLE,
    <LT_OTHERS>      type STANDARD TABLE,

    <LT_DELETING>    type STANDARD TABLE.  "Records 'deleting' <LT_TARGET>; Copy of <LT_TARGET> with all keyfigures set to zero except for the <>

  DATA:
    l_subrc          type SYSUBRC,
    lref_data        type REF TO DATA,
    ls_btc_header    type /BIC/AZXF_E30100,
    lt_btc_targets   type Y0BW_XF_UP_BATCH_TARGETS_T.


* ----------------------------------------------------------------------------
* - Create a work area for the resulting record (s)
* ----------------------------------------------------------------------------
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data_rel>.  clear lref_data.  "Status record -> DELETED
  create data lref_data like                   I_S_BLOCK_LINE. assign lref_data->* to <lwa_data>.      clear lref_data.  "Status record -> SUBMITTED

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_STATUS>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_SOURCE>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_TARGET>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_OTHERS>.   clear lref_data.
  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_RECMSG>.   clear lref_data.

  create data lref_data like standard table of I_S_BLOCK_LINE. assign lref_data->* to <LT_DELETING>. clear lref_data.


* ----------------------------------------------------------------------------
* - Loop at C_TH_DATA and separate status from source records
* ----------------------------------------------------------------------------
  call method me->SEPARATE_SOURCE_TARGET_RECORDS

    exporting I_TH_DATA  = C_TH_DATA
              I_R_MSG    = I_R_MSG
    importing E_T_STATUS = <LT_STATUS>     "XF UP 301 Status Cube
              E_T_SOURCE = <LT_SOURCE>     "XF UP 302 Generic Upload Cube
              E_T_TARGET = <LT_TARGET>     "XF UP 304 CDM Upload Cube, and alike
              E_T_OTHERS = <LT_OTHERS>
              E_T_RECMSG = <LT_RECMSG>
              E_SUBRC    = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Read the status record
* --------------------------------------------------------------------------
  DATA ln_Lines type i.
  describe table <LT_STATUS> lines ln_Lines.
  if ln_Lines > 1.
*   302: More than one status record read.
    ADD_MSG 'E' '302' '' '' '' ''.
    RETURN.
  endif.

  read table <LT_STATUS> index 1 assigning <ls_status_rel>.
  if sy-subrc <> 0.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Submitted' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Fill the RELATED FILE ID from the current status record
* ----------------------------------------------------------------------------
  clear: MS_FILEID_REL, l_subrc.
  call method STATUS_GET_INTO_FILEID  exporting I_S_STATUS  = <ls_status_rel>
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_FILEID  = MS_FILEID_REL
                                                E_SUBRC     = l_subrc.
  if l_subrc <> 0.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check the status "SUBMITTED"
* --------------------------------------------------------------------------
  if MS_FILEID_REL-ZXF_STAT <> C_ZXF_STAT-SUBMITTED.
*   312: No status record with appropriate status '&' could be read.
    ADD_MSG 'E' '312' 'Submitted' '' '' ''.
    RETURN.
  endif.

* --------------------------------------------------------------------------
* - Check Flag: "Deleting Request"
* --------------------------------------------------------------------------
  if MS_FILEID_REL-ZXF_FDEL = rs_c_true.
*   404: The File Id '&' has deleted File Id '&'. "Delete" not possible.
    ADD_MSG 'E' '404' MS_FILEID_REL-ZXF_UFID
                      MS_FILEID_REL-ZXF_RUFID '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Read the FILE ID for the deleting request from the filter
* ----------------------------------------------------------------------------
  FIELD-SYMBOLS: <ls_data_charsel> type RSPLF_S_CHARSEL.
  loop at MT_DATA_CHARSEL assigning <ls_data_charsel>
    where IOBJNM = 'ZXF_UFID'.

*   Skip the File Id, that shall be deleted!
    if <ls_data_charsel>-LOW = MS_FILEID_REL-ZXF_UFID.
      CONTINUE.
    endif.

*   Read the File Id for the deleting request insetad
    EXIT.
  endloop.

  if <ls_data_charsel>-LOW is initial.
*   403: The File Id for the deleting request could not be read from Filter.
    ADD_MSG 'E' '403' '' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Initialize the FILE ID from the RELATED FILE ID
* ----------------------------------------------------------------------------
  clear MS_FILEID.

* Unique File ID
  MS_FILEID-ZXF_UFID      = <ls_data_charsel>-LOW.         "XF Unique File ID
  MS_FILEID-ZXF_LABEL     = MS_FILEID_REL-ZXF_LABEL.       "XF User defined Label for UFID
  MS_FILEID-ZXF_FERR      = MS_FILEID_REL-ZXF_FERR.        "Flag: Record erroneous
  MS_FILEID-ZXF_FDEL      = rs_c_true.                     "Flag: Delete Request
  MS_FILEID-ZXF_RUFID     = MS_FILEID_REL-ZXF_UFID.

* Status
  MS_FILEID-ZXF_STAT      = C_ZXF_STAT-SUBMITREQ.          "Generic File Upload Status

* Source Flag
  MS_FILEID-ZXF_DSF       = MS_FILEID_REL-ZXF_DSF.

* Statistics
  MS_FILEID-0TCTSYSID     = MS_FILEID_REL-0TCTSYSID.       "BW System
  MS_FILEID-ZXF_UPLBY     = SY-UNAME.                      "Loaded by
  MS_FILEID-ZXF_UPLD      = SY-DATUM.                      "Loaded Date
  MS_FILEID-ZXF_UPLT      = SY-UZEIT.                      "Loaded Time
  MS_FILEID-ZXF_SUBBY     = MS_FILEID-ZXF_UPLBY.           "Submitted by  / Request for Uodate into Reporting
  MS_FILEID-ZXF_REQD      = MS_FILEID-ZXF_UPLD.            "Requested Date
  MS_FILEID-ZXF_REQT      = MS_FILEID-ZXF_UPLT.            "Requested Time
* MS_FILEID-ZXF_SUBD                                       "Submitted Date   << Batch Update Status
* MS_FILEID-ZXF_SUBT                                       "Submitted Time  << Batch Update Status
* MS_FILEID-ZXF_CANBY                                      "Cancelled by
* MS_FILEID-ZXF_CAND                                       "Cancelled Date
* MS_FILEID-ZXF_CANT                                       "Cancelled Time
* MS_FILEID-ZXF_DELBY                                      "Deleted by
* MS_FILEID-ZXF_DELD                                       "Deleted Date
* MS_FILEID-ZXF_DELT                                       "Deleted Time

* Keyfigures
  MS_FILEID-ZXF_NFILE     = MS_FILEID_REL-ZXF_NFILE.       "Number of Files (Counter =1)
  MS_FILEID-0TCTNUMREC    = MS_FILEID_REL-0TCTNUMREC.      "Number of Records
  MS_FILEID-0TCTRECERR    = MS_FILEID_REL-0TCTRECERR.      "Number of Erroneous Records

  if <ls_data_charsel> is assigned. unassign <ls_data_charsel>. endif.

* ----------------------------------------------------------------------------
* - Return an error message in case no source records have been provided
* - in order to prevent the planning sequence from executing subsequent steps.
* ----------------------------------------------------------------------------
  read table <LT_TARGET> index 1 transporting no fields.
  if sy-subrc <> 0.
*   402: No source records provided for deletion! STOP subsequent steps.
    ADD_MSG 'E' '402' '' '' '' ''.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Loop at the file, which is to be deleted and create a list of data targets
* - depending on the Measure ID's in the file and create the deleting "Zero"
* - records with the new File ID read from the filter.
* ----------------------------------------------------------------------------
  DATA:
    ls_targets type Y0XFU_T_S_MEAS_CLUSTER,
    lt_targets type Y0XFU_T_T_MEAS_CLUSTER.

  free: <LT_DELETING>.

* loop at the records and create a comprehensive list of data clusters
  loop at <LT_TARGET> assigning <ls_target>.

    assign component 'ZXF_UFID' of structure <ls_target> to <LF_FIELD>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.
      ADD_MSG 'E' '305' 'ZXF_UFID' '' '' ''.
      RETURN.
    endif.

    if <LF_FIELD> <> MS_FILEID_REL-ZXF_UFID.
*     382: More than one Unique File Id: '&', '&'.
      ADD_MSG 'E' '382' MS_FILEID-ZXF_UFID <LF_FIELD> '' ''.
      RETURN.
    endif.

    assign component 'ZXF_MEAS' of structure <ls_target> to <LF_FIELD>.
    if sy-subrc <> 0.
*     305: Field Symbol '&' couldn't be assigned.
      ADD_MSG 'E' '305' 'ZXF_MEAS' '' '' ''.
      RETURN.
    endif.

    clear ls_targets.
    read table STH_MEAS_CLUSTER
      into ls_targets
      with key MEASID  = <LF_FIELD>.

    if sy-subrc <> 0.
*     381: Measure ID '&': Assignment to data cluster not maintained.
      ADD_MSG 'E' '381' <LF_FIELD> '' '' ''.
      RETURN.
    endif.

*   382: Parameter '&': '' not maintained in 'Y0BW_XF_DATA_CLS'.
    if ls_targets-DATA_CLUSTER  is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Data Cluster'           '' ''. RETURN. endif.
    if ls_targets-SRC_VIRT_PROV is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Virtual Source Cube'    '' ''. RETURN. endif.
    if ls_targets-SOURCE        is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Source CDM Upload Cube' '' ''. RETURN. endif.
    if ls_targets-TARGET        is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Target Changelog DSO'   '' ''. RETURN. endif.
    if ls_targets-PROCESS_CHAIN is initial. ADD_MSG 'E' '382' <LF_FIELD> 'Process Chain ID'       '' ''. RETURN. endif.

    clear ls_targets-MEASID.
    collect ls_targets into lt_targets.

*   Create a copy of the record and change the File Id
    clear <lwa_data>.
    <lwa_data> = <ls_target>.

    assign component 'ZXF_UFID' of structure <lwa_data> to <LF_FIELD>.
    if <LF_FIELD> is assigned.
      <LF_FIELD> = MS_FILEID-ZXF_UFID.
      unassign <LF_FIELD>.
    endif.
    assign component 'ZXF_AMNT' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
    assign component 'ZXF_NUMB' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
    assign component 'ZXF_QUAN' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
    assign component 'ZXF_AMNF' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
    assign component 'ZXF_NUMF' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
    assign component 'ZXF_QUAF' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
*   assign component 'ZXF_RCNT' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.  "ZRBZERO !
*   assign component 'ZXF_FCTR' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.
*   assign component 'ZXF_INTE' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.  "deleted
*   assign component 'ZXF_FLTP' of structure <lwa_data> to <LF_FIELD>. if <LF_FIELD> is assigned. clear <LF_FIELD>. unassign <LF_FIELD>. endif.  "deleted

    append <lwa_data> to <LT_DELETING>.
  endloop.

  append lines of <LT_DELETING> to <LT_TARGET>.
  free: <LT_DELETING>.
  clear <lwa_data>.

  if <ls_target> is assigned. unassign <ls_target>. endif.
  if <LF_FIELD>  is assigned. unassign <LF_FIELD>.  endif.
  clear: ls_targets.

* ----------------------------------------------------------------------------
* - Update RELATED FILE ID
* ----------------------------------------------------------------------------
  MS_FILEID_REL-ZXF_STAT  = C_ZXF_STAT-DELETEREQ."Delete Requested
  MS_FILEID_REL-ZXF_RUFID = MS_FILEID-ZXF_UFID.
  MS_FILEID_REL-ZXF_DELBY = MS_FILEID-ZXF_SUBBY.           "Submitted/Requested for Update by
  MS_FILEID_REL-ZXF_DRQD  = MS_FILEID-ZXF_REQD.            "Date and Time: Request for Update
  MS_FILEID_REL-ZXF_DRQT  = MS_FILEID-ZXF_REQT.
* MS_FILEID_REL-ZXF_DELD  = MS_FILEID-ZXF_REQD.            "Batch Update Status
* MS_FILEID_REL-ZXF_DELT  = MS_FILEID-ZXF_REQT.

* ----------------------------------------------------------------------------
* - Create a new request for update into the reporting layer (Deleting Req.)
* ----------------------------------------------------------------------------
  clear ls_btc_header.
  ls_btc_header-/BIC/ZXF_UFID   = MS_FILEID-ZXF_UFID.
  ls_btc_header-/BIC/ZXF_LABEL  = MS_FILEID-ZXF_LABEL.
  ls_btc_header-/BIC/ZXF_DSF    = MS_FILEID-ZXF_DSF.
  ls_btc_header-/BIC/ZXF_REQBY  = MS_FILEID-ZXF_SUBBY.
  ls_btc_header-/BIC/ZXF_REQD   = MS_FILEID-ZXF_REQD.
  ls_btc_header-/BIC/ZXF_REQT   = MS_FILEID-ZXF_REQT.
  ls_btc_header-/BIC/ZXF_RUFID  = MS_FILEID-ZXF_RUFID.
  ls_btc_header-/BIC/ZXF_FDEL   = MS_FILEID-ZXF_FDEL.

  clear l_subrc.
  free: lt_btc_targets.

* call method l_oref_batch->CREATE_NEW_REQUEST
  call method Y0BW_CL_XF_UP_BATCH_CTRL=>CREATE_NEW_REQUEST

    exporting  I_T_DATA_CLUSTER  = lt_targets                "XF UP: Data Cluster (Source/Target/Process Chain)
    importing  E_T_BTC_TARGETS   = lt_btc_targets
    changing   C_S_BTC_HEADER    = ls_btc_header             "XF UP D301 Batch Control Table, Header ( Direct Update )
    exceptions PARAMETER_EMPTY          = 1
               ENQUEUE_FAILED           = 2
               UFID_ALREADY_IN_USE      = 3
               DSO_INSERT_HEADER_FAILED = 4
               DSO_INSERT_DCLUST_FAILED = 5
               others                   = 6.

* 388: Request for Update into Rep. Layer failed: '&'.
  case sy-subrc.
    when 0. .
    when 1. ADD_MSG 'E' '388' 'PARAMETER_EMPTY'          '' '' ''. RETURN.
    when 2. ADD_MSG 'E' '388' 'ENQUEUE_FAILED'           '' '' ''. RETURN.
    when 3. ADD_MSG 'E' '388' 'UFID_ALREADY_IN_USE'      '' '' ''. RETURN.
    when 4. ADD_MSG 'E' '388' 'DSO_INSERT_HEADER_FAILED' '' '' ''. RETURN.
    when 5. ADD_MSG 'E' '388' 'DSO_INSERT_DCLUST_FAILED' '' '' ''. RETURN.
    when 6. ADD_MSG 'E' '388' 'OTHERS'                   '' '' ''. RETURN.
  endcase.

  clear ls_btc_header.
  free: lt_targets, lt_btc_targets.


* ----------------------------------------------------------------------------
* - Update Related Status Record
* ----------------------------------------------------------------------------
  clear <lwa_data_rel>.
  <lwa_data_rel> = <ls_status_rel>.

  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID_REL
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data_rel>
                                                E_SUBRC     = l_subrc.

  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Create Status Record from Related Status Record
* ----------------------------------------------------------------------------
  clear <lwa_data>.
  <lwa_data> = <ls_status_rel>.

  clear: l_subrc.
  call method STATUS_SET_FROM_FILEID  exporting I_S_FILEID  = MS_FILEID
                                                I_R_MSG     = I_R_MSG
                                      importing E_S_STATUS  = <lwa_data>
                                                E_SUBRC     = l_subrc.

  if l_subrc <> 0.
*   389: Internal error: '&'.
    ADD_MSG 'E' '389' 'STATUS_SET_FROM_FILEID' '' '' ''. RETURN.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Return records
* ----------------------------------------------------------------------------
  free: C_TH_DATA[].

  insert          <lwa_data>      into table C_TH_DATA.
  insert          <lwa_data_rel>  into table C_TH_DATA.
  insert lines of <LT_SOURCE>     into table C_TH_DATA.
  insert lines of <LT_TARGET>     into table C_TH_DATA.
  insert lines of <LT_RECMSG>     into table C_TH_DATA.
  insert lines of <LT_OTHERS>     into table C_TH_DATA.

  free:
    <lwa_data>, <lwa_data_rel>.
  free:
    <LT_STATUS>, <LT_SOURCE>, <LT_TARGET>, <LT_RECMSG>, <LT_OTHERS>, <LT_DELETING>.

* ----------------------------------------------------------------------------
* - Start Job
* ----------------------------------------------------------------------------
*  DATA: lf_logid type RSPC_LOGID.
*  CALL FUNCTION 'RSPC_API_CHAIN_START'
*    EXPORTING
*      I_CHAIN             = 'ZXF_WW_A_00_TD00'
*      I_DONT_WAIT         = rs_c_true
*    IMPORTING
*     E_LOGID             = lf_logid
*     EXCEPTIONS
*       FAILED              = 1
*       OTHERS              = 2.

* ----------------------------------------------------------------------------
* - Start Job ( 4 ) FuBa (wird vom Programm benutzt)
* ----------------------------------------------------------------------------
  DATA:
    l_ZXF_UFID         type  /BIC/OIZXF_UFID,
    l_ZXF_RUND         type  /BIC/OIZXF_RUND,
    l_ZXF_RUNT         type  /BIC/OIZXF_RUNT,
    ls_BATCH_HEADER    type  /BIC/AZXF_E30100,
    lt_BATCH_TARGETS   type  Y0BW_XF_UP_BATCH_TARGETS_T.

* Start Job
  clear: l_ZXF_UFID, ls_BATCH_HEADER.
  free: lt_BATCH_TARGETS.

* Start Job
  CALL FUNCTION 'Y0BW_XF_UP_START_JOB'
    IMPORTING
      E_ZXF_UFID                     = l_ZXF_UFID
      E_ZXF_RUND                     = l_ZXF_RUND
      E_ZXF_RUNT                     = l_ZXF_RUNT
      E_S_BATCH_HEADER               = ls_BATCH_HEADER
      E_T_BATCH_TARGETS              = lt_BATCH_TARGETS
    EXCEPTIONS
*     JOB_STARTED                    = 0     "OK
      ENQUEUE_FAILED                 = 1     "Failed to start a job due to lock issues !!!!!
      STILL_ACTIVE                   = 2     "OK
      NO_MORE_REQUESTS               = 3     "OK (a terminated job started the job once again)
      NO_DATA_CLUSTER                = 4     "Failed to start a job for Update into Reporting !!!!!
      DSO_UPDATE_HEADER_FAILED       = 5     "Failed to start a job for Update into Reporting !!!!!
      DSO_UPDATE_DCLUST_FAILED       = 6     "Failed to start a job for Update into Reporting !!!!!
      START_CHAIN_FAILED             = 7     "Failed to Start Process Chain
      OTHERS                         = 8.

* l_ZXF_UFID = MS_FILEID-ZXF_UFID ?

  case sy-subrc.

*   395: Job Started for Update into Reporting.
    when 0.                                                          "JOB_STARTED
      ADD_MSG 'I' '395' '' '' '' ''.

*   396: Job for Update into Reporting still active. Wait.
    when 2.                                                          "STILL_ACTIVE
      ADD_MSG 'I' '396' '' '' '' ''.

*   397: Job for Update into Reporting already processed.
    when 3.                                                          "NO_MORE_REQUESTS
      ADD_MSG 'I' '397' '' '' '' ''.

*   398: Failed to start a job for Update into Reporting '&'.
    WHEN 1. ADD_MSG 'W' '398' 'ENQUEUE_FAILED'           '' '' ''.
    WHEN 4. ADD_MSG 'W' '398' 'NO_DATA_CLUSTER'          '' '' ''.
    WHEN 5. ADD_MSG 'W' '398' 'DSO_UPDATE_HEADER_FAILED' '' '' ''.
    WHEN 6. ADD_MSG 'W' '398' 'DSO_UPDATE_DCLUST_FAILED' '' '' ''.

*   399: Start Chain FAILED for Update into Reporting.
    WHEN 7.
      ADD_MSG 'W' '399' '' '' '' ''.

  endcase.


ENDMETHOD. "_EXEC_DELETE_BAK


method _GET_FROM_REC_PHYS_KEY_FIGURE.

  DATA:
    l_subrc      type SYSUBRC,
    l_ZXF_MEAS   type /BIC/OIZXF_MEAS,
    ls_meas_id   type Y0BW_XF_MEAS_ID.

  clear E_PHYS_KEY_FIGURE.
  E_SUBRC = 8.

* ----------------------------------------------------------------------------
* - Look up the Measure Id in the record and read the master data record
* ----------------------------------------------------------------------------
  clear: l_subrc, l_ZXF_MEAS, ls_meas_id.
  call method _GET_FROM_REC_ZXF_MEAS

      exporting I_S_REC     = I_S_REC
                I_B_CDM     = I_B_CDM
                I_R_MSG     = I_R_MSG
                I_VALID_MD  = rs_c_true
                I_LOG_MSG   = rs_c_false
      importing E_ZXF_MEAS  = l_ZXF_MEAS
                E_S_MEAS_ID = ls_meas_id
                E_SUBRC     = l_subrc.


  if l_subrc <> 0.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Each Measure Id must have assigned a Physical Keyfigure
* ----------------------------------------------------------------------------
  if ls_meas_id-PHYS_KEY_FIGURE is initial.

*   360: Record '&' Physical Key Figure not maintained for Measure Id '&'.
    ADD_REC_MSG 'E' '360' I_RECNO l_ZXF_MEAS '' ''.
    RETURN.
  endif.


  E_PHYS_KEY_FIGURE = ls_meas_id-PHYS_KEY_FIGURE.
  clear E_SUBRC.

  clear ls_meas_id.

endmethod. "_GET_ZXF_MEAS_FROM_REC


method _GET_FROM_REC_ZXF_MEAS.
* ----------------------------------------------------------------------------
* - 305: Field Symbol '&' couldn't be assigned.
* - 322: A column header for the Measure ID is mandatory.
* - 341: Record '&' has invalid master data '&' for characteristic '&'.
* - 351: Record '&' has no Measure ID.
* ----------------------------------------------------------------------------


  FIELD-SYMBOLS:
    <LF_FIELD>        type ANY,
    <ls_meas_id>      type Y0BW_XF_MEAS_ID,
    <ls_head_to_dim>  type T_S_HEAD_TO_DIM.

  DATA:
    ln_RecNo          type I,
    l_ZXF_MEAS        type /BIC/OIZXF_MEAS.      " 'Measure ID'

  clear:
    E_ZXF_MEAS,
    E_S_MEAS_ID.

  E_SUBRC = 8.

* ----------------------------------------------------------------------------
* - Access Field "Measure Id" in the record
* ----------------------------------------------------------------------------
  if <LF_FIELD> is assigned. unassign <LF_FIELD>. endif.

* Structure: CDM Upload Cube
  if I_B_CDM = rs_c_true.

    assign component 'ZXF_MEAS' of structure I_S_REC to <LF_FIELD>.

* Structure: Upload Cube
  else.

    read table MTH_HEAD_TO_DIM_CHAS assigning <ls_head_to_dim>
      with key DIMNM      = 'ZXF_MEAS'.
*              COL_HEADER = MEASUREID
    if sy-subrc <> 0.                                               "We should have passed the structural validation
      if I_LOG_MSG = rs_c_true.                                     "already. Nevertheless, ..
*       322: A column header for the Measure ID is mandatory.
        ADD_MSG 'W' '322' '' '' '' ''.
*       351: Record '&' has no Measure ID.
        ADD_REC_MSG 'W' '351' I_RECNO '' '' ''.
        RETURN.
      endif.
    else.
      assign component <ls_head_to_dim>-FIELDNM_SRC of structure I_S_REC to <LF_FIELD>.
    endif.
  endif.

  if not <LF_FIELD> is assigned.
    if I_LOG_MSG = rs_c_true.
*     305: Field Symbol '&' couldn't be assigned.
      ADD_MSG 'W' '305' '' '' '' ''.
*     351: Record '&' has no Measure ID.
      ADD_REC_MSG 'W' '351' I_RECNO '' '' ''.
    endif.
    RETURN.
  endif.
  l_ZXF_MEAS = <LF_FIELD>.
  unassign <LF_FIELD>.


* ----------------------------------------------------------------------------
* - Ensure, the Measure Id is known
* ----------------------------------------------------------------------------
  if l_ZXF_MEAS is initial.
    if I_LOG_MSG = rs_c_true.
*     351: Record '&' has no Measure ID.
      ADD_REC_MSG 'W' '351' I_RECNO '' '' ''.
    endif.
    RETURN.
  endif.

* ----------------------------------------------------------------------------
* - Verify Master Data for the Measure ID
* ----------------------------------------------------------------------------
  if I_VALID_MD = rs_c_true.

*   Look up the Measure Id
    read table STH_MEAS_ID assigning <ls_meas_id>

         with key MEASID  = l_ZXF_MEAS
                  OBJVERS = RS_C_OBJVERS-ACTIVE.

    if sy-subrc <> 0.                                          "mustn't pass validation !
      if I_LOG_MSG = rs_c_true.
*       341: Record '&' has invalid master data '&' for characteristic '&'.
        ADD_REC_MSG 'W' '341' I_RECNO l_ZXF_MEAS 'Measure Id' ''.
*       351: Record '&' has no Measure ID.
        ADD_REC_MSG 'W' '351' I_RECNO '' '' ''.      endif.
      RETURN.
    endif.
  endif.

* Return Measure ID
  E_ZXF_MEAS  = l_ZXF_MEAS.
  clear l_ZXF_MEAS.

* Return Master Data Record, if required
  if E_ZXF_MEAS is supplied.

    if <ls_meas_id> is assigned.    "I_VALID_MD = 'X': validation mus be required
      E_S_MEAS_ID = <ls_meas_id>.
      unassign <ls_meas_id>.
    endif.

  endif.

  clear E_SUBRC.

endmethod. "_GET_ZXF_MEAS_FROM_REC


method _GET_TIME.


 clear R_TIME_STR.

  CONSTANTS:
    lc_timezone type ttzz-tzone value 'CET'.

  DATA:
    l_time_str(60) type c,
    l_str          type string.

  DATA:
    l_date     type d,
    l_time     type t,
    l_dst      type c,

    l_tsl type timestampl. "YYYYMMDDhhmmss.mmmuuun


  get time stamp field l_tsl. l_str = l_tsl.

  convert time stamp l_tsl  time zone lc_timezone
    into date l_date
         time l_time daylight saving time l_dst.

           concatenate l_time+0(2)
                       l_time+2(2)
                       l_time+4(2)
                       l_str+15(3)
             into R_TIME_STR separated by ':'.


endmethod.
ENDCLASS.